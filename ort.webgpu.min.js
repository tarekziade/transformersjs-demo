/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Un=Object.defineProperty;var nm=Object.getOwnPropertyDescriptor;var am=Object.getOwnPropertyNames;var om=Object.prototype.hasOwnProperty;var oe=(e,r)=>()=>(e&&(r=e(e=0)),r);var Pr=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),Br=(e,r)=>{for(var t in r)Un(e,t,{get:r[t],enumerable:!0})},sm=(e,r,t,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of am(r))!om.call(e,a)&&a!==t&&Un(e,a,{get:()=>r[a],enumerable:!(s=nm(r,a))||s.enumerable});return e};var sr=e=>sm(Un({},"__esModule",{value:!0}),e);var an,ur,Lt,on,sn=oe(()=>{"use strict";an=new Map,ur=[],Lt=(e,r,t)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let s=an.get(e);if(s===void 0)an.set(e,{backend:r,priority:t});else{if(s.priority>t)return;if(s.priority===t&&s.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${t}`)}if(t>=0){let a=ur.indexOf(e);a!==-1&&ur.splice(a,1);for(let f=0;f<ur.length;f++)if(an.get(ur[f]).priority<=t){ur.splice(f,0,e);return}ur.push(e)}return}throw new TypeError("not a valid backend")},on=async e=>{let r=e.length===0?ur:e,t=[];for(let s of r){let a=an.get(s);if(a){if(a.initialized)return a.backend;if(a.aborted)continue;let f=!!a.initPromise;try{return f||(a.initPromise=a.backend.init()),await a.initPromise,a.initialized=!0,a.backend}catch(p){f||t.push({name:s,err:p}),a.aborted=!0}finally{delete a.initPromise}}}throw new Error(`no available backend found. ERR: ${t.map(s=>`[${s.name}] ${s.err}`).join(", ")}`)}});var $s=oe(()=>{"use strict";sn()});var Cs,_s=oe(()=>{"use strict";Cs="1.17.0"});var Ss,Hn,xs=oe(()=>{"use strict";_s();Ss="warning",Hn={wasm:{},webgl:{},webgpu:{},versions:{common:Cs},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ss=e}},get logLevel(){return Ss}};Object.defineProperty(Hn,"logLevel",{enumerable:!0})});var Ve,Is=oe(()=>{"use strict";xs();Ve=Hn});var As,Es,Ts=oe(()=>{"use strict";As=(e,r)=>{let t=document.createElement("canvas");t.width=e.dims[3],t.height=e.dims[2];let s=t.getContext("2d");if(s!=null){let a,f;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(a=e.dims[2],f=e.dims[3]):(a=e.dims[3],f=e.dims[2]);let p=r?.format!==void 0?r.format:"RGB",g=r?.norm,u,w;g===void 0||g.mean===void 0?u=[255,255,255,255]:typeof g.mean=="number"?u=[g.mean,g.mean,g.mean,g.mean]:(u=[g.mean[0],g.mean[1],g.mean[2],0],g.mean[3]!==void 0&&(u[3]=g.mean[3])),g===void 0||g.bias===void 0?w=[0,0,0,0]:typeof g.bias=="number"?w=[g.bias,g.bias,g.bias,g.bias]:(w=[g.bias[0],g.bias[1],g.bias[2],0],g.bias[3]!==void 0&&(w[3]=g.bias[3]));let C=f*a,T=0,x=C,O=C*2,k=-1;p==="RGBA"?(T=0,x=C,O=C*2,k=C*3):p==="RGB"?(T=0,x=C,O=C*2):p==="RBG"&&(T=0,O=C,x=C*2);for(let P=0;P<f;P++)for(let D=0;D<a;D++){let M=(e.data[T++]-w[0])*u[0],z=(e.data[x++]-w[1])*u[1],G=(e.data[O++]-w[2])*u[2],L=k===-1?255:(e.data[k++]-w[3])*u[3];s.fillStyle="rgba("+M+","+z+","+G+","+L+")",s.fillRect(D,P,1,1)}return t.toDataURL()}else throw new Error("Can not access image data")},Es=(e,r)=>{let t=document.createElement("canvas").getContext("2d"),s;if(t!=null){let a,f,p;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(a=e.dims[2],f=e.dims[1],p=e.dims[3]):(a=e.dims[3],f=e.dims[2],p=e.dims[1]);let g=r!==void 0&&r.format!==void 0?r.format:"RGB",u=r?.norm,w,C;u===void 0||u.mean===void 0?w=[255,255,255,255]:typeof u.mean=="number"?w=[u.mean,u.mean,u.mean,u.mean]:(w=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(w[3]=u.mean[3])),u===void 0||u.bias===void 0?C=[0,0,0,0]:typeof u.bias=="number"?C=[u.bias,u.bias,u.bias,u.bias]:(C=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(C[3]=u.bias[3]));let T=f*a;if(r!==void 0&&(r.format!==void 0&&p===4&&r.format!=="RGBA"||p===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let x=4,O=0,k=1,P=2,D=3,M=0,z=T,G=T*2,L=-1;g==="RGBA"?(M=0,z=T,G=T*2,L=T*3):g==="RGB"?(M=0,z=T,G=T*2):g==="RBG"&&(M=0,G=T,z=T*2),s=t.createImageData(a,f);for(let Y=0;Y<f*a;O+=x,k+=x,P+=x,D+=x,Y++)s.data[O]=(e.data[M++]-C[0])*w[0],s.data[k]=(e.data[z++]-C[1])*w[1],s.data[P]=(e.data[G++]-C[2])*w[2],s.data[D]=L===-1?255:(e.data[L++]-C[3])*w[3]}else throw new Error("Can not access image data");return s}});var Ln,Os,ks,Rs,Ps,Bs=oe(()=>{"use strict";un();Ln=(e,r)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:t,width:s}=r,a=r.norm??{mean:255,bias:0},f,p;typeof a.mean=="number"?f=[a.mean,a.mean,a.mean,a.mean]:f=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?p=[a.bias,a.bias,a.bias,a.bias]:p=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let g=r.format!==void 0?r.format:"RGBA",u=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",w=t*s,C=u==="RGBA"?new Float32Array(w*4):new Float32Array(w*3),T=4,x=0,O=1,k=2,P=3,D=0,M=w,z=w*2,G=-1;g==="RGB"&&(T=3,x=0,O=1,k=2,P=-1),u==="RGBA"?G=w*3:u==="RBG"?(D=0,z=w,M=w*2):u==="BGR"&&(z=0,M=w,D=w*2);for(let Y=0;Y<w;Y++,x+=T,k+=T,O+=T,P+=T)C[D++]=(e[x]+p[0])/f[0],C[M++]=(e[O]+p[1])/f[1],C[z++]=(e[k]+p[2])/f[2],G!==-1&&P!==-1&&(C[G++]=(e[P]+p[3])/f[3]);return u==="RGBA"?new lt("float32",C,[1,4,t,s]):new lt("float32",C,[1,3,t,s])},Os=async(e,r)=>{let t=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,f=typeof e=="string",p,g=r??{};if(t){let u=document.createElement("canvas");u.width=e.width,u.height=e.height;let w=u.getContext("2d");if(w!=null){let C=e.height,T=e.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(C=r.resizedHeight,T=r.resizedWidth),r!==void 0){if(g=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");g.tensorFormat="RGBA",g.height=C,g.width=T}else g.tensorFormat="RGBA",g.height=C,g.width=T;w.drawImage(e,0,0),p=w.getImageData(0,0,T,C).data}else throw new Error("Can not access image data")}else if(s){let u,w;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(u=r.resizedHeight,w=r.resizedWidth):(u=e.height,w=e.width),r!==void 0&&(g=r),g.format="RGBA",g.height=u,g.width=w,r!==void 0){let C=document.createElement("canvas");C.width=w,C.height=u;let T=C.getContext("2d");if(T!=null)T.putImageData(e,0,0),p=T.getImageData(0,0,w,u).data;else throw new Error("Can not access image data")}else p=e.data}else if(a){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=document.createElement("canvas");u.width=e.width,u.height=e.height;let w=u.getContext("2d");if(w!=null){let C=e.height,T=e.width;return w.drawImage(e,0,0,T,C),p=w.getImageData(0,0,T,C).data,g.height=C,g.width=T,Ln(p,g)}else throw new Error("Can not access image data")}else{if(f)return new Promise((u,w)=>{let C=document.createElement("canvas"),T=C.getContext("2d");if(!e||!T)return w();let x=new Image;x.crossOrigin="Anonymous",x.src=e,x.onload=()=>{C.width=x.width,C.height=x.height,T.drawImage(x,0,0,C.width,C.height);let O=T.getImageData(0,0,C.width,C.height);g.height=C.height,g.width=C.width,u(Ln(O.data,g))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(p!==void 0)return Ln(p,g);throw new Error("Input data provided is not supported - aborted tensor creation")},ks=(e,r)=>{let{width:t,height:s,download:a,dispose:f}=r,p=[1,s,t,4];return new lt({location:"texture",type:"float32",texture:e,dims:p,download:a,dispose:f})},Rs=(e,r)=>{let{dataType:t,dims:s,download:a,dispose:f}=r;return new lt({location:"gpu-buffer",type:t??"float32",gpuBuffer:e,dims:s,download:a,dispose:f})},Ps=(e,r,t)=>new lt({location:"cpu-pinned",type:e,data:r,dims:t??[r.length]})});var _i,ln,Ms,js,Ds=oe(()=>{"use strict";_i=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),ln=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Ms=!1,js=()=>{if(!Ms){Ms=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",r=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(_i.set("int64",BigInt64Array),ln.set(BigInt64Array,"int64")),r&&(_i.set("uint64",BigUint64Array),ln.set(BigUint64Array,"uint64"))}}});var zs,Ws,Vs=oe(()=>{"use strict";un();zs=e=>{let r=1;for(let t=0;t<e.length;t++){let s=e[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);r*=s}return r},Ws=(e,r)=>{switch(e.location){case"cpu":return new lt(e.type,e.data,r);case"cpu-pinned":return new lt({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new lt({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new lt({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var lt,un=oe(()=>{"use strict";Ts();Bs();Ds();Vs();lt=class{constructor(r,t,s){js();let a,f;if(typeof r=="object"&&"location"in r)switch(this.dataLocation=r.location,a=r.type,f=r.dims,r.location){case"cpu-pinned":{let g=_i.get(a);if(!g)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(r.data instanceof g))throw new TypeError(`buffer should be of type ${g.name}`);this.cpuData=r.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=r.texture,this.downloader=r.download,this.disposer=r.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=r.gpuBuffer,this.downloader=r.download,this.disposer=r.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let g,u;if(typeof r=="string")if(a=r,u=s,r==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");g=t}else{let w=_i.get(r);if(w===void 0)throw new TypeError(`Unsupported tensor type: ${r}.`);if(Array.isArray(t)){if(r==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");r==="uint64"||r==="int64"?g=w.from(t,BigInt):g=w.from(t)}else if(t instanceof w)g=t;else throw new TypeError(`A ${a} tensor's data must be type of ${w}`)}else if(u=t,Array.isArray(r)){if(r.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let w=typeof r[0];if(w==="string")a="string",g=r;else if(w==="boolean")a="bool",g=Uint8Array.from(r);else throw new TypeError(`Invalid element type of data array: ${w}.`)}else{let w=ln.get(r.constructor);if(w===void 0)throw new TypeError(`Unsupported type for tensor data: ${r.constructor}.`);a=w,g=r}if(u===void 0)u=[g.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");f=u,this.cpuData=g,this.dataLocation="cpu"}let p=zs(f);if(this.cpuData&&p!==this.cpuData.length)throw new Error(`Tensor's size(${p}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=f,this.size=p}static async fromImage(r,t){return Os(r,t)}static fromTexture(r,t){return ks(r,t)}static fromGpuBuffer(r,t){return Rs(r,t)}static fromPinnedBuffer(r,t,s){return Ps(r,t,s)}toDataURL(r){return As(this,r)}toImageData(r){return Es(this,r)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(r){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,r&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(r){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ws(this,r)}}});var ot,dn=oe(()=>{"use strict";un();ot=lt});var cn,Ns=oe(()=>{"use strict";sn();dn();cn=class e{constructor(r){this.handler=r}async run(r,t,s){let a={},f={};if(typeof r!="object"||r===null||r instanceof ot||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let p=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof ot)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");p=!1;for(let w of t){if(typeof w!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(w)===-1)throw new RangeError(`'fetches' contains invalid output name: ${w}.`);a[w]=null}if(typeof s=="object"&&s!==null)f=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let w=!1,C=Object.getOwnPropertyNames(t);for(let T of this.outputNames)if(C.indexOf(T)!==-1){let x=t[T];(x===null||x instanceof ot)&&(w=!0,p=!1,a[T]=x)}if(w){if(typeof s=="object"&&s!==null)f=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else f=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let w of this.inputNames)if(typeof r[w]>"u")throw new Error(`input '${w}' is missing in 'feeds'.`);if(p)for(let w of this.outputNames)a[w]=null;let g=await this.handler.run(r,a,f),u={};for(let w in g)if(Object.hasOwnProperty.call(g,w)){let C=g[w];C instanceof ot?u[w]=C:u[w]=new ot(C.type,C.data,C.dims)}return u}async release(){return this.handler.dispose()}static async create(r,t,s,a){let f,p={};if(typeof r=="string"){if(f=r,typeof t=="object"&&t!==null)p=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(f=r,typeof t=="object"&&t!==null)p=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let T=r,x=0,O=r.byteLength;if(typeof t=="object"&&t!==null)p=t;else if(typeof t=="number"){if(x=t,!Number.isSafeInteger(x))throw new RangeError("'byteOffset' must be an integer.");if(x<0||x>=T.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${T.byteLength}).`);if(O=r.byteLength-x,typeof s=="number"){if(O=s,!Number.isSafeInteger(O))throw new RangeError("'byteLength' must be an integer.");if(O<=0||x+O>T.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${T.byteLength-x}].`);if(typeof a=="object"&&a!==null)p=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");f=new Uint8Array(T,x,O)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let u=(p.executionProviders||[]).map(T=>typeof T=="string"?T:T.name),C=await(await on(u)).createInferenceSessionHandler(f,p);return new e(C)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var um,Us=oe(()=>{"use strict";Ns();um=cn});var Hs=oe(()=>{"use strict"});var lm,fn,Ls=oe(()=>{"use strict";sn();dn();lm="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",fn=class e{constructor(r){this.handler=r}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(r,t){let s=r.evalModel||"",a=r.optimizerModel||"",f=t||{},g=(f.executionProviders||[]).map(w=>typeof w=="string"?w:w.name),u=await on(g);if(u.createTrainingSessionHandler){let w=await u.createTrainingSessionHandler(r.checkpointState,r.trainModel,s,a,f);return new e(w)}else throw new Error(lm)}typeNarrowingForRunStep(r,t,s){let a={},f={};if(typeof r!="object"||r===null||r instanceof ot||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let p=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof ot)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");p=!1;for(let g of t){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);a[g]=null}if(typeof s=="object"&&s!==null)f=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,u=Object.getOwnPropertyNames(t);for(let w of this.outputNames)if(u.indexOf(w)!==-1){let C=t[w];(C===null||C instanceof ot)&&(g=!0,p=!1,a[w]=C)}if(g){if(typeof s=="object"&&s!==null)f=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else f=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of this.inputNames)if(typeof r[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(p)for(let g of this.outputNames)a[g]=null;return[a,f]}convertHandlerReturnTypeToMapOfTensors(r){let t={};for(let s in r)if(Object.hasOwnProperty.call(r,s)){let a=r[s];a instanceof ot?t[s]=a:t[s]=new ot(a.type,a.data,a.dims)}return t}async runTrainStep(r,t,s){let[a,f]=this.typeNarrowingForRunStep(r,t,s),p=await this.handler.runTrainStep(r,a,f);return this.convertHandlerReturnTypeToMapOfTensors(p)}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,t=!0){let s=await this.getParametersSize(t);if(r.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,t)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}});var dm,Gs=oe(()=>{"use strict";Ls();dm=fn});var Gn={};Br(Gn,{InferenceSession:()=>um,Tensor:()=>ot,TrainingSession:()=>dm,env:()=>Ve,registerBackend:()=>Lt});var Ut=oe(()=>{"use strict";$s();Is();Us();dn();Hs();Gs()});var Fn={};Br(Fn,{readFile:()=>cm});var cm,qn=oe(()=>{cm=void 0});var Kn={};Br(Kn,{join:()=>fm});var fm,Yn=oe(()=>{fm=void 0});var Ys=Pr((Ks,Xn)=>{"use strict";var qs=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(r={}){var t=r,s,a;t.ready=new Promise((i,n)=>{s=i,a=n}),t.jsepInit=(i,n,o,l,d,h,m,y)=>{t.zh=i,t.ph=n,t.rh=o,t.eh=l,t.qh=d,t.Cd=h,t.sh=m,t.th=y,n=(b,$,_)=>(...E)=>{let R=gt,S=$?.();E=b(...E);let j=$?.();return S!==j&&(b=j,_(S),$=_=null),gt!=R?Di():E},o=b=>async(...$)=>{try{if(t.Xg)throw Error("Session already started");let _=t.Xg={uh:$[0],errors:[]},E=await b(...$);if(t.Xg!==_)throw Error("Session mismatch");i.flush();let R=_.errors;if(0<R.length){let S=await Promise.all(R);if(S=S.filter(j=>j),0<S.length)throw Error(S.join(`
`))}return E}finally{t.Xg=null}},t._OrtRun=o(n(t._OrtRun,()=>t._OrtRun,b=>t._OrtRun=b)),t._OrtRunWithBinding=o(n(t._OrtRunWithBinding,()=>t._OrtRunWithBinding,b=>t._OrtRunWithBinding=b)),t._OrtBindInput=n(t._OrtBindInput,()=>t._OrtBindInput,b=>t._OrtBindInput=b),t.jsepRegisterBuffer=(b,$,_,E)=>i.registerBuffer(b,$,_,E),t.jsepUnregisterBuffers=b=>{i.unregisterBuffers(b)},t.jsepGetBuffer=b=>i.getBuffer(b),t.jsepCreateDownloader=(b,$,_)=>i.createDownloader(b,$,_)};var f=Object.assign({},t),p="./this.program",g=(i,n)=>{throw n},u=typeof window=="object",w=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T="",x,O,k;if(C){var P=(qn(),sr(Fn)),D=(Yn(),sr(Kn));T=w?D.dirname(T)+"/":__dirname+"/",x=(i,n)=>(i=i.startsWith("file://")?new URL(i):D.normalize(i),P.readFileSync(i,n?void 0:"utf8")),k=i=>(i=x(i,!0),i.buffer||(i=new Uint8Array(i)),i),O=(i,n,o,l=!0)=>{i=i.startsWith("file://")?new URL(i):D.normalize(i),P.readFile(i,l?void 0:"utf8",(d,h)=>{d?o(d):n(l?h.buffer:h)})},!t.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),g=(i,n)=>{throw process.exitCode=i,n},t.inspect=()=>"[Emscripten Module object]"}else(u||w)&&(w?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),e&&(T=e),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",x=i=>{var n=new XMLHttpRequest;return n.open("GET",i,!1),n.send(null),n.responseText},w&&(k=i=>{var n=new XMLHttpRequest;return n.open("GET",i,!1),n.responseType="arraybuffer",n.send(null),new Uint8Array(n.response)}),O=(i,n,o)=>{var l=new XMLHttpRequest;l.open("GET",i,!0),l.responseType="arraybuffer",l.onload=()=>{l.status==200||l.status==0&&l.response?n(l.response):o()},l.onerror=o,l.send(null)});var M=t.print||console.log.bind(console),z=t.printErr||console.error.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(g=t.quit);var G;t.wasmBinary&&(G=t.wasmBinary);var L=t.noExitRuntime||!0;typeof WebAssembly!="object"&&nt("no native wasm support detected");var Y,A,Z=!1,J,re,fe,F,ae,_e,he;function Pe(){var i=Y.buffer;t.HEAP8=re=new Int8Array(i),t.HEAP16=new Int16Array(i),t.HEAP32=F=new Int32Array(i),t.HEAPU8=fe=new Uint8Array(i),t.HEAPU16=new Uint16Array(i),t.HEAPU32=ae=new Uint32Array(i),t.HEAPF32=_e=new Float32Array(i),t.HEAPF64=he=new Float64Array(i)}var ue=[],Be=[],Me=[];function je(){var i=t.preRun.shift();ue.unshift(i)}var Ae=0,At=null,it=null;function nt(i){throw t.onAbort&&t.onAbort(i),i="Aborted("+i+")",z(i),Z=!0,J=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),a(i),i}function ie(i){return i.startsWith("data:application/octet-stream;base64,")}var we;if(we="ort-wasm-simd.wasm",!ie(we)){var Ie=we;we=t.locateFile?t.locateFile(Ie,T):T+Ie}function rt(i){if(i==we&&G)return new Uint8Array(G);if(k)return k(i);throw"both async and sync fetching of the wasm failed"}function dt(i){if(!G&&(u||w)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(n=>{if(!n.ok)throw"failed to load wasm binary file at '"+i+"'";return n.arrayBuffer()}).catch(()=>rt(i));if(O)return new Promise((n,o)=>{O(i,l=>n(new Uint8Array(l)),o)})}return Promise.resolve().then(()=>rt(i))}function qe(i,n,o){return dt(i).then(l=>WebAssembly.instantiate(l,n)).then(l=>l).then(o,l=>{z("failed to asynchronously prepare wasm: "+l),nt(l)})}function Je(i,n){var o=we;return G||typeof WebAssembly.instantiateStreaming!="function"||ie(o)||o.startsWith("file://")||C||typeof fetch!="function"?qe(o,i,n):fetch(o,{credentials:"same-origin"}).then(l=>WebAssembly.instantiateStreaming(l,i).then(n,function(d){return z("wasm streaming compile failed: "+d),z("falling back to ArrayBuffer instantiation"),qe(o,i,n)}))}var ut,Et={1336376:i=>{t.Cd("Abs",i,void 0)},1336427:i=>{t.Cd("Neg",i,void 0)},1336478:i=>{t.Cd("Floor",i,void 0)},1336531:i=>{t.Cd("Ceil",i,void 0)},1336583:i=>{t.Cd("Reciprocal",i,void 0)},1336641:i=>{t.Cd("Sqrt",i,void 0)},1336693:i=>{t.Cd("Exp",i,void 0)},1336744:i=>{t.Cd("Erf",i,void 0)},1336795:i=>{t.Cd("Sigmoid",i,void 0)},1336850:i=>{t.Cd("Log",i,void 0)},1336901:i=>{t.Cd("Sin",i,void 0)},1336952:i=>{t.Cd("Cos",i,void 0)},1337003:i=>{t.Cd("Tan",i,void 0)},1337054:i=>{t.Cd("Asin",i,void 0)},1337106:i=>{t.Cd("Acos",i,void 0)},1337158:i=>{t.Cd("Atan",i,void 0)},1337210:i=>{t.Cd("Sinh",i,void 0)},1337262:i=>{t.Cd("Cosh",i,void 0)},1337314:i=>{t.Cd("Asinh",i,void 0)},1337367:i=>{t.Cd("Acosh",i,void 0)},1337420:i=>{t.Cd("Atanh",i,void 0)},1337473:i=>{t.Cd("Tanh",i,void 0)},1337525:i=>{t.Cd("Not",i,void 0)},1337576:(i,n,o)=>{t.Cd("Clip",i,{min:n,max:o})},1337645:i=>{t.Cd("Clip",i,void 0)},1337697:(i,n)=>{t.Cd("Elu",i,{alpha:n})},1337755:i=>{t.Cd("Relu",i,void 0)},1337807:(i,n)=>{t.Cd("LeakyRelu",i,{alpha:n})},1337871:(i,n)=>{t.Cd("ThresholdedRelu",i,{alpha:n})},1337941:(i,n)=>{t.Cd("Cast",i,{to:n})},1337999:i=>{t.Cd("Add",i,void 0)},1338050:i=>{t.Cd("Sub",i,void 0)},1338101:i=>{t.Cd("Mul",i,void 0)},1338152:i=>{t.Cd("Div",i,void 0)},1338203:i=>{t.Cd("Pow",i,void 0)},1338254:i=>{t.Cd("Equal",i,void 0)},1338307:i=>{t.Cd("Greater",i,void 0)},1338362:i=>{t.Cd("GreaterOrEqual",i,void 0)},1338424:i=>{t.Cd("Less",i,void 0)},1338476:i=>{t.Cd("LessOrEqual",i,void 0)},1338535:(i,n,o,l,d)=>{t.Cd("ReduceMean",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1338699:(i,n,o,l,d)=>{t.Cd("ReduceMax",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1338862:(i,n,o,l,d)=>{t.Cd("ReduceMin",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339025:(i,n,o,l,d)=>{t.Cd("ReduceProd",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339189:(i,n,o,l,d)=>{t.Cd("ReduceSum",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339352:(i,n,o,l,d)=>{t.Cd("ReduceL1",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339514:(i,n,o,l,d)=>{t.Cd("ReduceL2",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339676:(i,n,o,l,d)=>{t.Cd("ReduceLogSum",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1339842:(i,n,o,l,d)=>{t.Cd("ReduceSumSquare",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1340011:(i,n,o,l,d)=>{t.Cd("ReduceLogSumExp",i,{keepDims:!!n,noopWithEmptyAxes:!!o,axes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1340180:i=>{t.Cd("Where",i,void 0)},1340233:(i,n,o)=>{t.Cd("Transpose",i,{perm:n?Array.from(F.subarray(o>>>0,o+n>>>0)):[]})},1340346:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>{t.Cd("ConvTranspose",i,{format:b?"NHWC":"NCHW",autoPad:n,dilations:[o],group:l,kernel_shape:[d],pads:[h,m],strides:[y],wIsConst:()=>!!re[$>>>0],outputPadding:_?Array.from(F.subarray(E>>>0,E+_>>>0)):[],outputShape:R?Array.from(F.subarray(S>>>0,S+R>>>0)):[],activation:at(j)})},1340760:(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>{t.Cd("ConvTranspose",i,{format:y?"NHWC":"NCHW",autoPad:n,dilations:Array.from(F.subarray(o>>>0,o+2>>>0)),group:l,kernelShape:Array.from(F.subarray(d>>>0,d+2>>>0)),pads:Array.from(F.subarray(h>>>0,h+4>>>0)),strides:Array.from(F.subarray(m>>>0,m+2>>>0)),wIsConst:()=>!!re[b>>>0],outputPadding:0<$?Array.from(F.subarray(_>>>0,_+$>>>0)):[],outputShape:0<E?Array.from(F.subarray(R>>>0,R+E>>>0)):[],activation:at(S)})},1341317:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>{t.Cd("ConvTranspose",i,{format:b?"NHWC":"NCHW",autoPad:n,dilations:[o],group:l,kernel_shape:[d],pads:[h,m],strides:[y],wIsConst:()=>!!re[$>>>0],outputPadding:_?Array.from(F.subarray(E>>>0,E+_>>>0)):[],outputShape:R?Array.from(F.subarray(S>>>0,S+R>>>0)):[],activation:at(j)})},1341731:(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>{t.Cd("ConvTranspose",i,{format:y?"NHWC":"NCHW",autoPad:n,dilations:Array.from(F.subarray(o>>>0,o+2>>>0)),group:l,kernelShape:Array.from(F.subarray(d>>>0,d+2>>>0)),pads:Array.from(F.subarray(h>>>0,h+4>>>0)),strides:Array.from(F.subarray(m>>>0,m+2>>>0)),wIsConst:()=>!!re[b>>>0],outputPadding:0<$?Array.from(F.subarray(_>>>0,_+$>>>0)):[],outputShape:0<E?Array.from(F.subarray(R>>>0,R+E>>>0)):[],activation:at(S)})},1342288:(i,n)=>{t.Cd("GlobalAveragePool",i,{format:n?"NHWC":"NCHW"})},1342379:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>{t.Cd("AveragePool",i,{format:W?"NHWC":"NCHW",auto_pad:n,ceil_mode:o,count_include_pad:l,storage_order:d,dilations:[h,m],kernel_shape:[y,b],pads:[$,_,E,R],strides:[S,j]})},1342663:(i,n)=>{t.Cd("GlobalAveragePool",i,{format:n?"NHWC":"NCHW"})},1342754:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>{t.Cd("AveragePool",i,{format:W?"NHWC":"NCHW",auto_pad:n,ceil_mode:o,count_include_pad:l,storage_order:d,dilations:[h,m],kernel_shape:[y,b],pads:[$,_,E,R],strides:[S,j]})},1343038:(i,n)=>{t.Cd("GlobalMaxPool",i,{format:n?"NHWC":"NCHW"})},1343125:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>{t.Cd("MaxPool",i,{format:W?"NHWC":"NCHW",auto_pad:n,ceil_mode:o,count_include_pad:l,storage_order:d,dilations:[h,m],kernel_shape:[y,b],pads:[$,_,E,R],strides:[S,j]})},1343405:(i,n)=>{t.Cd("GlobalMaxPool",i,{format:n?"NHWC":"NCHW"})},1343492:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>{t.Cd("MaxPool",i,{format:W?"NHWC":"NCHW",auto_pad:n,ceil_mode:o,count_include_pad:l,storage_order:d,dilations:[h,m],kernel_shape:[y,b],pads:[$,_,E,R],strides:[S,j]})},1343772:(i,n,o,l,d)=>{t.Cd("Gemm",i,{alpha:n,beta:o,transA:l,transB:d})},1343876:i=>{t.Cd("MatMul",i,void 0)},1343930:(i,n,o,l)=>{t.Cd("ArgMax",i,{keepDims:!!n,selectLastIndex:!!o,axis:l})},1344038:(i,n,o,l)=>{t.Cd("ArgMin",i,{keepDims:!!n,selectLastIndex:!!o,axis:l})},1344146:(i,n)=>{t.Cd("Softmax",i,{axis:n})},1344209:(i,n)=>{t.Cd("Concat",i,{axis:n})},1344269:(i,n,o,l,d)=>{t.Cd("Split",i,{axis:n,numOutputs:o,splitSizes:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1344414:i=>{t.Cd("Expand",i,void 0)},1344468:(i,n)=>{t.Cd("Gather",i,{axis:Number(n)})},1344539:(i,n)=>{t.Cd("GatherElements",i,{axis:Number(n)})},1344618:(i,n,o,l,d,h,m,y,b,$,_)=>{t.Cd("Resize",i,{antialias:n,axes:o?Array.from(F.subarray(l>>>0,l+o>>>0)):[],coordinateTransformMode:at(d),cubicCoeffA:h,excludeOutside:m,extrapolationValue:y,keepAspectRatioPolicy:at(b),mode:at($),nearestMode:at(_)})},1344969:(i,n,o,l,d,h,m)=>{t.Cd("Slice",i,{starts:n?Array.from(F.subarray(o>>>0,o+n>>>0)):[],ends:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[],axes:h?Array.from(F.subarray(m>>>0,m+h>>>0)):[]})},1345200:i=>{t.Cd("Tile",i,void 0)},1345252:(i,n,o)=>{t.Cd("LayerNormalization",i,{axis:Number(n),epsilon:Number(o)})},1345359:(i,n,o)=>{t.Cd("InstanceNormalization",i,{epsilon:n,format:o?"NHWC":"NCHW"})},1345473:(i,n,o)=>{t.Cd("InstanceNormalization",i,{epsilon:n,format:o?"NHWC":"NCHW"})},1345587:i=>{t.Cd("Range",i,void 0)},1345640:(i,n)=>{t.Cd("Einsum",i,{equation:at(n)})},1345721:(i,n,o,l,d)=>{t.Cd("Pad",i,{mode:n,value:o,pads:l?Array.from(F.subarray(d>>>0,d+l>>>0)):[]})},1345853:(i,n,o,l,d,h)=>{t.Cd("BatchNormalization",i,{epsilon:n,momentum:o,spatial:!!d,trainingMode:!!l,format:h?"NHWC":"NCHW"})},1346022:(i,n,o,l,d,h)=>{t.Cd("BatchNormalization",i,{epsilon:n,momentum:o,spatial:!!d,trainingMode:!!l,format:h?"NHWC":"NCHW"})},1346191:(i,n,o,l,d,h,m,y,b)=>{t.Cd("Attention",i,{numHeads:n,isUnidirectional:o,maskFilterValue:l,scale:d,doRotary:h,qkvHiddenSizes:m?Array.from(F.subarray(Number(y)>>>0,Number(y)+m>>>0)):[],pastPresentShareBuffer:!!b})},1346463:i=>{t.Cd("Gelu",i,void 0)},1346515:(i,n,o,l,d,h)=>{t.Cd("MultiHeadAttention",i,{numHeads:n,isUnidirectional:o,maskFilterValue:l,scale:d,doRotary:h})},1346674:i=>{t.Cd("BiasAdd",i,void 0)},1346729:i=>{t.Cd("BiasSplitGelu",i,void 0)},1346790:(i,n)=>{t.Cd("SkipLayerNormalization",i,{epsilon:n})},1346871:(i,n,o,l,d,h,m,y,b,$,_,E,R)=>{t.Cd("Conv",i,{format:b?"NHWC":"NCHW",auto_pad:n,dilations:[o],group:l,kernel_shape:[d],pads:h?Array.from(F.subarray(m>>>0,m+h>>>0)):[],strides:[y],w_is_const:()=>!!re[$>>>0],activation:at(_),activation_params:E?Array.from(_e.subarray(R>>>0,R+E>>>0)):[]})},1347252:(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>{t.Cd("Conv",i,{format:E?"NHWC":"NCHW",auto_pad:n,dilations:[o,l],group:d,kernel_shape:[h,m],pads:y?Array.from(F.subarray(b>>>0,b+y>>>0)):[],strides:[$,_],w_is_const:()=>!!re[R>>>0],activation:at(S),activation_params:j?Array.from(_e.subarray(W>>>0,W+j>>>0)):[]})},1347654:i=>{t.sh(i)},1347688:(i,n)=>t.th(i,n,t.Xg.uh,t.Xg.errors),1347800:i=>t.ph(i),1347833:i=>t.rh(i),1347865:(i,n,o)=>{t.eh(i,n,o,!0)},1347904:(i,n,o)=>{t.eh(i,n,o)}};function ht(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}var Kt=i=>{for(;0<i.length;)i.shift()(t)},Tt=[],Yt=0,wt=0;function $t(i){this.Wg=i,this.Sg=i-24,this.mh=function(n){ae[this.Sg+4>>2>>>0]=n},this.bh=function(){return ae[this.Sg+4>>2>>>0]},this.lh=function(n){ae[this.Sg+8>>2>>>0]=n},this.fh=function(n){re[this.Sg+12>>0>>>0]=n?1:0},this.ih=function(){return re[this.Sg+12>>0>>>0]!=0},this.gh=function(n){re[this.Sg+13>>0>>>0]=n?1:0},this.oh=function(){return re[this.Sg+13>>0>>>0]!=0},this.kh=function(n,o){this.dh(0),this.mh(n),this.lh(o)},this.dh=function(n){ae[this.Sg+16>>2>>>0]=n},this.hh=function(){return ae[this.Sg+16>>2>>>0]},this.jh=function(){if(Fr(this.bh()))return ae[this.Wg>>2>>>0];var n=this.hh();return n!==0?n:this.Wg}}var Xt=i=>{var n=wt;if(!n)return Vt(0),0;var o=new $t(n);o.dh(n);var l=o.bh();if(!l)return Vt(0),n;for(var d in i){var h=i[d];if(h===0||h===l)break;if(Gr(h,l,o.Sg+16))return Vt(h),n}return Vt(l),n},Wt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Dr=(i,n,o)=>{n>>>=0;var l=n+o;for(o=n;i[o]&&!(o>=l);)++o;if(16<o-n&&i.buffer&&Wt)return Wt.decode(i.subarray(n,o));for(l="";n<o;){var d=i[n++];if(d&128){var h=i[n++]&63;if((d&224)==192)l+=String.fromCharCode((d&31)<<6|h);else{var m=i[n++]&63;d=(d&240)==224?(d&15)<<12|h<<6|m:(d&7)<<18|h<<12|m<<6|i[n++]&63,65536>d?l+=String.fromCharCode(d):(d-=65536,l+=String.fromCharCode(55296|d>>10,56320|d&1023))}}else l+=String.fromCharCode(d)}return l},at=(i,n)=>(i>>>=0)?Dr(fe,i,n):"",cr=i=>{for(var n=0,o=0;o<i.length;++o){var l=i.charCodeAt(o);127>=l?n++:2047>=l?n+=2:55296<=l&&57343>=l?(n+=4,++o):n+=3}return n},zr=(i,n,o,l)=>{if(o>>>=0,!(0<l))return 0;var d=o;l=o+l-1;for(var h=0;h<i.length;++h){var m=i.charCodeAt(h);if(55296<=m&&57343>=m){var y=i.charCodeAt(++h);m=65536+((m&1023)<<10)|y&1023}if(127>=m){if(o>=l)break;n[o++>>>0]=m}else{if(2047>=m){if(o+1>=l)break;n[o++>>>0]=192|m>>6}else{if(65535>=m){if(o+2>=l)break;n[o++>>>0]=224|m>>12}else{if(o+3>=l)break;n[o++>>>0]=240|m>>18,n[o++>>>0]=128|m>>12&63}n[o++>>>0]=128|m>>6&63}n[o++>>>0]=128|m&63}}return n[o>>>0]=0,o-d},mt=i=>i%4===0&&(i%100!==0||i%400===0),fr=[0,31,60,91,121,152,182,213,244,274,305,335],Zt=[0,31,59,90,120,151,181,212,243,273,304,334],pr=i=>{var n=cr(i)+1,o=$r(n);return o&&zr(i,fe,o,n),o},hr=[],Wr=(i,n)=>{hr.length=0;var o;for(n>>=2;o=fe[i++>>>0];)n+=o!=105&n,hr.push(o==105?F[n>>>0]:he[n++>>>1]),++n;return hr},mr={},Vr=()=>{if(!et){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},n;for(n in mr)mr[n]===void 0?delete i[n]:i[n]=mr[n];var o=[];for(n in i)o.push(`${n}=${i[n]}`);et=o}return et},et,Pi=[null,[],[]],gr=[31,29,31,30,31,30,31,31,30,31,30,31],be=[31,28,31,30,31,30,31,31,30,31,30,31];function yr(i){var n=Array(cr(i)+1);return zr(i,n,0,n.length),n}function Nr(i,n,o,l){function d(S,j,W){for(S=typeof S=="number"?S.toString():S||"";S.length<j;)S=W[0]+S;return S}function h(S,j){return d(S,j,"0")}function m(S,j){function W(ne){return 0>ne?-1:0<ne?1:0}var Q;return(Q=W(S.getFullYear()-j.getFullYear()))===0&&(Q=W(S.getMonth()-j.getMonth()))===0&&(Q=W(S.getDate()-j.getDate())),Q}function y(S){switch(S.getDay()){case 0:return new Date(S.getFullYear()-1,11,29);case 1:return S;case 2:return new Date(S.getFullYear(),0,3);case 3:return new Date(S.getFullYear(),0,2);case 4:return new Date(S.getFullYear(),0,1);case 5:return new Date(S.getFullYear()-1,11,31);case 6:return new Date(S.getFullYear()-1,11,30)}}function b(S){var j=S.Ug;for(S=new Date(new Date(S.Vg+1900,0,1).getTime());0<j;){var W=S.getMonth(),Q=(mt(S.getFullYear())?gr:be)[W];if(j>Q-S.getDate())j-=Q-S.getDate()+1,S.setDate(1),11>W?S.setMonth(W+1):(S.setMonth(0),S.setFullYear(S.getFullYear()+1));else{S.setDate(S.getDate()+j);break}}return W=new Date(S.getFullYear()+1,0,4),j=y(new Date(S.getFullYear(),0,4)),W=y(W),0>=m(j,S)?0>=m(W,S)?S.getFullYear()+1:S.getFullYear():S.getFullYear()-1}i>>>=0,n>>>=0,o>>>=0,l>>>=0;var $=F[l+40>>2>>>0];l={xh:F[l>>2>>>0],wh:F[l+4>>2>>>0],Yg:F[l+8>>2>>>0],ah:F[l+12>>2>>>0],Zg:F[l+16>>2>>>0],Vg:F[l+20>>2>>>0],Tg:F[l+24>>2>>>0],Ug:F[l+28>>2>>>0],Ah:F[l+32>>2>>>0],vh:F[l+36>>2>>>0],yh:$?at($):""},o=at(o),$={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var _ in $)o=o.replace(new RegExp(_,"g"),$[_]);var E="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),R="January February March April May June July August September October November December".split(" ");$={"%a":S=>E[S.Tg].substring(0,3),"%A":S=>E[S.Tg],"%b":S=>R[S.Zg].substring(0,3),"%B":S=>R[S.Zg],"%C":S=>h((S.Vg+1900)/100|0,2),"%d":S=>h(S.ah,2),"%e":S=>d(S.ah,2," "),"%g":S=>b(S).toString().substring(2),"%G":S=>b(S),"%H":S=>h(S.Yg,2),"%I":S=>(S=S.Yg,S==0?S=12:12<S&&(S-=12),h(S,2)),"%j":S=>{for(var j=0,W=0;W<=S.Zg-1;j+=(mt(S.Vg+1900)?gr:be)[W++]);return h(S.ah+j,3)},"%m":S=>h(S.Zg+1,2),"%M":S=>h(S.wh,2),"%n":()=>`
`,"%p":S=>0<=S.Yg&&12>S.Yg?"AM":"PM","%S":S=>h(S.xh,2),"%t":()=>"	","%u":S=>S.Tg||7,"%U":S=>h(Math.floor((S.Ug+7-S.Tg)/7),2),"%V":S=>{var j=Math.floor((S.Ug+7-(S.Tg+6)%7)/7);if(2>=(S.Tg+371-S.Ug-2)%7&&j++,j)j==53&&(W=(S.Tg+371-S.Ug)%7,W==4||W==3&&mt(S.Vg)||(j=1));else{j=52;var W=(S.Tg+7-S.Ug-1)%7;(W==4||W==5&&mt(S.Vg%400-1))&&j++}return h(j,2)},"%w":S=>S.Tg,"%W":S=>h(Math.floor((S.Ug+7-(S.Tg+6)%7)/7),2),"%y":S=>(S.Vg+1900).toString().substring(2),"%Y":S=>S.Vg+1900,"%z":S=>{S=S.vh;var j=0<=S;return S=Math.abs(S)/60,(j?"+":"-")+("0000"+(S/60*100+S%60)).slice(-4)},"%Z":S=>S.yh,"%%":()=>"%"},o=o.replace(/%%/g,"\0\0");for(_ in $)o.includes(_)&&(o=o.replace(new RegExp(_,"g"),$[_](l)));return o=o.replace(/\0\0/g,"%"),_=yr(o),_.length>n?0:(re.set(_,i>>>0),_.length-1)}function br(i){try{i()}catch(n){nt(n)}}function Bi(i){var n={},o;for(o in i)(function(l){var d=i[l];n[l]=typeof d=="function"?function(){Qt.push(l);try{return d.apply(null,arguments)}finally{Z||(Qt.pop()===l||nt(),gt&&Ot===1&&Qt.length===0&&(Ot=0,br(ys),typeof Fibers<"u"&&Fibers.Bh()))}}:d})(o);return n}var Ot=0,gt=null,Ur=0,Qt=[],Hr={},vr={},Mi=0,wr=null,ji=[];function Di(){return new Promise((i,n)=>{wr={resolve:i,reject:n}})}function zi(){var i=$r(65548),n=i+12;ae[i>>2>>>0]=n,ae[i+4>>2>>>0]=n+65536,n=Qt[0];var o=Hr[n];return o===void 0&&(o=Mi++,Hr[n]=o,vr[o]=n),F[i+8>>2>>>0]=o,i}function Wi(i){if(!Z){if(Ot===0){var n=!1,o=!1;i((l=0)=>{if(!Z&&(Ur=l,n=!0,o)){Ot=2,br(()=>bs(gt)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),l=!1;try{var d=(0,A[vr[F[gt+8>>2>>>0]]])()}catch(y){d=y,l=!0}var h=!1;if(!gt){var m=wr;m&&(wr=null,(l?m.reject:m.resolve)(d),h=!0)}if(l&&!h)throw d}}),o=!0,n||(Ot=1,gt=zi(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),br(()=>gs(gt)))}else Ot===2?(Ot=0,br(vs),Lr(gt),gt=null,ji.forEach(l=>{if(!Z)try{if(l(),!L)try{J=J=l=J,L||(t.onExit&&t.onExit(l),Z=!0),g(l,new ht(l))}catch(d){d instanceof ht||d=="unwind"||g(1,d)}}catch(d){d instanceof ht||d=="unwind"||g(1,d)}})):nt(`invalid state: ${Ot}`);return Ur}}function Vi(i){return Wi(n=>{i().then(n)})}var Ni={Ha:function(i,n,o){return Vi(async()=>{await t.qh(i,n,o)})},u:function(i){return i=new $t(i>>>0),i.ih()||(i.fh(!0),Yt--),i.gh(!1),Tt.push(i),Nt(i.Wg),i.jh()},C:function(){V(0,0);var i=Tt.pop();Jt(i.Wg),wt=0},a:function(){return Xt([])},k:function(i){return Xt([i>>>0])},w:function(i,n){return Xt([i>>>0,n>>>0])},q:function(i,n,o){return Xt([i>>>0,n>>>0,o>>>0])},pa:function(){var i=Tt.pop();i||nt("no exception to throw");var n=i.Wg;throw i.oh()||(Tt.push(i),i.gh(!0),i.fh(!1),Yt++),wt=n,wt},s:function(i,n,o){throw i>>>=0,new $t(i).kh(n>>>0,o>>>0),wt=i,Yt++,wt},$:function(){return Yt},g:function(i){throw wt||(wt=i>>>0),wt},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(i,n,o){i=n+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*n:NaN,o>>>=0,i=new Date(1e3*i),F[o>>2>>>0]=i.getUTCSeconds(),F[o+4>>2>>>0]=i.getUTCMinutes(),F[o+8>>2>>>0]=i.getUTCHours(),F[o+12>>2>>>0]=i.getUTCDate(),F[o+16>>2>>>0]=i.getUTCMonth(),F[o+20>>2>>>0]=i.getUTCFullYear()-1900,F[o+24>>2>>>0]=i.getUTCDay(),F[o+28>>2>>>0]=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(i,n,o){i=n+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*n:NaN,o>>>=0,i=new Date(1e3*i),F[o>>2>>>0]=i.getSeconds(),F[o+4>>2>>>0]=i.getMinutes(),F[o+8>>2>>>0]=i.getHours(),F[o+12>>2>>>0]=i.getDate(),F[o+16>>2>>>0]=i.getMonth(),F[o+20>>2>>>0]=i.getFullYear()-1900,F[o+24>>2>>>0]=i.getDay(),F[o+28>>2>>>0]=(mt(i.getFullYear())?fr:Zt)[i.getMonth()]+i.getDate()-1|0,F[o+36>>2>>>0]=-(60*i.getTimezoneOffset()),n=new Date(i.getFullYear(),6,1).getTimezoneOffset();var l=new Date(i.getFullYear(),0,1).getTimezoneOffset();F[o+32>>2>>>0]=(n!=l&&i.getTimezoneOffset()==Math.min(l,n))|0},Qc:function(i){i>>>=0;var n=new Date(F[i+20>>2>>>0]+1900,F[i+16>>2>>>0],F[i+12>>2>>>0],F[i+8>>2>>>0],F[i+4>>2>>>0],F[i>>2>>>0],0),o=F[i+32>>2>>>0],l=n.getTimezoneOffset(),d=new Date(n.getFullYear(),6,1).getTimezoneOffset(),h=new Date(n.getFullYear(),0,1).getTimezoneOffset(),m=Math.min(h,d);return 0>o?F[i+32>>2>>>0]=+(d!=h&&m==l):0<o!=(m==l)&&(d=Math.max(h,d),n.setTime(n.getTime()+6e4*((0<o?m:d)-l))),F[i+24>>2>>>0]=n.getDay(),F[i+28>>2>>>0]=(mt(n.getFullYear())?fr:Zt)[n.getMonth()]+n.getDate()-1|0,F[i>>2>>>0]=n.getSeconds(),F[i+4>>2>>>0]=n.getMinutes(),F[i+8>>2>>>0]=n.getHours(),F[i+12>>2>>>0]=n.getDate(),F[i+16>>2>>>0]=n.getMonth(),F[i+20>>2>>>0]=n.getYear(),i=n.getTime()/1e3,Vt((ut=i,1<=+Math.abs(ut)?0<ut?+Math.floor(ut/4294967296)>>>0:~~+Math.ceil((ut-+(~~ut>>>0))/4294967296)>>>0:0)),i>>>0},Mc:function(){return-52},Nc:function(){},La:function(i,n,o){function l(b){return(b=b.toTimeString().match(/\(([A-Za-z ]+)\)$/))?b[1]:"GMT"}o>>>=0;var d=new Date().getFullYear(),h=new Date(d,0,1),m=new Date(d,6,1);d=h.getTimezoneOffset();var y=m.getTimezoneOffset();ae[i>>>0>>2>>>0]=60*Math.max(d,y),F[n>>>0>>2>>>0]=+(d!=y),i=l(h),n=l(m),i=pr(i),n=pr(n),y<d?(ae[o>>2>>>0]=i,ae[o+4>>2>>>0]=n):(ae[o>>2>>>0]=n,ae[o+4>>2>>>0]=i)},ja:()=>{nt("")},x:function(i,n,o){return i>>>=0,n=Wr(n>>>0,o>>>0),Et[i].apply(null,n)},wa:function(i,n,o){return i>>>=0,n=Wr(n>>>0,o>>>0),Et[i].apply(null,n)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(i,n,o){return n>>>=0,fe.copyWithin(i>>>0>>>0,n>>>0,n+(o>>>0)>>>0)},Ka:function(i){i>>>=0;var n=fe.length;if(4294901760<i)return!1;for(var o=1;4>=o;o*=2){var l=n*(1+.2/o);l=Math.min(l,i+100663296);var d=Math;l=Math.max(i,l);e:{d=d.min.call(d,4294901760,l+(65536-l%65536)%65536)-Y.buffer.byteLength+65535>>>16;try{Y.grow(d),Pe();var h=1;break e}catch{}h=void 0}if(h)return!0}return!1},cb:function(i,n){i>>>=0,n>>>=0;var o=0;return Vr().forEach(function(l,d){var h=n+o;for(d=ae[i+4*d>>2>>>0]=h,h=0;h<l.length;++h)re[d++>>0>>>0]=l.charCodeAt(h);re[d>>0>>>0]=0,o+=l.length+1}),0},nb:function(i,n){i>>>=0,n>>>=0;var o=Vr();ae[i>>2>>>0]=o.length;var l=0;return o.forEach(function(d){l+=d.length+1}),ae[n>>2>>>0]=l,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(i,n,o,l){n>>>=0,o>>>=0,l>>>=0;for(var d=0,h=0;h<o;h++){var m=ae[n>>2>>>0],y=ae[n+4>>2>>>0];n+=8;for(var b=0;b<y;b++){var $=fe[m+b>>>0],_=Pi[i];$===0||$===10?((i===1?M:z)(Dr(_,0)),_.length=0):_.push($)}d+=y}return ae[l>>2>>>0]=d,0},ia:yf,Sc:gp,M:Lf,K:gf,Uc:mp,Wc:fp,B:kf,z:pf,b:af,Da:lp,aa:Qf,f:rf,ra:dp,h:tf,F:up,i:df,Vc:pp,j:lf,t:uf,r:mf,n:bf,W:$f,Y:ip,J:xf,oa:Df,ba:Wf,la:np,vb:Eh,fb:Hh,yc:Op,ab:qh,db:Gh,Sa:rm,Rb:uh,Dc:xp,ib:Vh,Va:em,Nb:fh,eb:Lh,fc:Kp,Lc:yp,nc:Vp,gb:Uh,bb:Fh,Bb:_h,jc:Lp,mc:Np,ec:Yp,Kc:bp,Za:Xh,$a:Kh,qb:Ph,mb:jh,_a:Yh,hc:Fp,Ib:gh,lb:Dh,Ua:tm,Sb:sh,Ic:wp,zc:Tp,sc:jp,pb:Bh,kc:Hp,Hb:yh,Gb:bh,c:sf,_:Pf,p:of,P:cp,Z:Kf,ha:Af,e:nf,za:Sf,G:sp,da:Mf,O:Gf,ub:Th,fa:Ef,d:cf,xa:Of,Fa:ap,l:ff,va:Bf,m:hf,ya:Tf,ua:jf,Ga:Jf,o:vf,V:Uf,ga:Nf,U:Hf,na:Yf,y:wf,A:Cf,E:_f,X:op,ta:Ff,ea:Rf,N:Vf,L:Xf,D:zf,ca:If,T:qf,ka:hp,R:ep,sa:rp,Q:tp,S:Zf,ic:Gp,zb:xh,rb:Rh,Db:$h,Ab:Sh,Ac:Ep,Mb:ph,xb:Ih,Eb:wh,Ob:ch,cc:Xp,ob:Mh,Lb:hh,sb:kh,kb:zh,qc:zp,Fc:_p,Ya:Zh,Pb:dh,wc:Rp,jb:Wh,uc:Bp,Hc:$p,vc:Pp,Bc:Ap,Xa:Qh,Ec:Sp,wb:Ah,Kb:mh,xc:kp,Jc:vp,hb:Nh,Cb:Ch,Xb:ih,tb:Oh,Gc:Cp,Yb:rh,Qb:lh,gc:qp,Cc:Ip,pc:Wp,Fb:vh,Wb:nh,rc:Dp,lc:Up,Wa:Jh,tc:Mp,Tb:oh,Vb:ah,_b:eh,$b:Jp,bc:Zp,Zb:th,ac:Qp,v:function(i){return i>>>0},Ia:Nr,H:function(i,n,o,l){return Nr(i>>>0,n>>>0,o>>>0,l>>>0)}};(function(){function i(o){if(o=o.exports,o=Bi(o),A=o=im(o),Y=A.Xc,Pe(),Be.unshift(A.Yc),Ae--,t.monitorRunDependencies&&t.monitorRunDependencies(Ae),Ae==0&&(At!==null&&(clearInterval(At),At=null),it)){var l=it;it=null,l()}return o}var n={a:Ni};if(Ae++,t.monitorRunDependencies&&t.monitorRunDependencies(Ae),t.instantiateWasm)try{return t.instantiateWasm(n,i)}catch(o){z("Module.instantiateWasm callback failed with error: "+o),a(o)}return Je(n,function(o){i(o.instance)}).catch(a),{}})(),t._OrtInit=(i,n)=>(t._OrtInit=A.Zc)(i,n),t._OrtGetLastError=(i,n)=>(t._OrtGetLastError=A._c)(i,n),t._OrtCreateSessionOptions=(i,n,o,l,d,h,m,y,b,$)=>(t._OrtCreateSessionOptions=A.$c)(i,n,o,l,d,h,m,y,b,$),t._OrtAppendExecutionProvider=(i,n)=>(t._OrtAppendExecutionProvider=A.ad)(i,n),t._OrtAddFreeDimensionOverride=(i,n,o)=>(t._OrtAddFreeDimensionOverride=A.bd)(i,n,o),t._OrtAddSessionConfigEntry=(i,n,o)=>(t._OrtAddSessionConfigEntry=A.cd)(i,n,o),t._OrtReleaseSessionOptions=i=>(t._OrtReleaseSessionOptions=A.dd)(i),t._OrtCreateSession=(i,n,o)=>(t._OrtCreateSession=A.ed)(i,n,o),t._OrtReleaseSession=i=>(t._OrtReleaseSession=A.fd)(i),t._OrtGetInputOutputCount=(i,n,o)=>(t._OrtGetInputOutputCount=A.gd)(i,n,o),t._OrtGetInputName=(i,n)=>(t._OrtGetInputName=A.hd)(i,n),t._OrtGetOutputName=(i,n)=>(t._OrtGetOutputName=A.id)(i,n),t._OrtFree=i=>(t._OrtFree=A.jd)(i),t._OrtCreateTensor=(i,n,o,l,d,h)=>(t._OrtCreateTensor=A.kd)(i,n,o,l,d,h),t._OrtGetTensorData=(i,n,o,l,d)=>(t._OrtGetTensorData=A.ld)(i,n,o,l,d),t._OrtReleaseTensor=i=>(t._OrtReleaseTensor=A.md)(i),t._OrtCreateRunOptions=(i,n,o,l)=>(t._OrtCreateRunOptions=A.nd)(i,n,o,l),t._OrtAddRunConfigEntry=(i,n,o)=>(t._OrtAddRunConfigEntry=A.od)(i,n,o),t._OrtReleaseRunOptions=i=>(t._OrtReleaseRunOptions=A.pd)(i),t._OrtCreateBinding=i=>(t._OrtCreateBinding=A.qd)(i),t._OrtBindInput=(i,n,o)=>(t._OrtBindInput=A.rd)(i,n,o),t._OrtBindOutput=(i,n,o,l)=>(t._OrtBindOutput=A.sd)(i,n,o,l),t._OrtClearBoundOutputs=i=>(t._OrtClearBoundOutputs=A.td)(i),t._OrtReleaseBinding=i=>(t._OrtReleaseBinding=A.ud)(i),t._OrtRunWithBinding=(i,n,o,l,d)=>(t._OrtRunWithBinding=A.vd)(i,n,o,l,d),t._OrtRun=(i,n,o,l,d,h,m,y)=>(t._OrtRun=A.wd)(i,n,o,l,d,h,m,y),t._OrtEndProfiling=i=>(t._OrtEndProfiling=A.xd)(i),t._JsepOutput=(i,n,o)=>(t._JsepOutput=A.yd)(i,n,o),t._JsepGetNodeName=i=>(t._JsepGetNodeName=A.zd)(i);var $r=t._malloc=i=>($r=t._malloc=A.Ad)(i),Lr=t._free=i=>(Lr=t._free=A.Bd)(i),V=(i,n)=>(V=A.Dd)(i,n),Vt=i=>(Vt=A.Ed)(i),N=()=>(N=A.Fd)(),U=i=>(U=A.Gd)(i),Cr=i=>(Cr=A.Hd)(i),Jt=i=>(Jt=A.Id)(i),Nt=i=>(Nt=A.Jd)(i),Gr=(i,n,o)=>(Gr=A.Kd)(i,n,o),Fr=i=>(Fr=A.Ld)(i),qr=t.dynCall_vi=(i,n)=>(qr=t.dynCall_vi=A.Md)(i,n),Kr=t.dynCall_vii=(i,n,o)=>(Kr=t.dynCall_vii=A.Nd)(i,n,o),Yr=t.dynCall_iiii=(i,n,o,l)=>(Yr=t.dynCall_iiii=A.Od)(i,n,o,l),_r=t.dynCall_iii=(i,n,o)=>(_r=t.dynCall_iii=A.Pd)(i,n,o),Xr=t.dynCall_ii=(i,n)=>(Xr=t.dynCall_ii=A.Qd)(i,n),Ui=t.dynCall_iiiiiii=(i,n,o,l,d,h,m)=>(Ui=t.dynCall_iiiiiii=A.Rd)(i,n,o,l,d,h,m),We=t.dynCall_v=i=>(We=t.dynCall_v=A.Sd)(i),Sr=t.dynCall_iiiiii=(i,n,o,l,d,h)=>(Sr=t.dynCall_iiiiii=A.Td)(i,n,o,l,d,h),xr=t.dynCall_iiij=(i,n,o,l,d)=>(xr=t.dynCall_iiij=A.Ud)(i,n,o,l,d),Zr=t.dynCall_iiiii=(i,n,o,l,d)=>(Zr=t.dynCall_iiiii=A.Vd)(i,n,o,l,d),Ir=t.dynCall_viii=(i,n,o,l)=>(Ir=t.dynCall_viii=A.Wd)(i,n,o,l),Qr=t.dynCall_j=i=>(Qr=t.dynCall_j=A.Xd)(i),Jr=t.dynCall_i=i=>(Jr=t.dynCall_i=A.Yd)(i),ei=t.dynCall_iij=(i,n,o,l)=>(ei=t.dynCall_iij=A.Zd)(i,n,o,l),ti=t.dynCall_iiiiij=(i,n,o,l,d,h,m)=>(ti=t.dynCall_iiiiij=A._d)(i,n,o,l,d,h,m),ri=t.dynCall_vij=(i,n,o,l)=>(ri=t.dynCall_vij=A.$d)(i,n,o,l),Hi=t.dynCall_viiiii=(i,n,o,l,d,h)=>(Hi=t.dynCall_viiiii=A.ae)(i,n,o,l,d,h),ii=t.dynCall_viiii=(i,n,o,l,d)=>(ii=t.dynCall_viiii=A.be)(i,n,o,l,d),ni=t.dynCall_iiiiiiii=(i,n,o,l,d,h,m,y)=>(ni=t.dynCall_iiiiiiii=A.ce)(i,n,o,l,d,h,m,y),ai=t.dynCall_fi=(i,n)=>(ai=t.dynCall_fi=A.de)(i,n),Li=t.dynCall_fii=(i,n,o)=>(Li=t.dynCall_fii=A.ee)(i,n,o),Gi=t.dynCall_ji=(i,n)=>(Gi=t.dynCall_ji=A.fe)(i,n),oi=t.dynCall_di=(i,n)=>(oi=t.dynCall_di=A.ge)(i,n),er=t.dynCall_jii=(i,n,o)=>(er=t.dynCall_jii=A.he)(i,n,o),Fi=t.dynCall_dii=(i,n,o)=>(Fi=t.dynCall_dii=A.ie)(i,n,o),Ct=t.dynCall_iiiiiiiii=(i,n,o,l,d,h,m,y,b)=>(Ct=t.dynCall_iiiiiiiii=A.je)(i,n,o,l,d,h,m,y,b),yt=t.dynCall_viij=(i,n,o,l,d)=>(yt=t.dynCall_viij=A.ke)(i,n,o,l,d),si=t.dynCall_viiiiii=(i,n,o,l,d,h,m)=>(si=t.dynCall_viiiiii=A.le)(i,n,o,l,d,h,m),tr=t.dynCall_vijj=(i,n,o,l,d,h)=>(tr=t.dynCall_vijj=A.me)(i,n,o,l,d,h),ui=t.dynCall_viiiiiii=(i,n,o,l,d,h,m,y)=>(ui=t.dynCall_viiiiiii=A.ne)(i,n,o,l,d,h,m,y),li=t.dynCall_iiiiiiiiii=(i,n,o,l,d,h,m,y,b,$)=>(li=t.dynCall_iiiiiiiiii=A.oe)(i,n,o,l,d,h,m,y,b,$),qi=t.dynCall_viiiiiiii=(i,n,o,l,d,h,m,y,b)=>(qi=t.dynCall_viiiiiiii=A.pe)(i,n,o,l,d,h,m,y,b),Ar=t.dynCall_iiiiijiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(Ar=t.dynCall_iiiiijiiiii=A.qe)(i,n,o,l,d,h,m,y,b,$,_,E),Ki=t.dynCall_vijjjiiij=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(Ki=t.dynCall_vijjjiiij=A.re)(i,n,o,l,d,h,m,y,b,$,_,E,R),Yi=t.dynCall_viiji=(i,n,o,l,d,h)=>(Yi=t.dynCall_viiji=A.se)(i,n,o,l,d,h),Xi=t.dynCall_viijiii=(i,n,o,l,d,h,m,y)=>(Xi=t.dynCall_viijiii=A.te)(i,n,o,l,d,h,m,y),Zi=t.dynCall_viiiiij=(i,n,o,l,d,h,m,y)=>(Zi=t.dynCall_viiiiij=A.ue)(i,n,o,l,d,h,m,y),Qi=t.dynCall_viiiiiiiii=(i,n,o,l,d,h,m,y,b,$)=>(Qi=t.dynCall_viiiiiiiii=A.ve)(i,n,o,l,d,h,m,y,b,$),Ji=t.dynCall_viid=(i,n,o,l)=>(Ji=t.dynCall_viid=A.we)(i,n,o,l),en=t.dynCall_iiiiiiiij=(i,n,o,l,d,h,m,y,b,$)=>(en=t.dynCall_iiiiiiiij=A.xe)(i,n,o,l,d,h,m,y,b,$),tn=t.dynCall_iiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(tn=t.dynCall_iiiiiiiiiiii=A.ye)(i,n,o,l,d,h,m,y,b,$,_,E),rr=t.dynCall_viiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(rr=t.dynCall_viiiiiiiiiiiii=A.ze)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),Er=t.dynCall_viijjjiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(Er=t.dynCall_viijjjiiiiii=A.Ae)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),di=t.dynCall_viiijiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(di=t.dynCall_viiijiiiiiii=A.Be)(i,n,o,l,d,h,m,y,b,$,_,E,R),ci=t.dynCall_viffiii=(i,n,o,l,d,h,m)=>(ci=t.dynCall_viffiii=A.Ce)(i,n,o,l,d,h,m),fi=t.dynCall_viiijjjii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(fi=t.dynCall_viiijjjii=A.De)(i,n,o,l,d,h,m,y,b,$,_,E),Tr=t.dynCall_viifiii=(i,n,o,l,d,h,m)=>(Tr=t.dynCall_viifiii=A.Ee)(i,n,o,l,d,h,m),Or=t.dynCall_viiiiidiidi=(i,n,o,l,d,h,m,y,b,$,_)=>(Or=t.dynCall_viiiiidiidi=A.Fe)(i,n,o,l,d,h,m,y,b,$,_),pi=t.dynCall_viiiiiiiiidi=(i,n,o,l,d,h,m,y,b,$,_,E)=>(pi=t.dynCall_viiiiiiiiidi=A.Ge)(i,n,o,l,d,h,m,y,b,$,_,E),hi=t.dynCall_vjiiiiii=(i,n,o,l,d,h,m,y,b)=>(hi=t.dynCall_vjiiiiii=A.He)(i,n,o,l,d,h,m,y,b),mi=t.dynCall_jiii=(i,n,o,l)=>(mi=t.dynCall_jiii=A.Ie)(i,n,o,l),kr=t.dynCall_viiid=(i,n,o,l,d)=>(kr=t.dynCall_viiid=A.Je)(i,n,o,l,d),ir=t.dynCall_viiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(ir=t.dynCall_viiiiiiiiiii=A.Ke)(i,n,o,l,d,h,m,y,b,$,_,E),Rr=t.dynCall_vijjjjjjjjjjjjji=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt)=>(Rr=t.dynCall_vijjjjjjjjjjjjji=A.Le)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt),gi=t.dynCall_viiiji=(i,n,o,l,d,h,m)=>(gi=t.dynCall_viiiji=A.Me)(i,n,o,l,d,h,m),yi=t.dynCall_vijjjiiji=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(yi=t.dynCall_vijjjiiji=A.Ne)(i,n,o,l,d,h,m,y,b,$,_,E,R),bi=t.dynCall_iiiji=(i,n,o,l,d,h)=>(bi=t.dynCall_iiiji=A.Oe)(i,n,o,l,d,h),vi=t.dynCall_iiijiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(vi=t.dynCall_iiijiiiiiiiiii=A.Pe)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),wi=t.dynCall_vj=(i,n,o)=>(wi=t.dynCall_vj=A.Qe)(i,n,o),rn=t.dynCall_jjj=(i,n,o,l,d)=>(rn=t.dynCall_jjj=A.Re)(i,n,o,l,d),nr=t.dynCall_iiijiiiiii=(i,n,o,l,d,h,m,y,b,$,_)=>(nr=t.dynCall_iiijiiiiii=A.Se)(i,n,o,l,d,h,m,y,b,$,_),$i=t.dynCall_viiff=(i,n,o,l,d)=>($i=t.dynCall_viiff=A.Te)(i,n,o,l,d),c=t.dynCall_viiiiiff=(i,n,o,l,d,h,m,y)=>(c=t.dynCall_viiiiiff=A.Ue)(i,n,o,l,d,h,m,y),v=t.dynCall_vfiii=(i,n,o,l,d)=>(v=t.dynCall_vfiii=A.Ve)(i,n,o,l,d),I=t.dynCall_viiiiff=(i,n,o,l,d,h,m)=>(I=t.dynCall_viiiiff=A.We)(i,n,o,l,d,h,m),B=t.dynCall_viiiiiiiiifiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(B=t.dynCall_viiiiiiiiifiii=A.Xe)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),H=t.dynCall_viiiiiiiijj=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(H=t.dynCall_viiiiiiiijj=A.Ye)(i,n,o,l,d,h,m,y,b,$,_,E,R),K=t.dynCall_iiiiiiiiiiiiiifii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)=>(K=t.dynCall_iiiiiiiiiiiiiifii=A.Ze)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q),ee=t.dynCall_viiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(ee=t.dynCall_viiiiiiiiiiii=A._e)(i,n,o,l,d,h,m,y,b,$,_,E,R),pe=t.dynCall_ij=(i,n,o)=>(pe=t.dynCall_ij=A.$e)(i,n,o),de=t.dynCall_iiiiiiiiiiiiiiiiifii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)=>(de=t.dynCall_iiiiiiiiiiiiiiiiifii=A.af)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve),ce=t.dynCall_vijjiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(ce=t.dynCall_vijjiiiiii=A.bf)(i,n,o,l,d,h,m,y,b,$,_,E),ge=t.dynCall_iiiijjj=(i,n,o,l,d,h,m,y,b,$)=>(ge=t.dynCall_iiiijjj=A.cf)(i,n,o,l,d,h,m,y,b,$),xe=t.dynCall_viiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_)=>(xe=t.dynCall_viiiiiiiiii=A.df)(i,n,o,l,d,h,m,y,b,$,_),Te=t.dynCall_iiijjj=(i,n,o,l,d,h,m,y,b)=>(Te=t.dynCall_iiijjj=A.ef)(i,n,o,l,d,h,m,y,b),q=t.dynCall_fffffff=(i,n,o,l,d,h,m)=>(q=t.dynCall_fffffff=A.ff)(i,n,o,l,d,h,m),ye=t.dynCall_viiiij=(i,n,o,l,d,h,m)=>(ye=t.dynCall_viiiij=A.gf)(i,n,o,l,d,h,m),Ee=t.dynCall_viijj=(i,n,o,l,d,h,m)=>(Ee=t.dynCall_viijj=A.hf)(i,n,o,l,d,h,m),kt=t.dynCall_vjjjjjjffiifiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue)=>(kt=t.dynCall_vjjjjjjffiifiiiiii=A.jf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue),Ci=t.dynCall_viiiiiiffiifiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)=>(Ci=t.dynCall_viiiiiiffiifiiiii=A.kf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q),Va=t.dynCall_viiiiiiffifiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(Va=t.dynCall_viiiiiiffifiiiii=A.lf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),Na=t.dynCall_viiiiiiffiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(Na=t.dynCall_viiiiiiffiiiiii=A.mf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),Ua=t.dynCall_vjjjjjjjjfffiifiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt)=>(Ua=t.dynCall_vjjjjjjjjfffiifiiiiii=A.nf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt),Ha=t.dynCall_vjjjjjjfffifiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He)=>(Ha=t.dynCall_vjjjjjjfffifiiiiiii=A.of)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He),La=t.dynCall_vjjjjjjfffifiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe)=>(La=t.dynCall_vjjjjjjfffifiiiii=A.pf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe),Ga=t.dynCall_vjjjjjjjjfffiifiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt)=>(Ga=t.dynCall_vjjjjjjjjfffiifiiiii=A.qf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt),Fa=t.dynCall_vijjfffiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(Fa=t.dynCall_vijjfffiii=A.rf)(i,n,o,l,d,h,m,y,b,$,_,E),qa=t.dynCall_vijiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(qa=t.dynCall_vijiiiiiiii=A.sf)(i,n,o,l,d,h,m,y,b,$,_,E),Ka=t.dynCall_vijjjjjjifiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e)=>(Ka=t.dynCall_vijjjjjjifiiiii=A.tf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e),Ya=t.dynCall_vjjjjjiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(Ya=t.dynCall_vjjjjjiiii=A.uf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),Xa=t.dynCall_vjjjjfiii=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(Xa=t.dynCall_vjjjjfiii=A.vf)(i,n,o,l,d,h,m,y,b,$,_,E,R),Za=t.dynCall_viifi=(i,n,o,l,d)=>(Za=t.dynCall_viifi=A.wf)(i,n,o,l,d),Qa=t.dynCall_iiiiiji=(i,n,o,l,d,h,m,y)=>(Qa=t.dynCall_iiiiiji=A.xf)(i,n,o,l,d,h,m,y),Ja=t.dynCall_vijjii=(i,n,o,l,d,h,m,y)=>(Ja=t.dynCall_vijjii=A.yf)(i,n,o,l,d,h,m,y),eo=t.dynCall_viiijiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E)=>(eo=t.dynCall_viiijiiiiii=A.zf)(i,n,o,l,d,h,m,y,b,$,_,E),to=t.dynCall_viiiiijjiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(to=t.dynCall_viiiiijjiiiii=A.Af)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),ro=t.dynCall_iiiiji=(i,n,o,l,d,h,m)=>(ro=t.dynCall_iiiiji=A.Bf)(i,n,o,l,d,h,m),io=t.dynCall_viiiiijiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(io=t.dynCall_viiiiijiiiiii=A.Cf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),no=t.dynCall_viiiijii=(i,n,o,l,d,h,m,y,b)=>(no=t.dynCall_viiiijii=A.Df)(i,n,o,l,d,h,m,y,b),ao=t.dynCall_viijjiii=(i,n,o,l,d,h,m,y,b,$)=>(ao=t.dynCall_viijjiii=A.Ef)(i,n,o,l,d,h,m,y,b,$),oo=t.dynCall_ijii=(i,n,o,l,d)=>(oo=t.dynCall_ijii=A.Ff)(i,n,o,l,d),so=t.dynCall_jjjjjjj=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(so=t.dynCall_jjjjjjj=A.Gf)(i,n,o,l,d,h,m,y,b,$,_,E,R),uo=t.dynCall_jjjjjj=(i,n,o,l,d,h,m,y,b,$,_)=>(uo=t.dynCall_jjjjjj=A.Hf)(i,n,o,l,d,h,m,y,b,$,_),lo=t.dynCall_vijjjjiij=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(lo=t.dynCall_vijjjjiij=A.If)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),co=t.dynCall_viiiiijij=(i,n,o,l,d,h,m,y,b,$,_)=>(co=t.dynCall_viiiiijij=A.Jf)(i,n,o,l,d,h,m,y,b,$,_),fo=t.dynCall_viiiiiijij=(i,n,o,l,d,h,m,y,b,$,_,E)=>(fo=t.dynCall_viiiiiijij=A.Kf)(i,n,o,l,d,h,m,y,b,$,_,E),po=t.dynCall_vijiii=(i,n,o,l,d,h,m)=>(po=t.dynCall_vijiii=A.Lf)(i,n,o,l,d,h,m),ho=t.dynCall_viiiiiiiiifi=(i,n,o,l,d,h,m,y,b,$,_,E)=>(ho=t.dynCall_viiiiiiiiifi=A.Mf)(i,n,o,l,d,h,m,y,b,$,_,E),mo=t.dynCall_iiijiiii=(i,n,o,l,d,h,m,y,b)=>(mo=t.dynCall_iiijiiii=A.Nf)(i,n,o,l,d,h,m,y,b),go=t.dynCall_viiiiiijjiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(go=t.dynCall_viiiiiijjiiiii=A.Of)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),yo=t.dynCall_viiiiiiijiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(yo=t.dynCall_viiiiiiijiiiiii=A.Pf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),bo=t.dynCall_vif=(i,n,o)=>(bo=t.dynCall_vif=A.Qf)(i,n,o),vo=t.dynCall_viif=(i,n,o,l)=>(vo=t.dynCall_viif=A.Rf)(i,n,o,l),wo=t.dynCall_viiiiiifii=(i,n,o,l,d,h,m,y,b,$)=>(wo=t.dynCall_viiiiiifii=A.Sf)(i,n,o,l,d,h,m,y,b,$),$o=t.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe)=>($o=t.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=A.Tf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe),Co=t.dynCall_viijji=(i,n,o,l,d,h,m,y)=>(Co=t.dynCall_viijji=A.Uf)(i,n,o,l,d,h,m,y),_o=t.dynCall_iiiiiiiiiiiji=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(_o=t.dynCall_iiiiiiiiiiiji=A.Vf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),So=t.dynCall_viifiifijjjii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(So=t.dynCall_viifiifijjjii=A.Wf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),xo=t.dynCall_viiiiiiiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e)=>(xo=t.dynCall_viiiiiiiiiiiiiiiiiiii=A.Xf)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e),Io=t.dynCall_iif=(i,n,o)=>(Io=t.dynCall_iif=A.Yf)(i,n,o),Ao=t.dynCall_viiiiifiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(Ao=t.dynCall_viiiiifiiiiii=A.Zf)(i,n,o,l,d,h,m,y,b,$,_,E,R),Eo=t.dynCall_vijiiiiiiijjii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)=>(Eo=t.dynCall_vijiiiiiiijjii=A._f)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q),To=t.dynCall_iiiiid=(i,n,o,l,d,h)=>(To=t.dynCall_iiiiid=A.$f)(i,n,o,l,d,h),Oo=t.dynCall_viiiijjj=(i,n,o,l,d,h,m,y,b,$,_)=>(Oo=t.dynCall_viiiijjj=A.ag)(i,n,o,l,d,h,m,y,b,$,_),ko=t.dynCall_viiiiiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le)=>(ko=t.dynCall_viiiiiiiiiiiiiiiiii=A.bg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le),Ro=t.dynCall_viiiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)=>(Ro=t.dynCall_viiiiiiiiiiiiiiii=A.cg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q),Po=t.dynCall_viiiiiiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)=>(Po=t.dynCall_viiiiiiiiiiiiiiiiiii=A.dg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve),Bo=t.dynCall_viiiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(Bo=t.dynCall_viiiiiiiiiiiiiii=A.eg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),Mo=t.dynCall_viiiiiiijjj=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(Mo=t.dynCall_viiiiiiijjj=A.fg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),jo=t.dynCall_iiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_)=>(jo=t.dynCall_iiiiiiiiiii=A.gg)(i,n,o,l,d,h,m,y,b,$,_),Do=t.dynCall_iiiiiiiiiiiiiiiiiifi=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)=>(Do=t.dynCall_iiiiiiiiiiiiiiiiiifi=A.hg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve),zo=t.dynCall_viiif=(i,n,o,l,d)=>(zo=t.dynCall_viiif=A.ig)(i,n,o,l,d),Wo=t.dynCall_iijjj=(i,n,o,l,d,h,m,y)=>(Wo=t.dynCall_iijjj=A.jg)(i,n,o,l,d,h,m,y),Vo=t.dynCall_viiiiji=(i,n,o,l,d,h,m,y)=>(Vo=t.dynCall_viiiiji=A.kg)(i,n,o,l,d,h,m,y),No=t.dynCall_iijjji=(i,n,o,l,d,h,m,y,b)=>(No=t.dynCall_iijjji=A.lg)(i,n,o,l,d,h,m,y,b),Uo=t.dynCall_ijijji=(i,n,o,l,d,h,m,y,b)=>(Uo=t.dynCall_ijijji=A.mg)(i,n,o,l,d,h,m,y,b),Ho=t.dynCall_viiij=(i,n,o,l,d,h)=>(Ho=t.dynCall_viiij=A.ng)(i,n,o,l,d,h),Lo=t.dynCall_viiijjiii=(i,n,o,l,d,h,m,y,b,$,_)=>(Lo=t.dynCall_viiijjiii=A.og)(i,n,o,l,d,h,m,y,b,$,_),Go=t.dynCall_iiiiijji=(i,n,o,l,d,h,m,y,b,$)=>(Go=t.dynCall_iiiiijji=A.pg)(i,n,o,l,d,h,m,y,b,$),Fo=t.dynCall_viji=(i,n,o,l,d)=>(Fo=t.dynCall_viji=A.qg)(i,n,o,l,d),qo=t.dynCall_iiiifi=(i,n,o,l,d,h)=>(qo=t.dynCall_iiiifi=A.rg)(i,n,o,l,d,h),Ko=t.dynCall_iiijii=(i,n,o,l,d,h,m)=>(Ko=t.dynCall_iiijii=A.sg)(i,n,o,l,d,h,m),Yo=t.dynCall_iiiiiiiiijii=(i,n,o,l,d,h,m,y,b,$,_,E,R)=>(Yo=t.dynCall_iiiiiiiiijii=A.tg)(i,n,o,l,d,h,m,y,b,$,_,E,R),Xo=t.dynCall_iiiijjii=(i,n,o,l,d,h,m,y,b,$)=>(Xo=t.dynCall_iiiijjii=A.ug)(i,n,o,l,d,h,m,y,b,$),Zo=t.dynCall_iiiiiijjjii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(Zo=t.dynCall_iiiiiijjjii=A.vg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),Qo=t.dynCall_iiijiii=(i,n,o,l,d,h,m,y)=>(Qo=t.dynCall_iiijiii=A.wg)(i,n,o,l,d,h,m,y),Jo=t.dynCall_iiiiiiiijjjfi=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)=>(Jo=t.dynCall_iiiiiiiijjjfi=A.xg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W),es=t.dynCall_iijiiii=(i,n,o,l,d,h,m,y)=>(es=t.dynCall_iijiiii=A.yg)(i,n,o,l,d,h,m,y),ts=t.dynCall_iijjjii=(i,n,o,l,d,h,m,y,b,$)=>(ts=t.dynCall_iijjjii=A.zg)(i,n,o,l,d,h,m,y,b,$),rs=t.dynCall_iiji=(i,n,o,l,d)=>(rs=t.dynCall_iiji=A.Ag)(i,n,o,l,d),is=t.dynCall_viiijiiiii=(i,n,o,l,d,h,m,y,b,$,_)=>(is=t.dynCall_viiijiiiii=A.Bg)(i,n,o,l,d,h,m,y,b,$,_),ns=t.dynCall_iid=(i,n,o)=>(ns=t.dynCall_iid=A.Cg)(i,n,o),as=t.dynCall_iiif=(i,n,o,l)=>(as=t.dynCall_iiif=A.Dg)(i,n,o,l),os=t.dynCall_vidi=(i,n,o,l)=>(os=t.dynCall_vidi=A.Eg)(i,n,o,l),ss=t.dynCall_vjiii=(i,n,o,l,d,h)=>(ss=t.dynCall_vjiii=A.Fg)(i,n,o,l,d,h),us=t.dynCall_iiiij=(i,n,o,l,d,h)=>(us=t.dynCall_iiiij=A.Gg)(i,n,o,l,d,h),ls=t.dynCall_viiijii=(i,n,o,l,d,h,m,y)=>(ls=t.dynCall_viiijii=A.Hg)(i,n,o,l,d,h,m,y),ds=t.dynCall_viijiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S)=>(ds=t.dynCall_viijiiiiiiiii=A.Ig)(i,n,o,l,d,h,m,y,b,$,_,E,R,S),cs=t.dynCall_fiiii=(i,n,o,l,d)=>(cs=t.dynCall_fiiii=A.Jg)(i,n,o,l,d),fs=t.dynCall_jfi=(i,n,o)=>(fs=t.dynCall_jfi=A.Kg)(i,n,o),ps=t.dynCall_viiiiiiiiiiiiii=(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)=>(ps=t.dynCall_viiiiiiiiiiiiii=A.Lg)(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j),hs=t.dynCall_jiij=(i,n,o,l,d)=>(hs=t.dynCall_jiij=A.Mg)(i,n,o,l,d),ms=t.dynCall_fiii=(i,n,o,l)=>(ms=t.dynCall_fiii=A.Ng)(i,n,o,l),gs=i=>(gs=A.Og)(i),ys=()=>(ys=A.Pg)(),bs=i=>(bs=A.Qg)(i),vs=()=>(vs=A.Rg)();t.___start_em_js=1347937,t.___stop_em_js=1348098;function tf(i,n,o,l){var d=N();try{return Yr(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function rf(i,n,o){var l=N();try{return _r(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function nf(i,n,o){var l=N();try{Kr(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function af(i,n){var o=N();try{return Xr(i,n)}catch(l){if(U(o),l!==l+0)throw l;V(1,0)}}function of(i,n){var o=N();try{qr(i,n)}catch(l){if(U(o),l!==l+0)throw l;V(1,0)}}function sf(i){var n=N();try{We(i)}catch(o){if(U(n),o!==o+0)throw o;V(1,0)}}function uf(i,n,o,l,d,h,m){var y=N();try{return Ui(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function lf(i,n,o,l,d,h){var m=N();try{return Sr(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function df(i,n,o,l,d){var h=N();try{return Zr(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function cf(i,n,o,l){var d=N();try{Ir(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function ff(i,n,o,l,d){var h=N();try{ii(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function pf(i){var n=N();try{return Jr(i)}catch(o){if(U(n),o!==o+0)throw o;V(1,0)}}function hf(i,n,o,l,d,h){var m=N();try{Hi(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function mf(i,n,o,l,d,h,m,y){var b=N();try{return ni(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function gf(i,n){var o=N();try{return ai(i,n)}catch(l){if(U(o),l!==l+0)throw l;V(1,0)}}function yf(i,n){var o=N();try{return oi(i,n)}catch(l){if(U(o),l!==l+0)throw l;V(1,0)}}function bf(i,n,o,l,d,h,m,y,b){var $=N();try{return Ct(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function vf(i,n,o,l,d,h,m){var y=N();try{si(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function wf(i,n,o,l,d,h,m,y){var b=N();try{ui(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function $f(i,n,o,l,d,h,m,y,b,$){var _=N();try{return li(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Cf(i,n,o,l,d,h,m,y,b){var $=N();try{qi(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function _f(i,n,o,l,d,h,m,y,b,$){var _=N();try{Qi(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Sf(i,n,o,l){var d=N();try{Ji(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function xf(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{return tn(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function If(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{rr(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Af(i,n,o,l,d,h,m){var y=N();try{ci(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Ef(i,n,o,l,d,h,m){var y=N();try{Tr(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Tf(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{Or(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Of(i,n,o,l,d){var h=N();try{kr(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function kf(i,n,o,l,d){var h=N();try{return cs(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Rf(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{B(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Pf(i,n,o,l,d){var h=N();try{v(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Bf(i,n,o,l,d,h,m){var y=N();try{I(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Mf(i,n,o,l,d){var h=N();try{$i(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function jf(i,n,o,l,d,h,m,y){var b=N();try{c(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Df(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q){var ne=N();try{return K(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)}catch(le){if(U(ne),le!==le+0)throw le;V(1,0)}}function zf(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{ee(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Wf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve){var $e=N();try{return de(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)}catch(Ce){if(U($e),Ce!==Ce+0)throw Ce;V(1,0)}}function Vf(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{xe(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Nf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q){var ne=N();try{Ci(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)}catch(le){if(U(ne),le!==le+0)throw le;V(1,0)}}function Uf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{Va(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function Hf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{Na(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function Lf(i,n,o,l,d,h,m){var y=N();try{return q(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Gf(i,n,o,l,d){var h=N();try{Za(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Ff(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{ho(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function qf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{ps(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function Kf(i,n,o){var l=N();try{bo(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function Yf(i,n,o,l,d,h,m,y,b,$){var _=N();try{wo(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Xf(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{ir(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function Zf(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e){var Ce=N();try{xo(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e)}catch(Oe){if(U(Ce),Oe!==Oe+0)throw Oe;V(1,0)}}function Qf(i,n,o){var l=N();try{return Io(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function Jf(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{Ao(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function ep(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q){var ne=N();try{Ro(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)}catch(le){if(U(ne),le!==le+0)throw le;V(1,0)}}function tp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve){var $e=N();try{Po(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)}catch(Ce){if(U($e),Ce!==Ce+0)throw Ce;V(1,0)}}function rp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le){var ve=N();try{ko(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le)}catch($e){if(U(ve),$e!==$e+0)throw $e;V(1,0)}}function ip(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{return jo(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function np(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve){var $e=N();try{return Do(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve)}catch(Ce){if(U($e),Ce!==Ce+0)throw Ce;V(1,0)}}function ap(i,n,o,l,d){var h=N();try{zo(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function op(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{pi(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function sp(i,n,o,l){var d=N();try{vo(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function up(i,n,o,l,d,h){var m=N();try{return qo(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function lp(i,n,o){var l=N();try{return ns(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function dp(i,n,o,l){var d=N();try{return as(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function cp(i,n,o,l){var d=N();try{os(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function fp(i,n,o,l){var d=N();try{return ms(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function pp(i,n,o,l,d,h){var m=N();try{return To(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function hp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{Bo(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function mp(i,n,o){var l=N();try{return Li(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function gp(i,n,o){var l=N();try{return Fi(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function yp(i,n,o,l,d){var h=N();try{return xr(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function bp(i,n,o,l){var d=N();try{return ei(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function vp(i,n,o,l){var d=N();try{ri(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function wp(i,n){var o=N();try{return Gi(i,n)}catch(l){if(U(o),l!==l+0)throw l;V(1,0)}}function $p(i,n,o,l,d){var h=N();try{yt(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Cp(i,n,o,l,d,h){var m=N();try{tr(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function _p(i,n,o,l,d,h,m,y){var b=N();try{ls(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Sp(i,n,o,l,d,h,m){var y=N();try{Ee(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function xp(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{return Ar(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function Ip(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{Ki(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Ap(i,n,o,l,d,h,m,y){var b=N();try{Xi(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Ep(i,n,o,l,d,h,m,y){var b=N();try{Zi(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Tp(i,n,o){var l=N();try{return er(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function Op(i,n,o,l,d,h,m,y,b,$){var _=N();try{return en(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function kp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{Er(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function Rp(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{di(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Pp(i,n,o,l,d,h){var m=N();try{Yi(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function Bp(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{fi(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function Mp(i,n,o,l,d,h,m,y,b){var $=N();try{hi(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function jp(i,n,o,l){var d=N();try{return mi(i,n,o,l)}catch(h){if(U(d),h!==h+0)throw h;V(1,0)}}function Dp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt){var ar=N();try{Rr(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt)}catch(or){if(U(ar),or!==or+0)throw or;V(1,0)}}function zp(i,n,o,l,d,h,m){var y=N();try{gi(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Wp(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{yi(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Vp(i,n,o,l,d,h){var m=N();try{return bi(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function Np(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{return vi(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function Up(i,n,o){var l=N();try{wi(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function Hp(i,n,o,l,d){var h=N();try{return rn(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Lp(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{return nr(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Gp(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{H(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Fp(i,n,o){var l=N();try{return pe(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function qp(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{ce(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function Kp(i,n,o,l,d,h,m,y,b,$){var _=N();try{return ge(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Yp(i,n,o,l,d,h,m,y,b){var $=N();try{return Te(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function Xp(i,n,o,l,d,h,m){var y=N();try{ye(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Zp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue){var He=N();try{kt(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue)}catch(Ye){if(U(He),Ye!==Ye+0)throw Ye;V(1,0)}}function Qp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt){var ar=N();try{Ua(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt,vt)}catch(or){if(U(ar),or!==or+0)throw or;V(1,0)}}function Jp(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He){var Ye=N();try{Ha(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He)}catch(Qe){if(U(Ye),Qe!==Qe+0)throw Qe;V(1,0)}}function eh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe){var Ue=N();try{La(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe)}catch(He){if(U(Ue),He!==He+0)throw He;V(1,0)}}function th(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt){var vt=N();try{Ga(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe,bt)}catch(ar){if(U(vt),ar!==ar+0)throw ar;V(1,0)}}function rh(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{Fa(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function ih(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{qa(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function nh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e){var Ce=N();try{Ka(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e)}catch(Oe){if(U(Ce),Oe!==Oe+0)throw Oe;V(1,0)}}function ah(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{Ya(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function oh(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{Xa(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function sh(i,n,o){var l=N();try{return fs(i,n,o)}catch(d){if(U(l),d!==d+0)throw d;V(1,0)}}function uh(i,n,o,l,d,h,m,y){var b=N();try{return Qa(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function lh(i,n,o,l,d,h,m,y){var b=N();try{Ja(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function dh(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{eo(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function ch(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j){var W=N();try{to(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j)}catch(Q){if(U(W),Q!==Q+0)throw Q;V(1,0)}}function fh(i,n,o,l,d,h,m){var y=N();try{return ro(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function ph(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{io(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function hh(i,n,o,l,d,h,m,y,b){var $=N();try{no(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function mh(i,n,o,l,d,h,m,y,b,$){var _=N();try{ao(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function gh(i,n,o,l,d){var h=N();try{return oo(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function yh(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{return uo(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function bh(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{return so(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function vh(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{lo(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function wh(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{co(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function $h(i,n,o,l,d,h,m,y,b,$,_,E){var R=N();try{fo(i,n,o,l,d,h,m,y,b,$,_,E)}catch(S){if(U(R),S!==S+0)throw S;V(1,0)}}function Ch(i,n,o,l,d,h,m){var y=N();try{po(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function _h(i,n,o,l,d,h,m,y,b){var $=N();try{return mo(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function Sh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{go(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function xh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{yo(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function Ih(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe){var bt=N();try{$o(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q,ne,le,ve,$e,Ce,Oe,Ue,He,Ye,Qe)}catch(vt){if(U(bt),vt!==vt+0)throw vt;V(1,0)}}function Ah(i,n,o,l,d,h,m,y){var b=N();try{Co(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Eh(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{return _o(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Th(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{So(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function Oh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q){var ne=N();try{Eo(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W,Q)}catch(le){if(U(ne),le!==le+0)throw le;V(1,0)}}function kh(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{Oo(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Rh(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{Mo(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Ph(i,n,o,l,d,h,m,y){var b=N();try{return Wo(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Bh(i,n,o,l,d){var h=N();try{return hs(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Mh(i,n,o,l,d,h,m,y){var b=N();try{Vo(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function jh(i,n,o,l,d,h,m,y,b){var $=N();try{return No(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function Dh(i,n,o,l,d,h,m,y,b){var $=N();try{return Uo(i,n,o,l,d,h,m,y,b)}catch(_){if(U($),_!==_+0)throw _;V(1,0)}}function zh(i,n,o,l,d,h){var m=N();try{Ho(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function Wh(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{Lo(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Vh(i,n,o,l,d,h,m,y,b,$){var _=N();try{return Go(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Nh(i,n,o,l,d){var h=N();try{Fo(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Uh(i,n,o,l,d,h,m){var y=N();try{return Ko(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function Hh(i,n,o,l,d,h,m,y,b,$,_,E,R){var S=N();try{return Yo(i,n,o,l,d,h,m,y,b,$,_,E,R)}catch(j){if(U(S),j!==j+0)throw j;V(1,0)}}function Lh(i,n,o,l,d,h,m,y,b,$){var _=N();try{return Xo(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Gh(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{return Zo(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Fh(i,n,o,l,d,h,m,y){var b=N();try{return Qo(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function qh(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W){var Q=N();try{return Jo(i,n,o,l,d,h,m,y,b,$,_,E,R,S,j,W)}catch(ne){if(U(Q),ne!==ne+0)throw ne;V(1,0)}}function Kh(i,n,o,l,d,h,m,y){var b=N();try{return es(i,n,o,l,d,h,m,y)}catch($){if(U(b),$!==$+0)throw $;V(1,0)}}function Yh(i,n,o,l,d,h,m,y,b,$){var _=N();try{return ts(i,n,o,l,d,h,m,y,b,$)}catch(E){if(U(_),E!==E+0)throw E;V(1,0)}}function Xh(i,n,o,l,d){var h=N();try{return rs(i,n,o,l,d)}catch(m){if(U(h),m!==m+0)throw m;V(1,0)}}function Zh(i,n,o,l,d,h,m,y,b,$,_){var E=N();try{is(i,n,o,l,d,h,m,y,b,$,_)}catch(R){if(U(E),R!==R+0)throw R;V(1,0)}}function Qh(i,n,o,l,d,h,m,y,b,$,_,E,R,S){var j=N();try{ds(i,n,o,l,d,h,m,y,b,$,_,E,R,S)}catch(W){if(U(j),W!==W+0)throw W;V(1,0)}}function Jh(i,n,o,l,d,h){var m=N();try{ss(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function em(i,n,o,l,d,h){var m=N();try{return us(i,n,o,l,d,h)}catch(y){if(U(m),y!==y+0)throw y;V(1,0)}}function tm(i){var n=N();try{return Qr(i)}catch(o){if(U(n),o!==o+0)throw o;V(1,0)}}function rm(i,n,o,l,d,h,m){var y=N();try{return ti(i,n,o,l,d,h,m)}catch(b){if(U(y),b!==b+0)throw b;V(1,0)}}function im(i){i=Object.assign({},i);var n=l=>()=>l()>>>0,o=l=>d=>l(d)>>>0;return i.__errno_location=n(i.__errno_location),i.malloc=o(i.malloc),i.stackSave=n(i.stackSave),i.stackAlloc=o(i.stackAlloc),i}t.stackAlloc=Cr,t.stackSave=N,t.stackRestore=U,t.UTF8ToString=at,t.stringToUTF8=(i,n,o)=>zr(i,fe,n,o),t.lengthBytesUTF8=cr;var nn;it=function i(){nn||ws(),nn||(it=i)};function ws(){function i(){if(!nn&&(nn=!0,t.calledRun=!0,!Z)){if(Kt(Be),s(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;){var n=t.postRun.shift();Me.unshift(n)}Kt(Me)}}if(!(0<Ae)){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)je();Kt(ue),0<Ae||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),i()},1)):i())}}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ws(),r.ready}})();typeof Ks=="object"&&typeof Xn=="object"?Xn.exports=qs:typeof define=="function"&&define.amd&&define([],()=>qs)});var Xs=Pr(()=>{});var Zs=Pr(()=>{});var Qs={};Br(Qs,{cpus:()=>pm});var pm,Js=oe(()=>{pm=void 0});var ru=Pr((tu,Zn)=>{"use strict";var eu=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(r={}){function t(){return Pe.buffer!=Ae.buffer&&Ie(),Ae}function s(){return Pe.buffer!=Ae.buffer&&Ie(),At}function a(){return Pe.buffer!=Ae.buffer&&Ie(),it}function f(){return Pe.buffer!=Ae.buffer&&Ie(),nt}function p(){return Pe.buffer!=Ae.buffer&&Ie(),ie}function g(){return Pe.buffer!=Ae.buffer&&Ie(),we}var u=r,w,C;u.ready=new Promise((c,v)=>{w=c,C=v}),u.jsepInit=(c,v,I,B,H,K,ee,pe)=>{u.Qb=c,u.wb=v,u.yb=I,u.jb=B,u.xb=H,u.Ea=K,u.zb=ee,u.Ab=pe,v=(de,ce,ge)=>(...xe)=>{let Te=yt,q=ce?.();xe=de(...xe);let ye=ce?.();return q!==ye&&(de=ye,ge(q),ce=ge=null),yt!=Te?Yi():xe},I=de=>async(...ce)=>{try{if(u.bb)throw Error("Session already started");let ge=u.bb={Fb:ce[0],errors:[]},xe=await de(...ce);if(u.bb!==ge)throw Error("Session mismatch");c.flush();let Te=ge.errors;if(0<Te.length){let q=await Promise.all(Te);if(q=q.filter(ye=>ye),0<q.length)throw Error(q.join(`
`))}return xe}finally{u.bb=null}},u._OrtRun=I(v(u._OrtRun,()=>u._OrtRun,de=>u._OrtRun=de)),u._OrtRunWithBinding=I(v(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,de=>u._OrtRunWithBinding=de)),u._OrtBindInput=v(u._OrtBindInput,()=>u._OrtBindInput,de=>u._OrtBindInput=de),u.jsepRegisterBuffer=(de,ce,ge,xe)=>c.registerBuffer(de,ce,ge,xe),u.jsepUnregisterBuffers=de=>{c.unregisterBuffers(de)},u.jsepGetBuffer=de=>c.getBuffer(de),u.jsepCreateDownloader=(de,ce,ge)=>c.createDownloader(de,ce,ge)};var T=Object.assign({},u),x="./this.program",O=(c,v)=>{throw v},k=typeof window=="object",P=typeof importScripts=="function",D=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",M=u.ENVIRONMENT_IS_PTHREAD||!1,z="";function G(c){return u.locateFile?u.locateFile(c,z):z+c}var L,Y,A;if(D){var Z=(qn(),sr(Fn)),J=(Yn(),sr(Kn));z=P?J.dirname(z)+"/":__dirname+"/",L=(v,I)=>(v=v.startsWith("file://")?new URL(v):J.normalize(v),Z.readFileSync(v,I?void 0:"utf8")),A=v=>(v=L(v,!0),v.buffer||(v=new Uint8Array(v)),v),Y=(v,I,B,H=!0)=>{v=v.startsWith("file://")?new URL(v):J.normalize(v),Z.readFile(v,H?void 0:"utf8",(K,ee)=>{K?B(K):I(H?ee.buffer:ee)})},!u.thisProgram&&1<process.argv.length&&(x=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),O=(v,I)=>{throw process.exitCode=v,I},u.inspect=()=>"[Emscripten Module object]";let c;try{c=Xs()}catch(v){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),v}global.Worker=c.Worker}else(k||P)&&(P?z=self.location.href:typeof document<"u"&&document.currentScript&&(z=document.currentScript.src),typeof e<"u"&&e&&(z=e),z.indexOf("blob:")!==0?z=z.substr(0,z.replace(/[?#].*/,"").lastIndexOf("/")+1):z="",D||(L=c=>{var v=new XMLHttpRequest;return v.open("GET",c,!1),v.send(null),v.responseText},P&&(A=c=>{var v=new XMLHttpRequest;return v.open("GET",c,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),Y=(c,v,I)=>{var B=new XMLHttpRequest;B.open("GET",c,!0),B.responseType="arraybuffer",B.onload=()=>{B.status==200||B.status==0&&B.response?v(B.response):I()},B.onerror=I,B.send(null)}));D&&typeof performance>"u"&&(global.performance=Zs().performance);var re=console.log.bind(console),fe=console.error.bind(console);D&&(re=(...c)=>Z.writeSync(1,c.join(" ")+`
`),fe=(...c)=>Z.writeSync(2,c.join(" ")+`
`));var F=u.print||re,ae=u.printErr||fe;Object.assign(u,T),T=null,u.thisProgram&&(x=u.thisProgram),u.quit&&(O=u.quit);var _e;u.wasmBinary&&(_e=u.wasmBinary);var he=u.noExitRuntime||!0;typeof WebAssembly!="object"&&$t("no native wasm support detected");var Pe,ue,Be,Me=!1,je,Ae,At,it,nt,ie,we;function Ie(){var c=Pe.buffer;u.HEAP8=Ae=new Int8Array(c),u.HEAP16=new Int16Array(c),u.HEAP32=it=new Int32Array(c),u.HEAPU8=At=new Uint8Array(c),u.HEAPU16=new Uint16Array(c),u.HEAPU32=nt=new Uint32Array(c),u.HEAPF32=ie=new Float32Array(c),u.HEAPF64=we=new Float64Array(c)}var rt=u.INITIAL_MEMORY||16777216;if(5242880<=rt||$t("INITIAL_MEMORY should be larger than STACK_SIZE, was "+rt+"! (STACK_SIZE=5242880)"),M)Pe=u.wasmMemory;else if(u.wasmMemory)Pe=u.wasmMemory;else if(Pe=new WebAssembly.Memory({initial:rt/65536,maximum:65536,shared:!0}),!(Pe.buffer instanceof SharedArrayBuffer))throw ae("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),D&&ae("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ie(),rt=Pe.buffer.byteLength;var dt=[],qe=[],Je=[],ut=0;function Et(){return he||0<ut}var ht=0,Kt=null,Tt=null;function Yt(){ht++,u.monitorRunDependencies&&u.monitorRunDependencies(ht)}function wt(){if(ht--,u.monitorRunDependencies&&u.monitorRunDependencies(ht),ht==0&&(Kt!==null&&(clearInterval(Kt),Kt=null),Tt)){var c=Tt;Tt=null,c()}}function $t(c){throw u.onAbort&&u.onAbort(c),c="Aborted("+c+")",ae(c),Me=!0,je=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),C(c),c}function Xt(c){return c.startsWith("data:application/octet-stream;base64,")}var Wt;Wt="ort-wasm-simd-threaded.wasm",Xt(Wt)||(Wt=G(Wt));function Dr(c){if(c==Wt&&_e)return new Uint8Array(_e);if(A)return A(c);throw"both async and sync fetching of the wasm failed"}function at(c){if(!_e&&(k||P)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(v=>{if(!v.ok)throw"failed to load wasm binary file at '"+c+"'";return v.arrayBuffer()}).catch(()=>Dr(c));if(Y)return new Promise((v,I)=>{Y(c,B=>v(new Uint8Array(B)),I)})}return Promise.resolve().then(()=>Dr(c))}function cr(c,v,I){return at(c).then(B=>WebAssembly.instantiate(B,v)).then(B=>B).then(I,B=>{ae("failed to asynchronously prepare wasm: "+B),$t(B)})}function zr(c,v){var I=Wt;return _e||typeof WebAssembly.instantiateStreaming!="function"||Xt(I)||I.startsWith("file://")||D||typeof fetch!="function"?cr(I,c,v):fetch(I,{credentials:"same-origin"}).then(B=>WebAssembly.instantiateStreaming(B,c).then(v,function(H){return ae("wasm streaming compile failed: "+H),ae("falling back to ArrayBuffer instantiation"),cr(I,c,v)}))}var mt,fr={913596:c=>{u.Ea("Abs",c,void 0)},913647:c=>{u.Ea("Neg",c,void 0)},913698:c=>{u.Ea("Floor",c,void 0)},913751:c=>{u.Ea("Ceil",c,void 0)},913803:c=>{u.Ea("Reciprocal",c,void 0)},913861:c=>{u.Ea("Sqrt",c,void 0)},913913:c=>{u.Ea("Exp",c,void 0)},913964:c=>{u.Ea("Erf",c,void 0)},914015:c=>{u.Ea("Sigmoid",c,void 0)},914070:c=>{u.Ea("Log",c,void 0)},914121:c=>{u.Ea("Sin",c,void 0)},914172:c=>{u.Ea("Cos",c,void 0)},914223:c=>{u.Ea("Tan",c,void 0)},914274:c=>{u.Ea("Asin",c,void 0)},914326:c=>{u.Ea("Acos",c,void 0)},914378:c=>{u.Ea("Atan",c,void 0)},914430:c=>{u.Ea("Sinh",c,void 0)},914482:c=>{u.Ea("Cosh",c,void 0)},914534:c=>{u.Ea("Asinh",c,void 0)},914587:c=>{u.Ea("Acosh",c,void 0)},914640:c=>{u.Ea("Atanh",c,void 0)},914693:c=>{u.Ea("Tanh",c,void 0)},914745:c=>{u.Ea("Not",c,void 0)},914796:(c,v,I)=>{u.Ea("Clip",c,{min:v,max:I})},914865:c=>{u.Ea("Clip",c,void 0)},914917:(c,v)=>{u.Ea("Elu",c,{alpha:v})},914975:c=>{u.Ea("Relu",c,void 0)},915027:(c,v)=>{u.Ea("LeakyRelu",c,{alpha:v})},915091:(c,v)=>{u.Ea("ThresholdedRelu",c,{alpha:v})},915161:(c,v)=>{u.Ea("Cast",c,{to:v})},915219:c=>{u.Ea("Add",c,void 0)},915270:c=>{u.Ea("Sub",c,void 0)},915321:c=>{u.Ea("Mul",c,void 0)},915372:c=>{u.Ea("Div",c,void 0)},915423:c=>{u.Ea("Pow",c,void 0)},915474:c=>{u.Ea("Equal",c,void 0)},915527:c=>{u.Ea("Greater",c,void 0)},915582:c=>{u.Ea("GreaterOrEqual",c,void 0)},915644:c=>{u.Ea("Less",c,void 0)},915696:c=>{u.Ea("LessOrEqual",c,void 0)},915755:(c,v,I,B,H)=>{u.Ea("ReduceMean",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},915919:(c,v,I,B,H)=>{u.Ea("ReduceMax",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916082:(c,v,I,B,H)=>{u.Ea("ReduceMin",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916245:(c,v,I,B,H)=>{u.Ea("ReduceProd",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916409:(c,v,I,B,H)=>{u.Ea("ReduceSum",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916572:(c,v,I,B,H)=>{u.Ea("ReduceL1",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916734:(c,v,I,B,H)=>{u.Ea("ReduceL2",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916896:(c,v,I,B,H)=>{u.Ea("ReduceLogSum",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917062:(c,v,I,B,H)=>{u.Ea("ReduceSumSquare",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917231:(c,v,I,B,H)=>{u.Ea("ReduceLogSumExp",c,{keepDims:!!v,noopWithEmptyAxes:!!I,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917400:c=>{u.Ea("Where",c,void 0)},917453:(c,v,I)=>{u.Ea("Transpose",c,{perm:v?Array.from(a().subarray(I>>>0,I+v>>>0)):[]})},917566:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:v,dilations:[I],group:B,kernel_shape:[H],pads:[K,ee],strides:[pe],wIsConst:()=>!!t()[ce>>>0],outputPadding:ge?Array.from(a().subarray(xe>>>0,xe+ge>>>0)):[],outputShape:Te?Array.from(a().subarray(q>>>0,q+Te>>>0)):[],activation:et(ye)})},917980:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(a().subarray(I>>>0,I+2>>>0)),group:B,kernelShape:Array.from(a().subarray(H>>>0,H+2>>>0)),pads:Array.from(a().subarray(K>>>0,K+4>>>0)),strides:Array.from(a().subarray(ee>>>0,ee+2>>>0)),wIsConst:()=>!!t()[de>>>0],outputPadding:0<ce?Array.from(a().subarray(ge>>>0,ge+ce>>>0)):[],outputShape:0<xe?Array.from(a().subarray(Te>>>0,Te+xe>>>0)):[],activation:et(q)})},918537:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:v,dilations:[I],group:B,kernel_shape:[H],pads:[K,ee],strides:[pe],wIsConst:()=>!!t()[ce>>>0],outputPadding:ge?Array.from(a().subarray(xe>>>0,xe+ge>>>0)):[],outputShape:Te?Array.from(a().subarray(q>>>0,q+Te>>>0)):[],activation:et(ye)})},918951:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(a().subarray(I>>>0,I+2>>>0)),group:B,kernelShape:Array.from(a().subarray(H>>>0,H+2>>>0)),pads:Array.from(a().subarray(K>>>0,K+4>>>0)),strides:Array.from(a().subarray(ee>>>0,ee+2>>>0)),wIsConst:()=>!!t()[de>>>0],outputPadding:0<ce?Array.from(a().subarray(ge>>>0,ge+ce>>>0)):[],outputShape:0<xe?Array.from(a().subarray(Te>>>0,Te+xe>>>0)):[],activation:et(q)})},919508:(c,v)=>{u.Ea("GlobalAveragePool",c,{format:v?"NHWC":"NCHW"})},919599:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye,Ee)=>{u.Ea("AveragePool",c,{format:Ee?"NHWC":"NCHW",auto_pad:v,ceil_mode:I,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,xe,Te],strides:[q,ye]})},919883:(c,v)=>{u.Ea("GlobalAveragePool",c,{format:v?"NHWC":"NCHW"})},919974:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye,Ee)=>{u.Ea("AveragePool",c,{format:Ee?"NHWC":"NCHW",auto_pad:v,ceil_mode:I,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,xe,Te],strides:[q,ye]})},920258:(c,v)=>{u.Ea("GlobalMaxPool",c,{format:v?"NHWC":"NCHW"})},920345:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye,Ee)=>{u.Ea("MaxPool",c,{format:Ee?"NHWC":"NCHW",auto_pad:v,ceil_mode:I,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,xe,Te],strides:[q,ye]})},920625:(c,v)=>{u.Ea("GlobalMaxPool",c,{format:v?"NHWC":"NCHW"})},920712:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye,Ee)=>{u.Ea("MaxPool",c,{format:Ee?"NHWC":"NCHW",auto_pad:v,ceil_mode:I,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,xe,Te],strides:[q,ye]})},920992:(c,v,I,B,H)=>{u.Ea("Gemm",c,{alpha:v,beta:I,transA:B,transB:H})},921096:c=>{u.Ea("MatMul",c,void 0)},921150:(c,v,I,B)=>{u.Ea("ArgMax",c,{keepDims:!!v,selectLastIndex:!!I,axis:B})},921258:(c,v,I,B)=>{u.Ea("ArgMin",c,{keepDims:!!v,selectLastIndex:!!I,axis:B})},921366:(c,v)=>{u.Ea("Softmax",c,{axis:v})},921429:(c,v)=>{u.Ea("Concat",c,{axis:v})},921489:(c,v,I,B,H)=>{u.Ea("Split",c,{axis:v,numOutputs:I,splitSizes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},921634:c=>{u.Ea("Expand",c,void 0)},921688:(c,v)=>{u.Ea("Gather",c,{axis:Number(v)})},921759:(c,v)=>{u.Ea("GatherElements",c,{axis:Number(v)})},921838:(c,v,I,B,H,K,ee,pe,de,ce,ge)=>{u.Ea("Resize",c,{antialias:v,axes:I?Array.from(a().subarray(B>>>0,B+I>>>0)):[],coordinateTransformMode:et(H),cubicCoeffA:K,excludeOutside:ee,extrapolationValue:pe,keepAspectRatioPolicy:et(de),mode:et(ce),nearestMode:et(ge)})},922189:(c,v,I,B,H,K,ee)=>{u.Ea("Slice",c,{starts:v?Array.from(a().subarray(I>>>0,I+v>>>0)):[],ends:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[],axes:K?Array.from(a().subarray(ee>>>0,ee+K>>>0)):[]})},922420:c=>{u.Ea("Tile",c,void 0)},922472:(c,v,I)=>{u.Ea("LayerNormalization",c,{axis:Number(v),epsilon:Number(I)})},922579:(c,v,I)=>{u.Ea("InstanceNormalization",c,{epsilon:v,format:I?"NHWC":"NCHW"})},922693:(c,v,I)=>{u.Ea("InstanceNormalization",c,{epsilon:v,format:I?"NHWC":"NCHW"})},922807:c=>{u.Ea("Range",c,void 0)},922860:(c,v)=>{u.Ea("Einsum",c,{equation:et(v)})},922941:(c,v,I,B,H)=>{u.Ea("Pad",c,{mode:v,value:I,pads:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},923073:(c,v,I,B,H,K)=>{u.Ea("BatchNormalization",c,{epsilon:v,momentum:I,spatial:!!H,trainingMode:!!B,format:K?"NHWC":"NCHW"})},923242:(c,v,I,B,H,K)=>{u.Ea("BatchNormalization",c,{epsilon:v,momentum:I,spatial:!!H,trainingMode:!!B,format:K?"NHWC":"NCHW"})},923411:(c,v,I)=>{u.Ea("CumSum",c,{exclusive:Number(v),reverse:Number(I)})},923508:(c,v,I,B,H,K,ee,pe,de)=>{u.Ea("Attention",c,{numHeads:v,isUnidirectional:I,maskFilterValue:B,scale:H,doRotary:K,qkvHiddenSizes:ee?Array.from(a().subarray(Number(pe)>>>0,Number(pe)+ee>>>0)):[],pastPresentShareBuffer:!!de})},923780:c=>{u.Ea("Gelu",c,void 0)},923832:(c,v,I,B,H,K)=>{u.Ea("MultiHeadAttention",c,{numHeads:v,isUnidirectional:I,maskFilterValue:B,scale:H,doRotary:K})},923991:c=>{u.Ea("BiasAdd",c,void 0)},924046:c=>{u.Ea("BiasSplitGelu",c,void 0)},924107:(c,v)=>{u.Ea("SkipLayerNormalization",c,{epsilon:v})},924188:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:v,dilations:[I],group:B,kernel_shape:[H],pads:K?Array.from(a().subarray(ee>>>0,ee+K>>>0)):[],strides:[pe],w_is_const:()=>!!t()[ce>>>0],activation:et(ge),activation_params:xe?Array.from(p().subarray(Te>>>0,Te+xe>>>0)):[]})},924569:(c,v,I,B,H,K,ee,pe,de,ce,ge,xe,Te,q,ye,Ee)=>{u.Ea("Conv",c,{format:xe?"NHWC":"NCHW",auto_pad:v,dilations:[I,B],group:H,kernel_shape:[K,ee],pads:pe?Array.from(a().subarray(de>>>0,de+pe>>>0)):[],strides:[ce,ge],w_is_const:()=>!!t()[Te>>>0],activation:et(q),activation_params:ye?Array.from(p().subarray(Ee>>>0,Ee+ye>>>0)):[]})},924971:c=>{u.zb(c)},925005:(c,v)=>u.Ab(c,v,u.bb.Fb,u.bb.errors),925117:c=>u.wb(c),925150:c=>u.yb(c),925182:(c,v,I)=>{u.jb(c,v,I,!0)},925221:(c,v,I)=>{u.jb(c,v,I)}};function Zt(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function pr(c){c.terminate(),c.onmessage=()=>{}}function hr(c){(c=be.Qa[c])||$t(),be.Eb(c)}function Wr(c){var v=be.tb();if(!v)return 6;be.Ya.push(v),be.Qa[c.Xa]=v,v.Xa=c.Xa;var I={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return D&&v.unref(),v.postMessage(I,c.Mb),0}var mr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Vr=(c,v,I)=>{v>>>=0;var B=v+I;for(I=v;c[I]&&!(I>=B);)++I;if(16<I-v&&c.buffer&&mr)return mr.decode(c.buffer instanceof SharedArrayBuffer?c.slice(v,I):c.subarray(v,I));for(B="";v<I;){var H=c[v++];if(H&128){var K=c[v++]&63;if((H&224)==192)B+=String.fromCharCode((H&31)<<6|K);else{var ee=c[v++]&63;H=(H&240)==224?(H&15)<<12|K<<6|ee:(H&7)<<18|K<<12|ee<<6|c[v++]&63,65536>H?B+=String.fromCharCode(H):(H-=65536,B+=String.fromCharCode(55296|H>>10,56320|H&1023))}}else B+=String.fromCharCode(H)}return B},et=(c,v)=>(c>>>=0)?Vr(s(),c,v):"";function Pi(c){if(M)return We(1,1,c);je=c,Et()||(be.Hb(),u.onExit&&u.onExit(c),Me=!0),O(c,new Zt(c))}var gr=c=>{if(je=c,M)throw Nr(c),"unwind";Pi(c)},be={ab:[],Ya:[],mb:[],Qa:{},gb:function(){M?be.vb():be.ub()},ub:function(){dt.unshift(()=>{Yt(),be.Bb(()=>wt())})},vb:function(){be.receiveObjectTransfer=be.Db,be.threadInitTLS=be.lb,be.setExitStatus=be.kb,he=!1},kb:function(c){je=c},Sb:["$terminateWorker"],Hb:function(){for(var c of be.Ya)pr(c);for(c of be.ab)pr(c);be.ab=[],be.Ya=[],be.Qa=[]},Eb:function(c){var v=c.Xa;delete be.Qa[v],be.ab.push(c),be.Ya.splice(be.Ya.indexOf(c),1),c.Xa=0,Tr(v)},Db:function(){},lb:function(){be.mb.forEach(c=>c())},Cb:c=>new Promise(v=>{c.onmessage=K=>{K=K.data;var ee=K.cmd;if(K.targetThread&&K.targetThread!=rr()){var pe=be.Qa[K.Rb];pe?pe.postMessage(K,K.transferList):ae('Internal error! Worker sent a message "'+ee+'" to target pthread '+K.targetThread+", but that thread no longer exists!")}else ee==="checkMailbox"?Jt():ee==="spawnThread"?Wr(K):ee==="cleanupThread"?hr(K.thread):ee==="killThread"?(K=K.thread,ee=be.Qa[K],delete be.Qa[K],pr(ee),Tr(K),be.Ya.splice(be.Ya.indexOf(ee),1),ee.Xa=0):ee==="cancelThread"?be.Qa[K.thread].postMessage({cmd:"cancel"}):ee==="loaded"?(c.loaded=!0,v(c)):ee==="alert"?alert("Thread "+K.threadId+": "+K.text):K.target==="setimmediate"?c.postMessage(K):ee==="callHandler"?u[K.handler](...K.args):ee&&ae("worker sent an unknown command "+ee)},c.onerror=K=>{throw ae("worker sent an error! "+K.filename+":"+K.lineno+": "+K.message),K},D&&(c.on("message",function(K){c.onmessage({data:K})}),c.on("error",function(K){c.onerror(K)}));var I=[],B=["onExit","onAbort","print","printErr"],H;for(H of B)u.hasOwnProperty(H)&&I.push(H);c.postMessage({cmd:"load",handlers:I,urlOrBlob:u.mainScriptUrlOrBlob||e,wasmMemory:Pe,wasmModule:Be})}),Bb:function(c){c()},qb:function(){var c=G("ort-wasm-simd-threaded.worker.js");c=new Worker(c),be.ab.push(c)},tb:function(){return be.ab.length==0&&(be.qb(),be.Cb(be.ab[0])),be.ab.pop()}};u.PThread=be;var yr=c=>{for(;0<c.length;)c.shift()(u)};u.establishStackSpace=function(){var c=rr(),v=a()[c+52>>2>>>0];c=a()[c+56>>2>>>0],mi(v,v-c),ir(v)};function Nr(c){if(M)return We(2,0,c);gr(c)}u.invokeEntryPoint=function(c,v){c=gi.apply(null,[c,v]),Et()?be.kb(c):Or(c)};function br(c){this.fb=c-24,this.pb=function(v){f()[this.fb+4>>2>>>0]=v},this.ob=function(v){f()[this.fb+8>>2>>>0]=v},this.gb=function(v,I){this.nb(),this.pb(v),this.ob(I)},this.nb=function(){f()[this.fb+16>>2>>>0]=0}}var Bi=0,Ot=0;function gt(c,v,I,B){return M?We(3,1,c,v,I,B):Ur(c,v,I,B)}function Ur(c,v,I,B){if(c>>>=0,v>>>=0,I>>>=0,B>>>=0,typeof SharedArrayBuffer>"u")return ae("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var H=[];return M&&H.length===0?gt(c,v,I,B):(c={Gb:I,Xa:c,rb:B,Mb:H},M?(c.Ob="spawnThread",postMessage(c,H),0):Wr(c))}function Qt(c,v,I){return M?We(4,1,c,v,I):0}function Hr(c,v){if(M)return We(5,1,c,v)}var vr=c=>{for(var v=0,I=0;I<c.length;++I){var B=c.charCodeAt(I);127>=B?v++:2047>=B?v+=2:55296<=B&&57343>=B?(v+=4,++I):v+=3}return v},Mi=(c,v,I,B)=>{if(I>>>=0,!(0<B))return 0;var H=I;B=I+B-1;for(var K=0;K<c.length;++K){var ee=c.charCodeAt(K);if(55296<=ee&&57343>=ee){var pe=c.charCodeAt(++K);ee=65536+((ee&1023)<<10)|pe&1023}if(127>=ee){if(I>=B)break;v[I++>>>0]=ee}else{if(2047>=ee){if(I+1>=B)break;v[I++>>>0]=192|ee>>6}else{if(65535>=ee){if(I+2>=B)break;v[I++>>>0]=224|ee>>12}else{if(I+3>=B)break;v[I++>>>0]=240|ee>>18,v[I++>>>0]=128|ee>>12&63}v[I++>>>0]=128|ee>>6&63}v[I++>>>0]=128|ee&63}}return v[I>>>0]=0,I-H},wr=(c,v,I)=>Mi(c,s(),v,I);function ji(c,v){if(M)return We(6,1,c,v)}function Di(c,v,I){if(M)return We(7,1,c,v,I)}function zi(c,v,I){return M?We(8,1,c,v,I):0}function Wi(c,v){if(M)return We(9,1,c,v)}function Vi(c,v,I){if(M)return We(10,1,c,v,I)}function Ni(c,v,I,B){if(M)return We(11,1,c,v,I,B)}function $r(c,v,I,B){if(M)return We(12,1,c,v,I,B)}function Lr(c,v,I,B){if(M)return We(13,1,c,v,I,B)}function V(c){if(M)return We(14,1,c)}function Vt(c,v){if(M)return We(15,1,c,v)}function N(c,v,I){if(M)return We(16,1,c,v,I)}var U=c=>{if(!Me)try{if(c(),!Et())try{M?Or(je):gr(je)}catch(v){v instanceof Zt||v=="unwind"||O(1,v)}}catch(v){v instanceof Zt||v=="unwind"||O(1,v)}};function Cr(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(a(),c>>2,c).value.then(Jt),c+=128,Atomics.store(a(),c>>2,1))}u.__emscripten_thread_mailbox_await=Cr;function Jt(){var c=rr();c&&(Cr(c),U(()=>pi()))}u.checkMailbox=Jt;var Nt=c=>c%4===0&&(c%100!==0||c%400===0),Gr=[0,31,60,91,121,152,182,213,244,274,305,335],Fr=[0,31,59,90,120,151,181,212,243,273,304,334];function qr(c,v,I,B,H,K,ee,pe){return M?We(17,1,c,v,I,B,H,K,ee,pe):-52}function Kr(c,v,I,B,H,K,ee){if(M)return We(18,1,c,v,I,B,H,K,ee)}var Yr=c=>{var v=vr(c)+1,I=Er(v);return I&&wr(c,I,v),I},_r=[],Xr=(c,v)=>{_r.length=0;var I;for(v>>=2;I=s()[c++>>>0];)v+=I!=105&v,_r.push(I==105?a()[v>>>0]:g()[v++>>>1]),++v;return _r},Ui=c=>{var v=kr();return c=c(),ir(v),c};function We(c,v){var I=arguments.length-2,B=arguments;return Ui(()=>{for(var H=Rr(8*I),K=H>>3,ee=0;ee<I;ee++){var pe=B[2+ee];g()[K+ee>>>0]=pe}return fi(c,I,H,v)})}var Sr=[],xr={},Zr=()=>{if(!Ir){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:x||"./this.program"},v;for(v in xr)xr[v]===void 0?delete c[v]:c[v]=xr[v];var I=[];for(v in c)I.push(`${v}=${c[v]}`);Ir=I}return Ir},Ir;function Qr(c,v){if(M)return We(19,1,c,v);c>>>=0,v>>>=0;var I=0;return Zr().forEach(function(B,H){var K=v+I;for(H=f()[c+4*H>>2>>>0]=K,K=0;K<B.length;++K)t()[H++>>0>>>0]=B.charCodeAt(K);t()[H>>0>>>0]=0,I+=B.length+1}),0}function Jr(c,v){if(M)return We(20,1,c,v);c>>>=0,v>>>=0;var I=Zr();f()[c>>2>>>0]=I.length;var B=0;return I.forEach(function(H){B+=H.length+1}),f()[v>>2>>>0]=B,0}function ei(c){return M?We(21,1,c):52}function ti(c,v,I,B){return M?We(22,1,c,v,I,B):52}function ri(c,v,I,B,H){return M?We(23,1,c,v,I,B,H):70}var Hi=[null,[],[]];function ii(c,v,I,B){if(M)return We(24,1,c,v,I,B);v>>>=0,I>>>=0,B>>>=0;for(var H=0,K=0;K<I;K++){var ee=f()[v>>2>>>0],pe=f()[v+4>>2>>>0];v+=8;for(var de=0;de<pe;de++){var ce=s()[ee+de>>>0],ge=Hi[c];ce===0||ce===10?((c===1?F:ae)(Vr(ge,0)),ge.length=0):ge.push(ce)}H+=pe}return f()[B>>2>>>0]=H,0}var ni=[31,29,31,30,31,30,31,31,30,31,30,31],ai=[31,28,31,30,31,30,31,31,30,31,30,31];function Li(c){var v=Array(vr(c)+1);return Mi(c,v,0,v.length),v}var Gi=(c,v)=>{t().set(c,v>>>0)};function oi(c,v,I,B){function H(q,ye,Ee){for(q=typeof q=="number"?q.toString():q||"";q.length<ye;)q=Ee[0]+q;return q}function K(q,ye){return H(q,ye,"0")}function ee(q,ye){function Ee(Ci){return 0>Ci?-1:0<Ci?1:0}var kt;return(kt=Ee(q.getFullYear()-ye.getFullYear()))===0&&(kt=Ee(q.getMonth()-ye.getMonth()))===0&&(kt=Ee(q.getDate()-ye.getDate())),kt}function pe(q){switch(q.getDay()){case 0:return new Date(q.getFullYear()-1,11,29);case 1:return q;case 2:return new Date(q.getFullYear(),0,3);case 3:return new Date(q.getFullYear(),0,2);case 4:return new Date(q.getFullYear(),0,1);case 5:return new Date(q.getFullYear()-1,11,31);case 6:return new Date(q.getFullYear()-1,11,30)}}function de(q){var ye=q.Za;for(q=new Date(new Date(q.$a+1900,0,1).getTime());0<ye;){var Ee=q.getMonth(),kt=(Nt(q.getFullYear())?ni:ai)[Ee];if(ye>kt-q.getDate())ye-=kt-q.getDate()+1,q.setDate(1),11>Ee?q.setMonth(Ee+1):(q.setMonth(0),q.setFullYear(q.getFullYear()+1));else{q.setDate(q.getDate()+ye);break}}return Ee=new Date(q.getFullYear()+1,0,4),ye=pe(new Date(q.getFullYear(),0,4)),Ee=pe(Ee),0>=ee(ye,q)?0>=ee(Ee,q)?q.getFullYear()+1:q.getFullYear():q.getFullYear()-1}c>>>=0,v>>>=0,I>>>=0,B>>>=0;var ce=a()[B+40>>2>>>0];B={Kb:a()[B>>2>>>0],Jb:a()[B+4>>2>>>0],cb:a()[B+8>>2>>>0],ib:a()[B+12>>2>>>0],eb:a()[B+16>>2>>>0],$a:a()[B+20>>2>>>0],Wa:a()[B+24>>2>>>0],Za:a()[B+28>>2>>>0],Tb:a()[B+32>>2>>>0],Ib:a()[B+36>>2>>>0],Lb:ce?et(ce):""},I=et(I),ce={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ge in ce)I=I.replace(new RegExp(ge,"g"),ce[ge]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Te="January February March April May June July August September October November December".split(" ");ce={"%a":q=>xe[q.Wa].substring(0,3),"%A":q=>xe[q.Wa],"%b":q=>Te[q.eb].substring(0,3),"%B":q=>Te[q.eb],"%C":q=>K((q.$a+1900)/100|0,2),"%d":q=>K(q.ib,2),"%e":q=>H(q.ib,2," "),"%g":q=>de(q).toString().substring(2),"%G":q=>de(q),"%H":q=>K(q.cb,2),"%I":q=>(q=q.cb,q==0?q=12:12<q&&(q-=12),K(q,2)),"%j":q=>{for(var ye=0,Ee=0;Ee<=q.eb-1;ye+=(Nt(q.$a+1900)?ni:ai)[Ee++]);return K(q.ib+ye,3)},"%m":q=>K(q.eb+1,2),"%M":q=>K(q.Jb,2),"%n":()=>`
`,"%p":q=>0<=q.cb&&12>q.cb?"AM":"PM","%S":q=>K(q.Kb,2),"%t":()=>"	","%u":q=>q.Wa||7,"%U":q=>K(Math.floor((q.Za+7-q.Wa)/7),2),"%V":q=>{var ye=Math.floor((q.Za+7-(q.Wa+6)%7)/7);if(2>=(q.Wa+371-q.Za-2)%7&&ye++,ye)ye==53&&(Ee=(q.Wa+371-q.Za)%7,Ee==4||Ee==3&&Nt(q.$a)||(ye=1));else{ye=52;var Ee=(q.Wa+7-q.Za-1)%7;(Ee==4||Ee==5&&Nt(q.$a%400-1))&&ye++}return K(ye,2)},"%w":q=>q.Wa,"%W":q=>K(Math.floor((q.Za+7-(q.Wa+6)%7)/7),2),"%y":q=>(q.$a+1900).toString().substring(2),"%Y":q=>q.$a+1900,"%z":q=>{q=q.Ib;var ye=0<=q;return q=Math.abs(q)/60,(ye?"+":"-")+("0000"+(q/60*100+q%60)).slice(-4)},"%Z":q=>q.Lb,"%%":()=>"%"},I=I.replace(/%%/g,"\0\0");for(ge in ce)I.includes(ge)&&(I=I.replace(new RegExp(ge,"g"),ce[ge](B)));return I=I.replace(/\0\0/g,"%"),ge=Li(I),ge.length>v?0:(Gi(ge,c),ge.length-1)}function er(c){try{c()}catch(v){$t(v)}}function Fi(c){var v={},I;for(I in c)(function(B){var H=c[B];v[B]=typeof H=="function"?function(){tr.push(B);try{return H.apply(null,arguments)}finally{Me||(tr.pop()===B||$t(),yt&&Ct===1&&tr.length===0&&(Ct=0,ut+=1,er(bi),typeof Fibers<"u"&&Fibers.Ub()))}}:H})(I);return v}var Ct=0,yt=null,si=0,tr=[],ui={},li={},qi=0,Ar=null,Ki=[];function Yi(){return new Promise((c,v)=>{Ar={resolve:c,reject:v}})}function Xi(){var c=Er(65548),v=c+12;f()[c>>2>>>0]=v,f()[c+4>>2>>>0]=v+65536,v=tr[0];var I=ui[v];return I===void 0&&(I=qi++,ui[v]=I,li[I]=v),v=I,a()[c+8>>2>>>0]=v,c}function Zi(){var c=a()[yt+8>>2>>>0];return c=ue[li[c]],--ut,c()}function Qi(c){if(!Me){if(Ct===0){var v=!1,I=!1;c((B=0)=>{if(!Me&&(si=B,v=!0,I)){Ct=2,er(()=>vi(yt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),B=!1;try{var H=Zi()}catch(pe){H=pe,B=!0}var K=!1;if(!yt){var ee=Ar;ee&&(Ar=null,(B?ee.reject:ee.resolve)(H),K=!0)}if(B&&!K)throw H}}),I=!0,v||(Ct=1,yt=Xi(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),er(()=>yi(yt)))}else Ct===2?(Ct=0,er(wi),di(yt),yt=null,Ki.forEach(B=>U(B))):$t(`invalid state: ${Ct}`);return si}}function Ji(c){return Qi(v=>{c().then(v)})}be.gb();var en=[null,Pi,Nr,gt,Qt,Hr,ji,Di,zi,Wi,Vi,Ni,$r,Lr,V,Vt,N,qr,Kr,Qr,Jr,ei,ti,ri,ii],tn={r:function(c,v,I){return Ji(async()=>{await u.xb(c,v,I)})},b:function(c,v,I){throw c>>>=0,new br(c).gb(v>>>0,I>>>0),Bi=c,Ot++,Bi},O:function(c){ci(c>>>0,!P,1,!k,131072,!1),be.lb()},l:function(c){c>>>=0,M?postMessage({cmd:"cleanupThread",thread:c}):hr(c)},I:Ur,i:Qt,U:Hr,E:ji,G:Di,V:zi,S:Wi,K:Vi,R:Ni,p:$r,F:Lr,C:V,T:Vt,D:N,q:()=>!0,A:function(c,v){c>>>=0,c==v>>>0?setTimeout(()=>Jt()):M?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=be.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Cr,X:function(c){D&&be.Qa[c>>>0].ref()},u:function(c,v,I){c=v+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*v:NaN,I>>>=0,c=new Date(1e3*c),a()[I>>2>>>0]=c.getUTCSeconds(),a()[I+4>>2>>>0]=c.getUTCMinutes(),a()[I+8>>2>>>0]=c.getUTCHours(),a()[I+12>>2>>>0]=c.getUTCDate(),a()[I+16>>2>>>0]=c.getUTCMonth(),a()[I+20>>2>>>0]=c.getUTCFullYear()-1900,a()[I+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[I+28>>2>>>0]=c},v:function(c,v,I){c=v+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*v:NaN,I>>>=0,c=new Date(1e3*c),a()[I>>2>>>0]=c.getSeconds(),a()[I+4>>2>>>0]=c.getMinutes(),a()[I+8>>2>>>0]=c.getHours(),a()[I+12>>2>>>0]=c.getDate(),a()[I+16>>2>>>0]=c.getMonth(),a()[I+20>>2>>>0]=c.getFullYear()-1900,a()[I+24>>2>>>0]=c.getDay(),v=(Nt(c.getFullYear())?Gr:Fr)[c.getMonth()]+c.getDate()-1|0,a()[I+28>>2>>>0]=v,a()[I+36>>2>>>0]=-(60*c.getTimezoneOffset()),v=new Date(c.getFullYear(),6,1).getTimezoneOffset();var B=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(v!=B&&c.getTimezoneOffset()==Math.min(B,v))|0,a()[I+32>>2>>>0]=c},w:function(c){c>>>=0;var v=new Date(a()[c+20>>2>>>0]+1900,a()[c+16>>2>>>0],a()[c+12>>2>>>0],a()[c+8>>2>>>0],a()[c+4>>2>>>0],a()[c>>2>>>0],0),I=a()[c+32>>2>>>0],B=v.getTimezoneOffset(),H=new Date(v.getFullYear(),6,1).getTimezoneOffset(),K=new Date(v.getFullYear(),0,1).getTimezoneOffset(),ee=Math.min(K,H);return 0>I?a()[c+32>>2>>>0]=+(H!=K&&ee==B):0<I!=(ee==B)&&(H=Math.max(K,H),v.setTime(v.getTime()+6e4*((0<I?ee:H)-B))),a()[c+24>>2>>>0]=v.getDay(),I=(Nt(v.getFullYear())?Gr:Fr)[v.getMonth()]+v.getDate()-1|0,a()[c+28>>2>>>0]=I,a()[c>>2>>>0]=v.getSeconds(),a()[c+4>>2>>>0]=v.getMinutes(),a()[c+8>>2>>>0]=v.getHours(),a()[c+12>>2>>>0]=v.getDate(),a()[c+16>>2>>>0]=v.getMonth(),a()[c+20>>2>>>0]=v.getYear(),c=v.getTime()/1e3,hi((mt=c,1<=+Math.abs(mt)?0<mt?+Math.floor(mt/4294967296)>>>0:~~+Math.ceil((mt-+(~~mt>>>0))/4294967296)>>>0:0)),c>>>0},s:qr,t:Kr,z:function(c,v,I){function B(ce){return(ce=ce.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ce[1]:"GMT"}c>>>=0,v>>>=0,I>>>=0;var H=new Date().getFullYear(),K=new Date(H,0,1),ee=new Date(H,6,1);H=K.getTimezoneOffset();var pe=ee.getTimezoneOffset(),de=Math.max(H,pe);f()[c>>2>>>0]=60*de,a()[v>>2>>>0]=+(H!=pe),c=B(K),v=B(ee),c=Yr(c),v=Yr(v),pe<H?(f()[I>>2>>>0]=c,f()[I+4>>2>>>0]=v):(f()[I>>2>>>0]=v,f()[I+4>>2>>>0]=c)},d:()=>{$t("")},c:function(c,v,I){return c>>>=0,v=Xr(v>>>0,I>>>0),fr[c].apply(null,v)},k:function(c,v,I){return c>>>=0,v=Xr(v>>>0,I>>>0),fr[c].apply(null,v)},m:function(){},j:function(){return Date.now()},W:()=>{throw ut+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return D?(Js(),sr(Qs)).cpus().length:navigator.hardwareConcurrency},L:function(c,v,I,B){for(be.Pb=v>>>0,Sr.length=I,v=B>>>0>>3,B=0;B<I;B++)Sr[B]=g()[v+B>>>0];return(0>c?fr[-c-1]:en[c]).apply(null,Sr)},y:function(c){c>>>=0;var v=s().length;if(c<=v||4294901760<c)return!1;for(var I=1;4>=I;I*=2){var B=v*(1+.2/I);B=Math.min(B,c+100663296);var H=Math;B=Math.max(c,B);e:{H=H.min.call(H,4294901760,B+(65536-B%65536)%65536)-Pe.buffer.byteLength+65535>>>16;try{Pe.grow(H),Ie();var K=1;break e}catch{}K=void 0}if(K)return!0}return!1},P:Qr,Q:Jr,H:gr,h:ei,o:ti,x:ri,n:ii,a:Pe||u.wasmMemory,J:oi,e:function(c,v,I,B){return oi(c>>>0,v>>>0,I>>>0,B>>>0)}};(function(){function c(I,B){return I=I.exports,I=Fi(I),ue=I=rn(I),be.mb.push(ue.Da),qe.unshift(ue.Y),Be=B,wt(),I}var v={a:tn};if(Yt(),u.instantiateWasm)try{return u.instantiateWasm(v,c)}catch(I){ae("Module.instantiateWasm callback failed with error: "+I),C(I)}return zr(v,function(I){c(I.instance,I.module)}).catch(C),{}})(),u._OrtInit=(c,v)=>(u._OrtInit=ue.Z)(c,v),u._OrtGetLastError=(c,v)=>(u._OrtGetLastError=ue._)(c,v),u._OrtCreateSessionOptions=(c,v,I,B,H,K,ee,pe,de,ce)=>(u._OrtCreateSessionOptions=ue.$)(c,v,I,B,H,K,ee,pe,de,ce),u._OrtAppendExecutionProvider=(c,v)=>(u._OrtAppendExecutionProvider=ue.aa)(c,v),u._OrtAddFreeDimensionOverride=(c,v,I)=>(u._OrtAddFreeDimensionOverride=ue.ba)(c,v,I),u._OrtAddSessionConfigEntry=(c,v,I)=>(u._OrtAddSessionConfigEntry=ue.ca)(c,v,I),u._OrtReleaseSessionOptions=c=>(u._OrtReleaseSessionOptions=ue.da)(c),u._OrtCreateSession=(c,v,I)=>(u._OrtCreateSession=ue.ea)(c,v,I),u._OrtReleaseSession=c=>(u._OrtReleaseSession=ue.fa)(c),u._OrtGetInputOutputCount=(c,v,I)=>(u._OrtGetInputOutputCount=ue.ga)(c,v,I),u._OrtGetInputName=(c,v)=>(u._OrtGetInputName=ue.ha)(c,v),u._OrtGetOutputName=(c,v)=>(u._OrtGetOutputName=ue.ia)(c,v),u._OrtFree=c=>(u._OrtFree=ue.ja)(c),u._OrtCreateTensor=(c,v,I,B,H,K)=>(u._OrtCreateTensor=ue.ka)(c,v,I,B,H,K),u._OrtGetTensorData=(c,v,I,B,H)=>(u._OrtGetTensorData=ue.la)(c,v,I,B,H),u._OrtReleaseTensor=c=>(u._OrtReleaseTensor=ue.ma)(c),u._OrtCreateRunOptions=(c,v,I,B)=>(u._OrtCreateRunOptions=ue.na)(c,v,I,B),u._OrtAddRunConfigEntry=(c,v,I)=>(u._OrtAddRunConfigEntry=ue.oa)(c,v,I),u._OrtReleaseRunOptions=c=>(u._OrtReleaseRunOptions=ue.pa)(c),u._OrtCreateBinding=c=>(u._OrtCreateBinding=ue.qa)(c),u._OrtBindInput=(c,v,I)=>(u._OrtBindInput=ue.ra)(c,v,I),u._OrtBindOutput=(c,v,I,B)=>(u._OrtBindOutput=ue.sa)(c,v,I,B),u._OrtClearBoundOutputs=c=>(u._OrtClearBoundOutputs=ue.ta)(c),u._OrtReleaseBinding=c=>(u._OrtReleaseBinding=ue.ua)(c),u._OrtRunWithBinding=(c,v,I,B,H)=>(u._OrtRunWithBinding=ue.va)(c,v,I,B,H),u._OrtRun=(c,v,I,B,H,K,ee,pe)=>(u._OrtRun=ue.wa)(c,v,I,B,H,K,ee,pe),u._OrtEndProfiling=c=>(u._OrtEndProfiling=ue.xa)(c),u._JsepOutput=(c,v,I)=>(u._JsepOutput=ue.ya)(c,v,I),u._JsepGetNodeName=c=>(u._JsepGetNodeName=ue.za)(c);var rr=u._pthread_self=()=>(rr=u._pthread_self=ue.Aa)(),Er=u._malloc=c=>(Er=u._malloc=ue.Ba)(c),di=u._free=c=>(di=u._free=ue.Ca)(c);u.__emscripten_tls_init=()=>(u.__emscripten_tls_init=ue.Da)();var ci=u.__emscripten_thread_init=(c,v,I,B,H,K)=>(ci=u.__emscripten_thread_init=ue.Fa)(c,v,I,B,H,K);u.__emscripten_thread_crashed=()=>(u.__emscripten_thread_crashed=ue.Ga)();var fi=(c,v,I,B)=>(fi=ue.Ha)(c,v,I,B),Tr=c=>(Tr=ue.Ia)(c),Or=u.__emscripten_thread_exit=c=>(Or=u.__emscripten_thread_exit=ue.Ja)(c),pi=u.__emscripten_check_mailbox=()=>(pi=u.__emscripten_check_mailbox=ue.Ka)(),hi=c=>(hi=ue.La)(c),mi=(c,v)=>(mi=ue.Ma)(c,v),kr=()=>(kr=ue.Na)(),ir=c=>(ir=ue.Oa)(c),Rr=c=>(Rr=ue.Pa)(c),gi=u.dynCall_ii=(c,v)=>(gi=u.dynCall_ii=ue.Ra)(c,v),yi=c=>(yi=ue.Sa)(c),bi=()=>(bi=ue.Ta)(),vi=c=>(vi=ue.Ua)(c),wi=()=>(wi=ue.Va)();u.___start_em_js=925254,u.___stop_em_js=925415;function rn(c){c=Object.assign({},c);var v=B=>()=>B()>>>0,I=B=>H=>B(H)>>>0;return c.__errno_location=v(c.__errno_location),c.pthread_self=v(c.pthread_self),c.malloc=I(c.malloc),c.stackSave=v(c.stackSave),c.stackAlloc=I(c.stackAlloc),c}u.keepRuntimeAlive=Et,u.wasmMemory=Pe,u.stackAlloc=Rr,u.stackSave=kr,u.stackRestore=ir,u.UTF8ToString=et,u.stringToUTF8=wr,u.lengthBytesUTF8=vr,u.ExitStatus=Zt,u.PThread=be;var nr;Tt=function c(){nr||$i(),nr||(Tt=c)};function $i(){function c(){if(!nr&&(nr=!0,u.calledRun=!0,!Me)&&(M||yr(qe),w(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!M)){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;){var v=u.postRun.shift();Je.unshift(v)}yr(Je)}}if(!(0<ht))if(M)w(u),M||yr(qe),startWorker(u);else{if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)dt.unshift(u.preRun.shift());yr(dt),0<ht||(u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),c()},1)):c())}}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return $i(),r.ready}})();typeof tu=="object"&&typeof Zn=="object"?Zn.exports=eu:typeof define=="function"&&define.amd&&define([],()=>eu)});var iu=Pr((X0,hm)=>{hm.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var au,mm,Qn,Jn,pn,nu,gm,ym,bm,ou,Ke,Mr=oe(()=>{"use strict";au=Ys();mm=ru(),Jn=!1,pn=!1,nu=!1,gm=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},ym=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},bm=(e,r)=>e?r?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":r?"ort-wasm-threaded.wasm":"ort-wasm.wasm",ou=async e=>{if(Jn)return Promise.resolve();if(pn)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(nu)throw new Error("previous call to 'initializeWebAssembly()' failed.");pn=!0;let r=e.initTimeout,t=e.numThreads,s=e.simd,a=t>1&&gm(),f=s&&ym(),p=e.wasmPaths,g=typeof p=="string"?p:void 0,u=bm(f,a),w=typeof p=="object"?p[u]:void 0,C=!1,T=[];if(r>0&&T.push(new Promise(x=>{setTimeout(()=>{C=!0,x()},r)})),T.push(new Promise((x,O)=>{let k=a?mm:au,P={locateFile:(D,M)=>{if(a&&D.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([iu()],{type:"text/javascript"}));if(D.endsWith(".wasm")){if(w)return w;let z=g??M;return u==="ort-wasm-simd.wasm"?z+"ort-wasm-simd.jsep.wasm":u==="ort-wasm-simd-threaded.wasm"?z+"ort-wasm-simd-threaded.jsep.wasm":z+u}return M+D}};if(a)if(typeof Blob>"u")P.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let D=`var ortWasmThreaded=${k.toString()};`;P.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}k(P).then(D=>{pn=!1,Jn=!0,Qn=D,x()},D=>{pn=!1,nu=!0,O(D)})})),await Promise.race(T),C)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},Ke=()=>{if(Jn&&Qn)return Qn;throw new Error("WebAssembly is not initialized yet.")}});var Xe,Si,Ne,hn=oe(()=>{"use strict";Mr();Xe=(e,r)=>{let t=Ke(),s=t.lengthBytesUTF8(e)+1,a=t._malloc(s);return t.stringToUTF8(e,a,s),r.push(a),a},Si=(e,r,t,s)=>{if(typeof e=="object"&&e!==null){if(t.has(e))throw new Error("Circular reference in options");t.add(e)}Object.entries(e).forEach(([a,f])=>{let p=r?r+a:a;if(typeof f=="object")Si(f,p+".",t,s);else if(typeof f=="string"||typeof f=="number")s(p,f.toString());else if(typeof f=="boolean")s(p,f?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof f}`)})},Ne=e=>{let r=Ke(),t=r.stackSave();try{let s=r.stackAlloc(8);r._OrtGetLastError(s,s+4);let a=r.HEAP32[s/4],f=r.HEAPU32[s/4+1],p=f?r.UTF8ToString(f):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${p}`)}finally{r.stackRestore(t)}}});var su,uu=oe(()=>{"use strict";Mr();hn();su=e=>{let r=Ke(),t=0,s=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let f=0;return e?.tag!==void 0&&(f=Xe(e.tag,s)),t=r._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,f),t===0&&Ne("Can't create run options."),e?.extra!==void 0&&Si(e.extra,"",new WeakSet,(p,g)=>{let u=Xe(p,s),w=Xe(g,s);r._OrtAddRunConfigEntry(t,u,w)!==0&&Ne(`Can't set a run config entry: ${p} - ${g}.`)}),[t,s]}catch(f){throw t!==0&&r._OrtReleaseRunOptions(t),s.forEach(p=>r._free(p)),f}}});var vm,wm,$m,Cm,lu,du=oe(()=>{"use strict";Mr();hn();vm=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},wm=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},$m=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(e.enableMemPattern=!1)},Cm=(e,r,t)=>{for(let s of r){let a=typeof s=="string"?s:s.name;switch(a){case"xnnpack":a="XNNPACK";break;case"webnn":if(a="WEBNN",typeof s!="string"){let p=s;if(p?.deviceType){let g=Xe("deviceType",t),u=Xe(p.deviceType,t);Ke()._OrtAddSessionConfigEntry(e,g,u)!==0&&Ne(`Can't set a session config entry: 'deviceType' - ${p.deviceType}.`)}if(p?.numThreads){let g=p.numThreads;(typeof g!="number"||!Number.isInteger(g)||g<0)&&(g=0);let u=Xe("numThreads",t),w=Xe(g.toString(),t);Ke()._OrtAddSessionConfigEntry(e,u,w)!==0&&Ne(`Can't set a session config entry: 'numThreads' - ${p.numThreads}.`)}if(p?.powerPreference){let g=Xe("powerPreference",t),u=Xe(p.powerPreference,t);Ke()._OrtAddSessionConfigEntry(e,g,u)!==0&&Ne(`Can't set a session config entry: 'powerPreference' - ${p.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof s!="string"){let p=s;if(p?.preferredLayout){if(p.preferredLayout!=="NCHW"&&p.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${p.preferredLayout}`);let g=Xe("preferredLayout",t),u=Xe(p.preferredLayout,t);Ke()._OrtAddSessionConfigEntry(e,g,u)!==0&&Ne(`Can't set a session config entry: 'preferredLayout' - ${p.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let f=Xe(a,t);Ke()._OrtAppendExecutionProvider(e,f)!==0&&Ne(`Can't append execution provider: ${a}.`)}},lu=e=>{let r=Ke(),t=0,s=[],a=e||{};$m(a);try{let f=vm(a.graphOptimizationLevel??"all"),p=wm(a.executionMode??"sequential"),g=typeof a.logId=="string"?Xe(a.logId,s):0,u=a.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let w=a.logVerbosityLevel??0;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log verbosity level is not valid: ${w}`);let C=typeof a.optimizedModelFilePath=="string"?Xe(a.optimizedModelFilePath,s):0;if(t=r._OrtCreateSessionOptions(f,!!a.enableCpuMemArena,!!a.enableMemPattern,p,!!a.enableProfiling,0,g,u,w,C),t===0&&Ne("Can't create session options."),a.executionProviders&&Cm(t,a.executionProviders,s),a.freeDimensionOverrides)for(let[T,x]of Object.entries(a.freeDimensionOverrides)){if(typeof T!="string")throw new Error(`free dimension override name must be a string: ${T}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let O=Xe(T,s);r._OrtAddFreeDimensionOverride(t,O,x)!==0&&Ne(`Can't set a free dimension override: ${T} - ${x}.`)}return a.extra!==void 0&&Si(a.extra,"",new WeakSet,(T,x)=>{let O=Xe(T,s),k=Xe(x,s);r._OrtAddSessionConfigEntry(t,O,k)!==0&&Ne(`Can't set a session config entry: ${T} - ${x}.`)}),[t,s]}catch(f){throw t!==0&&r._OrtReleaseSessionOptions(t),s.forEach(p=>r._free(p)),f}}});var ea,xi,Ii,mn,Ai,gn,ta,Ze=oe(()=>{"use strict";ea=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},xi=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Ii=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],mn=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ai=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},gn=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",ta=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var _m,Sm,cu,fu,pu,xm,Ge,Gt=oe(()=>{"use strict";Ze();_m=["V","I","W","E","F"],Sm=(e,r)=>{console.log(`[${_m[e]},${new Date().toISOString()}]${r}`)},pu=(e,r)=>{cu=e,fu=r},xm=(e,r)=>{let t=Ai(e),s=Ai(cu);t>=s&&Sm(t,typeof r=="function"?r():r)},Ge=(...e)=>{fu&&xm(...e)}});var hu,mu=oe(()=>{"use strict";Ze();hu=(e,r)=>new(mn(r))(e)});var yn=oe(()=>{"use strict"});var bn,Im,gu,ia,ra,bu,vu=oe(()=>{"use strict";Gt();yn();bn=e=>Math.ceil(e/16)*16,Im=1,gu=()=>Im++,ia=async(e,r,t,s)=>{let a=bn(t),f=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let p=e.getCommandEncoder();e.endComputePass(),p.copyBufferToBuffer(r,0,f,0,a),e.flush(),await f.mapAsync(GPUMapMode.READ);let g=f.getMappedRange();if(s){let u=s();return u.set(new Uint8Array(g,0,t)),u}else return new Uint8Array(g.slice(0,t))}finally{f.destroy()}},ra=class{constructor(r){this.backend=r;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(r,t){let s=t.buffer,a=t.byteOffset,f=t.byteLength,p=bn(f),g=this.storageCache.get(r);if(!g)throw new Error("gpu data for uploading does not exist");if(g.originalSize!==f)throw new Error(`inconsistent data size. gpu data size=${g.originalSize}, data size=${f}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:p,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),w=u.getMappedRange();new Uint8Array(w).set(new Uint8Array(s,a,f)),u.unmap();let C=this.backend.getCommandEncoder();this.backend.endComputePass(),C.copyBufferToBuffer(u,0,g.gpuData.buffer,0,p),Ge("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(u)}memcpy(r,t){let s=this.storageCache.get(r);if(!s)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(t);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let f=bn(s.originalSize),p=this.backend.getCommandEncoder();this.backend.endComputePass(),p.copyBufferToBuffer(s.gpuData.buffer,0,a.gpuData.buffer,0,f)}registerExternalBuffer(r,t,s){let a;if(s){if(a=this.externalBuffers.get(s),a===void 0)throw new Error("previous buffer is not registered");if(r===s)return Ge("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${a}, buffer is the same, skip.`),a;this.externalBuffers.delete(s)}else a=gu();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:r},originalSize:t}),this.externalBuffers.set(r,a),Ge("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${a}, registered.`),a}unregisterExternalBuffer(r){let t=this.externalBuffers.get(r);t!==void 0&&(this.storageCache.delete(t),this.externalBuffers.delete(r),Ge("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(r,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let s=bn(r),a,f=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,p=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(f||p){let u=f?this.freeBuffers:this.freeUniformBuffers,w=u.get(s);w||(w=[],u.set(s,w)),w.length>0?a=w.pop():a=this.backend.device.createBuffer({size:s,usage:t})}else a=this.backend.device.createBuffer({size:s,usage:t});let g={id:gu(),type:0,buffer:a};return this.storageCache.set(g.id,{gpuData:g,originalSize:r}),Ge("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${g.id}`),g}get(r){return this.storageCache.get(r)?.gpuData}release(r){let t=this.storageCache.get(r);if(!t)throw new Error("releasing data does not exist");return Ge("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(r,t){let s=this.storageCache.get(r);if(!s)throw new Error("data does not exist");await ia(this.backend,s.gpuData.buffer,s.originalSize,t)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();this.buffersForUploadingPending=[];for(let r of this.buffersPending)(r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(r.size).push(r):(r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(r.size).push(r):r.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(r=>{r.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(t=>{t.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},bu=(...e)=>new ra(...e)});var na,me,Fe=oe(()=>{"use strict";na=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this.key}},me=e=>new na(e)});var aa,Rt,X,lr,vn,wn,$n,ke=oe(()=>{"use strict";aa=class{static calcMatMulShape(r,t){return r[1]!==t[0]?void 0:[r[0],t[1]]}},Rt=class{static calcShape(r,t,s=!1){let a=r.length,f=t.length;if(a===0)return t;if(f===0)return r;let p=Math.max(r.length,t.length),g=new Array(p);if(s){if(a<2||f<2)return;let u=aa.calcMatMulShape([r[a-2],r[a-1]],[t[f-2],t[f-1]]);if(u===void 0)return;[g[p-2],g[p-1]]=u}for(let u=s?3:1;u<=p;u++){let w=a-u<0?1:r[a-u],C=f-u<0?1:t[f-u];if(w!==C&&w>1&&C>1)return;g[p-u]=Math.max(w,C)}return g}static isValidBroadcast(r,t){let s=r.length,a=t.length;if(s>a)return!1;for(let f=1;f<=s;f++)if(r[s-f]!==1&&r[s-f]!==t[a-f])return!1;return!0}},X=class e{static size(r){return e.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,t){if(t<0||t>r.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return e.getSizeFromDimensionRange(r,t,r.length)}static sizeToDimension(r,t){if(t<0||t>r.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${r.length} dimensions.`);return e.getSizeFromDimensionRange(r,0,t)}static getSizeFromDimensionRange(r,t,s){let a=1;for(let f=t;f<s;f++){if(r[f]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=r[f]}return a}static computeStrides(r){let t=r.length;if(t===0)return[];if(t===1)return[1];let s=new Array(t);s[t-1]=1,s[t-2]=r[t-1];for(let a=t-3;a>=0;--a)s[a]=s[a+1]*r[a+1];return s}static normalizeAxis(r,t){if(r<-t&&r>=t)throw new Error("unsupported axis for this operation.");return r<0?r+t:r}static normalizeAxes(r,t){return r.map(s=>this.normalizeAxis(s,t??r.length))}static sortBasedOnPerm(r,t){return t?t.map(s=>r[s]):r.slice().reverse()}static padShape(r,t){let s=r.length;return r.map((a,f)=>a+t[f]+t[f+s])}static areEqual(r,t){return r.length!==t.length?!1:r.every((s,a)=>s===t[a])}},lr=class e{static adjustPoolAttributes(r,t,s,a,f,p){if(!r&&s.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let g=0;g<t.length-2;g++)g>=s.length?s.push(t[g+2]):s[g]=t[g+2];for(let g=0;g<s.length;g++)if(g<a.length){if(a[g]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let g=0;g<s.length;g++)if(g<f.length){if(f[g]<0)throw new Error("dilations should be greater than or equal to 1")}else f.push(1);for(let g=0;g<s.length*2;g++)if(g<p.length){if(p[g]<0)throw new Error("pad should be greater than or equal to 1")}else p.push(0);for(let g=0;g<s.length;g++){if(s[g]<=0)throw new Error("kernel shapes need to be greater than 0");if(p[g]>=s[g]||p[g+s.length]>=s[g])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,t,s,a,f,p,g){if(g){if(f.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<r.length-2;u++)e.adjustPadAndReturnShape(r[u+(p?1:2)],t[u],s[u],a[u],f,u,u+r.length-2,g)}}static computePoolOutputShape(r,t,s,a,f,p,g){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let u=[t[0],t[1]];return e.computeShapeHelper(r,t,u,s,a,f,p,g),u}static computeConvOutputShape(r,t,s,a,f,p,g){if(r.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[r[0],t[0]];return e.computeShapeHelper(!1,r,u,s,a,f,p,g),u}static computeShapeHelper(r,t,s,a,f,p,g,u){if(r)for(let w=0;w<t.length-2;w++)s.push(1);else for(let w=0;w<t.length-2;w++)s.push(e.adjustPadAndReturnShape(t[w+2],a[w],f[w],p[w],g,w,w+t.length-2,u))}static adjustPadAndReturnShape(r,t,s,a,f,p,g,u){let w=s*(a-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return f[p]=0,f[g]=0,Math.floor((r-w)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let T=((r+t-1)/t-1)*t+a-r;return f[p]=Math.floor(u==="SAME_LOWER"?(T+1)/2:T/2),f[g]=T-f[p],Math.floor((r+T-a)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+f[p]+f[g]-w)/t+1)}},vn=class{static getShapeOfGemmResult(r,t,s,a,f){if(r.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let p,g,u;t?(p=r[1],g=r[0]):(p=r[0],g=r[1]);let w=-1;if(a?(u=s[0],w=1):(u=s[1],w=0),s[w]!==g)throw new Error("dimension mismatch");if(p<=0||u<=0||g<=0)throw new Error("invalid shape specified");if(f&&!Rt.isValidBroadcast(f,[p,u]))throw new Error("gemm: invalid bias shape for broadcast");return[p,u,g]}},wn=-34028234663852886e22,$n=34028234663852886e22});var Am,wu,De,Se,ft,st,_t,St,Pt,sa,te,se,$u,oa,Cu,ua,Le,Re=oe(()=>{"use strict";Ze();ke();Am=64,wu=(e,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},De=(e,r=1)=>{let t=wu(e,r);return typeof t=="string"?t:t[0]},Se=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:X.computeStrides(e)}],ft=e=>e%4===0?4:e%2===0?2:1,st=(e="f32",r,t="0")=>!r||r===1?`${e}(${t})`:`vec${r}<${e}>(${t})`,_t=(e,r,t)=>e==="f32"?t:r===1?`f32(${t})`:`vec${r}f(${t})`,St=(e,r)=>r===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:r===2?`(${e}.x + ${e}.y)`:r===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Pt=(e,r,t)=>e.startsWith("uniforms.")&&t>4?typeof r=="string"?`${e}[(${r}) / 4][(${r}) % 4]`:`${e}[${Math.floor(r/4)}][${r%4}]`:t>1?`${e}[${r}]`:e,sa=(e,r,t,s,a)=>{let f=typeof t=="number",p=f?t:t.length,g=[...new Array(p).keys()],u=p<2?"u32":p<=4?`vec${p}<u32>`:`array<u32, ${p}>`,w=wu(r,a),C=typeof w=="string"?w:w[1],T=typeof w=="string"?w:w[0],x={indices:u,value:C,storage:T,tensor:r},O=ie=>typeof ie=="string"?ie:`${ie}u`,k={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},P=f?"uniforms.":"",D=`${P}${e}_shape`,M=`${P}${e}_strides`,z="";for(let ie=0;ie<p-1;ie++)z+=`
    let dim${ie} = current / ${Pt(M,ie,p)};
    let rest${ie} = current % ${Pt(M,ie,p)};
    indices[${ie}] = dim${ie};
    current = rest${ie};
    `;z+=`indices[${p-1}] = current;`;let G=p<2?"":`
  fn o2i_${e}(offset: u32) -> ${x.indices} {
    var indices: ${x.indices};
    var current = offset;
    ${z}
    return indices;
  }`,L=ie=>(k.offsetToIndices=!0,p<2?ie:`o2i_${e}(${ie})`),Y=[];if(p>=2)for(let ie=p-1;ie>=0;ie--)Y.push(`${Pt(M,ie,p)} * (indices[${ie}])`);let A=p<2?"":`
  fn i2o_${e}(indices: ${x.indices}) -> u32 {
    return ${Y.join("+")};
  }`,Z=ie=>(k.indicesToOffset=!0,p<2?ie:`i2o_${e}(${ie})`),J=(...ie)=>p===0?"0u":`${x.indices}(${ie.map(O).join(",")})`,re=(ie,we)=>p<2?`${ie}`:`${Pt(ie,we,p)}`,fe=(ie,we,Ie)=>p<2?`${ie}=${Ie};`:`${Pt(ie,we,p)}=${Ie};`,F={},ae=(ie,we)=>{k.broadcastedIndicesToOffset=!0;let Ie=`${we.name}broadcastedIndicesTo${e}Offset`;if(Ie in F)return`${Ie}(${ie})`;let rt=[];for(let dt=p-1;dt>=0;dt--){let qe=we.indicesGet("outputIndices",dt+we.rank-p);rt.push(`${re(M,dt)} * (${qe} % ${re(D,dt)})`)}return F[Ie]=`fn ${Ie}(outputIndices: ${we.type.indices}) -> u32 {
             return ${rt.length>0?rt.join("+"):"0u"};
           }`,`${Ie}(${ie})`},_e=(ie,we)=>(()=>{if(x.storage===x.value)return`${e}[${ie}]=${we};`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`${e}[${ie}]=vec2<u32>(u32(${we}), select(0u, 0xFFFFFFFFu, ${we} < 0));`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`${e}[${ie}]=vec2<u32>(u32(${we}), 0u);`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`${e}[${ie}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${we}));`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),he=ie=>(()=>{if(x.storage===x.value)return`${e}[${ie}]`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`i32(${e}[${ie}].x)`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`u32(${e}[${ie}].x)`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${ie}] & 0xFFu), bool(${e}[${ie}] & 0xFF00u), bool(${e}[${ie}] & 0xFF0000u), bool(${e}[${ie}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),Pe=p<2?"":`
  fn get_${e}ByIndices(indices: ${x.indices}) -> ${C} {
    return ${he(`i2o_${e}(indices)`)};
  }`,ue=p<2?"":(()=>{let ie=g.map(Ie=>`d${Ie}: u32`).join(", "),we=g.map(Ie=>`d${Ie}`).join(", ");return`
  fn get_${e}(${ie}) -> ${C} {
    return get_${e}ByIndices(${J(we)});
  }`})(),Be=(...ie)=>{if(ie.length!==p)throw new Error(`indices length must be ${p}`);let we=ie.map(O).join(",");return p===0?he("0u"):p===1?he(we[0]):(k.get=!0,k.getByIndices=!0,k.indicesToOffset=!0,`get_${e}(${we})`)},Me=ie=>p<2?he(ie):(k.getByIndices=!0,k.indicesToOffset=!0,`get_${e}ByIndices(${ie})`),je=p<2?"":`
  fn set_${e}ByIndices(indices: ${x.indices}, value: ${C}) {
    ${_e(`i2o_${e}(indices)`,"value")}
  }`,Ae=p<2?"":(()=>{let ie=g.map(Ie=>`d${Ie}: u32`).join(", "),we=g.map(Ie=>`d${Ie}`).join(", ");return`
  fn set_${e}(${ie}, value: ${C}) {
    set_${e}ByIndices(${J(we)}, value);
  }`})();return{impl:()=>{let ie=[];return f||(ie.push(`const ${D} = ${x.indices}(${t.join(",")});`),ie.push(`const ${M} = ${x.indices}(${X.computeStrides(t).join(",")});`)),k.offsetToIndices&&ie.push(G),k.indicesToOffset&&ie.push(A),k.broadcastedIndicesToOffset&&Object.values(F).forEach(we=>ie.push(we)),k.set&&ie.push(Ae),k.setByIndices&&ie.push(je),k.get&&ie.push(ue),k.getByIndices&&ie.push(Pe),ie.join(`
`)},type:x,offsetToIndices:L,indicesToOffset:Z,broadcastedIndicesToOffset:ae,indices:J,indicesGet:re,indicesSet:fe,set:(...ie)=>{if(ie.length!==p+1)throw new Error(`indices length must be ${p}`);let we=ie[p];if(typeof we!="string")throw new Error("value must be string");let Ie=ie.slice(0,p).map(O).join(",");return p===0?_e("0u",we):p===1?_e(Ie[0],we):(k.set=!0,k.setByIndices=!0,k.indicesToOffset=!0,`set_${e}(${Ie}, ${we})`)},setByOffset:_e,setByIndices:(ie,we)=>p<2?_e(ie,we):(k.setByIndices=!0,k.indicesToOffset=!0,`set_${e}ByIndices(${ie}, ${we});`),get:Be,getByOffset:he,getByIndices:Me,usage:s,name:e,strides:M,shape:D,rank:p}},te=(e,r,t,s=1)=>sa(e,r,t,"input",s),se=(e,r,t,s=1)=>sa(e,r,t,"output",s),$u=(e,r,t,s=1)=>sa(e,r,t,"internal",s),oa=class{constructor(r){this.normalizedDispatchGroup=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=Am){let t=typeof r=="number"?r:r[0],s=typeof r=="number"?1:r[1],a=typeof r=="number"?1:r[2],f=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,p=f?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,g=f?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${t*s*a}u + local_index;`;return`@compute @workgroup_size(${t}, ${s}, ${a})
  fn main(${p}) {
    ${g}
  `}appendVariableUniforms(r){r.rank!==0&&(r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:"u32",length:r.rank}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:"u32",length:r.rank}))}declareVariable(r,t){if(r.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(r),this.appendVariableUniforms(r);let s=r.usage==="input"?"read":"read_write",a=r.type.storage;return`@group(0) @binding(${t}) var<storage, ${s}> ${r.name}: array<${a}>;`}declareVariables(...r){return r.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(r){if(r.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(r),this.appendVariableUniforms(r)}registerInternalVariables(...r){return r.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(r,t,s=1){return this.uniforms.push({name:r,type:t,length:s}),this}registerUniforms(r){return this.uniforms=this.uniforms.concat(r),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:t,type:s,length:a}of this.uniforms)if(a&&a>4)r.push(`${t}:array<vec4<${s}>, ${Math.ceil(a/4)}>`);else{let f=a==null||a===1?s:`vec${a}<${s}>`;r.push(`${t}:${f}`)}return`
      struct Uniforms { ${r.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(r=>r.impl()).join(`
`)+this.internalVariables.map(r=>r.impl()).join(`
`)}},Cu=e=>new oa(e),ua=(e,r)=>{let t=e.length,s=[];for(let a=0;a<t;a++){let f=t-1-a,p=e[f]||1;(r[r.length-1-a]||1)>1&&p===1&&s.unshift(f)}return s},Le=e=>!0});var Em,_u,Tm,Om,xt,Su,xu,jr=oe(()=>{"use strict";ke();Fe();Re();Em=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},_u=(e,r)=>r&&r.length!==e?[...new Array(e).keys()].reverse():r,Tm=(e,r)=>X.sortBasedOnPerm(e,_u(e.length,r)),Om=(e,r,t,s)=>{let a=[];a.push(`fn perm(i: ${s.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`);for(let f=0;f<r;++f)a.push(t.indicesSet("a",e[f],`i[${f}]`));return a.push("return a;}"),a.join(`
`)},xt=(e,r)=>{let t=e.dataType,s=e.dims.length,a=_u(s,r),f=Le(s),p=Tm(e.dims,a),g=f?p.length:p,u=f?s:e.dims,w=se("output",t,g),C=te("a",t,u),T=x=>`
  ${x.registerUniform("output_size","u32").declareVariables(C,w)}

  ${Om(a,s,C,w)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx",C.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:f?["rank"]:["dims"]},getRunData:x=>{let O=X.size(p);return{outputs:[{dims:p,dataType:x[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)},programUniforms:f?[{type:"uint32",data:O},...Se(x[0].dims),...Se(p)]:[{type:"uint32",data:O}]}},getShaderSource:T}},Su=(e,r)=>{Em(e.inputs),e.compute(xt(e.inputs[0],r.perm))},xu=e=>me({perm:e.perm})});var km,Rm,Pm,Bm,Mm,jm,Dm,zm,Wm,Vm,Bt,Iu,Au,Eu,Tu,Ou,ku,Ru,Pu,Bu,Mu,ju=oe(()=>{"use strict";ke();Re();Cn();jr();km={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Rm={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Pm={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Bm={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Mm=(e,r)=>{let t=[];for(let s=r-e;s<r;++s)t.push(s);return t},jm=(e,r)=>{let t=[],s=e.length;for(let f=0;f<s;f++)r.indexOf(f)===-1&&t.push(e[f]);let a=r.map(f=>e[f]);return[t,a]},Dm=(e,r)=>{let t=e.length+r.length,s=[],a=0;for(let f=0;f<t;f++)r.indexOf(f)===-1?s.push(e[a++]):s.push(1);return s},zm=(e,r)=>{for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==r-1-t)return!1;return!0},Wm=(e,r)=>{let t=[];if(!zm(e,r)){for(let s=0;s<r;++s)e.indexOf(s)===-1&&t.push(s);e.forEach(s=>t.push(s))}return t},Vm=(e,r,t,s,a,f,p)=>{let g=t[0].dims,u=X.size(f),w=X.size(p),C=te("_A",t[0].dataType,g),T=se("output",a,f),x=32,O=`
          var<workgroup> aBestValues : array<${T.type.storage}, ${x}>;
       `;return{name:e,shaderCache:r,getShaderSource:P=>`
        ${P.registerUniform("reduceSize","u32").declareVariables(C,T)}
        ${O}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${P.mainStart(x)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${x};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${T.type.storage}(${Pm[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${x}) {
           let candidate = ${T.type.storage}(${C.getByOffset("offset + k")});
           bestValue = ${km[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${x}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Rm[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${T.setByOffset("outputIndex",`${s==="mean"?`bestValue / ${T.type.storage}(uniforms.reduceSize)`:`${Bm[s]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:f,dataType:a}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:w}]})}},Bt=(e,r,t,s)=>{let a=e.inputs.length===1?t:la(e.inputs,t),f=a.axes;f.length===0&&!a.noopWithEmptyAxes&&(f=e.inputs[0].dims.map((O,k)=>k));let p=X.normalizeAxes(f,e.inputs[0].dims.length),g=p,u=e.inputs[0],w=Wm(g,e.inputs[0].dims.length);w.length>0&&(u=e.compute(xt(e.inputs[0],w),{inputs:[0],outputs:[-1]})[0],g=Mm(g.length,u.dims.length));let[C,T]=jm(u.dims,g),x=C;a.keepDims&&(x=Dm(C,p)),e.compute(Vm(r,{hint:a.cacheKey,inputDependencies:["type"]},[u],s,e.inputs[0].dataType,x,T),{inputs:[u]})},Iu=(e,r)=>{Bt(e,"ReduceMeanShared",r,"mean")},Au=(e,r)=>{Bt(e,"ReduceL1Shared",r,"l1")},Eu=(e,r)=>{Bt(e,"ReduceL2Shared",r,"l2")},Tu=(e,r)=>{Bt(e,"ReduceLogSumExpShared",r,"logSumExp")},Ou=(e,r)=>{Bt(e,"ReduceMaxShared",r,"max")},ku=(e,r)=>{Bt(e,"ReduceMinShared",r,"min")},Ru=(e,r)=>{Bt(e,"ReduceProdShared",r,"prod")},Pu=(e,r)=>{Bt(e,"ReduceSumShared",r,"sum")},Bu=(e,r)=>{Bt(e,"ReduceSumSquareShared",r,"sumSquare")},Mu=(e,r)=>{Bt(e,"ReduceLogSumShared",r,"logSum")}});var Mt,Nm,_n,la,jt,Um,Hm,Lm,Gm,Fm,qm,Km,Ym,Xm,Zm,Dt,Du,zu,Wu,Vu,Nu,Uu,Hu,Lu,Gu,Fu,It,Cn=oe(()=>{"use strict";ke();Fe();Re();ju();Mt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Nm=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],_n=(e,r,t,s,a,f,p=!1,g=!1)=>{let u=[],w=t[0].dims,C=X.normalizeAxes(a,t[0].dims.length),T=!g&&C.length===0;w.forEach((Z,J)=>{T||C.indexOf(J)>=0?p&&u.push(1):u.push(Z)});let x=[],O=te("_A",t[0].dataType,w),k=se("output",f,u),P=s(O,k,C),D=`inputOffset = ${O.indicesToOffset("inputIndices")};`,M=`let ${D};`,z=`var ${D};`,G=P[1]===""?"":z,L=(P[1]===""?M:D)+`
`+P[2];for(let Z=0,J=0;Z<t[0].dims.length;Z++)T||C.indexOf(Z)>=0?(p&&J++,L=`for(var j${Z}: u32 = 0; j${Z} < ${t[0].dims[Z]}; j${Z}++) {
                ${P[2].includes("lastIndex")?`let lastIndex = j${Z};`:""}
                ${O.indicesSet("inputIndices",Z,`j${Z}`)}
                ${L}
              }`):(x.push(`${O.indicesSet("inputIndices",Z,k.indicesGet("outputIndices",J))};`),J++);let Y=X.size(u);return{name:e,shaderCache:r,getShaderSource:Z=>`
        ${Z.declareVariables(O,k)}

        ${Z.mainStart()}
          ${Z.guardAgainstOutOfBoundsWorkgroupSizes(Y)}
          var inputIndices: ${O.type.indices};
          let outputIndices = ${k.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${P[0]}       // init ops for reduce max/min
          ${G}
          ${P[1]}
          ${L}
          ${P[3]}
          ${P.length===4?k.setByOffset("global_idx","value"):P.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:u,dataType:f}],dispatchGroup:{x:Math.ceil(Y/64)}})}},la=(e,r)=>{let t=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(s=>t.push(Number(s))),me({axes:t,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},jt=(e,r,t,s)=>{let a=e.inputs,f=a.length===1?t:la(a,t);e.compute(_n(r,{hint:f.cacheKey},[a[0]],f.noopWithEmptyAxes&&f.axes.length===0?Nm:s,f.axes,a[0].dataType,f.keepDims,f.noopWithEmptyAxes),{inputs:[0]})},Um=(e,r)=>{Mt(e.inputs),jt(e,"ReduceLogSum",r,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${s.getByOffset("inputOffset")};`,"value = log(value);"])},Hm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceL1",r,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${s.getByOffset("inputOffset")});`,""])},Lm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceL2",r,(s,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${s.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Gm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceLogSumExp",r,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${s.getByOffset("inputOffset")});`,"value = log(value);"])},Fm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceMax",r,(s,a,f)=>{let p=[];for(let g=0;g<s.rank;g++)(f.indexOf(g)>=0||f.length===0)&&p.push(s.indicesSet("inputIndices",g,0));return[`${p.join(`
`)}`,`var value = ${s.getByOffset("inputOffset")};`,`value = max(value, ${s.getByOffset("inputOffset")});`,""]})},qm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceMean",r,(s,a,f)=>{let p=1;for(let g=0;g<s.rank;g++)(f.indexOf(g)>=0||f.length===0)&&(p*=e.inputs[0].dims[g]);return["var sum = f32(0);","",`sum += f32(${s.getByOffset("inputOffset")});`,`let value = ${a.type.value}(sum / ${p});`]})},Km=(e,r)=>{Mt(e.inputs),jt(e,"ReduceMin",r,(s,a,f)=>{let p=[];for(let g=0;g<s.rank;g++)(f.indexOf(g)>=0||f.length===0)&&p.push(`inputIndices[${g}] = 0;`);return[`${p.join(`
`)}`,`var value = ${s.getByOffset("inputOffset")};`,`value = min(value, ${s.getByOffset("inputOffset")});`,""]})},Ym=(e,r)=>{Mt(e.inputs),jt(e,"ReduceProd",r,(s,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${s.getByOffset("inputOffset")};`,""])},Xm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceSum",r,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${s.getByOffset("inputOffset")};`,""])},Zm=(e,r)=>{Mt(e.inputs),jt(e,"ReduceSumSquare",r,(s,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${s.getByOffset("inputOffset")}; value += t * t;`,""])},Dt=(e,r,t)=>{if(r.length===0)return!!t;let s=1,a=1;for(let f=0;f<r.length;f++)r.indexOf(f)===-1?s*=e[f]:a*=e[f];return a<32&&s>1024},Du=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?qm(e,r):Iu(e,r)},zu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Hm(e,r):Au(e,r)},Wu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Lm(e,r):Eu(e,r)},Vu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Gm(e,r):Tu(e,r)},Nu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Fm(e,r):Ou(e,r)},Uu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Km(e,r):ku(e,r)},Hu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Ym(e,r):Ru(e,r)},Lu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Xm(e,r):Pu(e,r)},Gu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Zm(e,r):Bu(e,r)},Fu=(e,r)=>{Dt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Um(e,r):Mu(e,r)},It=e=>me(e)});var qu,Ku,Yu,da,Xu=oe(()=>{"use strict";Ze();Fe();Cn();qu=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ku=(e,r)=>{qu(e.inputs);let t=(s,a,f)=>{let p=[];for(let g=0;g<s.rank;g++)(f.indexOf(g)>=0||f.length===0)&&p.push(`inputIndices[${g}] = 0;`);return[`${p.join(`
`)}`,`var value = ${s.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${s.getByOffset("inputOffset")} ${r.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",a.setByOffset("global_idx","bestIndex")]};e.compute(_n("ArgMin",{hint:r.cacheKey},[e.inputs[0]],t,[r.axis],7,r.keepDims),{inputs:[0]})},Yu=(e,r)=>{qu(e.inputs);let t=(s,a,f)=>{let p=[];for(let g=0;g<s.rank;g++)(f.indexOf(g)>=0||f.length===0)&&p.push(`inputIndices[${g}] = 0;`);return[`${p.join(`
`)}`,`var value = ${s.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${s.getByOffset("inputOffset")} ${r.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",a.setByOffset("global_idx","bestIndex")]};e.compute(_n("argMax",{hint:r.cacheKey},[e.inputs[0]],t,[r.axis],7,r.keepDims),{inputs:[0]})},da=e=>me(e)});var Qm,Zu,Jm,eg,tg,Sn,rg,Qu,ca=oe(()=>{"use strict";Fe();yn();Re();Qm=(e,r)=>{let t=e[0],s=e[1],a=e[2],f=e[3],p=e[4],g=e[5];if(p&&g)throw new Error("Attention cannot have both past and relative_position_bias");if(t.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let u=t.dims[0],w=t.dims[1],C=t.dims[2];if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==C)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let T=a.dims[0]/3,x=T,O=x;if(r.qkvHiddenSizes.length>0){if(r.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let G of r.qkvHiddenSizes)if(G%r.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");T=r.qkvHiddenSizes[0],x=r.qkvHiddenSizes[1],O=r.qkvHiddenSizes[2]}let k=w;if(T!==x)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==T+x+O)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let P=0;if(p){if(x!==O)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(p.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(p.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(p.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(p.dims[2]!==r.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(p.dims[4]!==x/r.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');r.pastPresentShareBuffer||(P=p.dims[3])}let D=k+P,M=-1,z=0;if(f)throw new Error("Mask not supported");if(p)throw new Error("past is not supported");if(g)throw new Error("relativePositionBias is not supported");return{batchSize:u,sequenceLength:w,pastSequenceLength:P,kvSequenceLength:k,totalSequenceLength:D,maxSequenceLength:M,inputHiddenSize:C,hiddenSize:T,vHiddenSize:O,headSize:Math.floor(T/r.numHeads),vHeadSize:Math.floor(O/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:z,scale:r.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Zu=e=>me({...e}),Jm=(e,r,t,s)=>{let a=ft(s),f=se("x",r.dataType,r.dims,a),p="threadMaxVector";a===2?p="max(threadMaxVector.x, threadMaxVector.y)":a===4&&(p="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let g=De(r.dataType),u=64,w=s/a;w<u?u=1:w/8<64&&(u=Math.ceil(w/8));let C=Math.ceil(s/a/u),T=x=>`
  const dInv: ${g} = 1 / ${s};
  const dComp = ${s/a};
  var<workgroup> wgMax: array<f32, ${u}>;
  var<workgroup> wgSum: array<f32, ${u}>;

  ${x.declareVariables(f)}
  @compute @workgroup_size(${u}, 1, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_index : u32) {
    let localOffset = local_index * ${C};
    let offset: u32 = workgroup_id.x * dComp + localOffset;

    var threadMaxVector = ${st("f32",a,"-3.402823e+38f")};
    for (var i: u32 = 0; i < ${C} && i + localOffset < dComp; i++) {
      threadMaxVector = max(${_t(g,a,"x[offset + i]")}, threadMaxVector);
    }
    wgMax[local_index] = ${p};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${u}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${st("f32",a,"0")};
    for (var i: u32 = 0; i < ${C} && i + localOffset < dComp; i++) {
      sumVector += exp(${_t(g,a,"x[offset + i]")} - maxValue);
    }
    wgSum[local_index] = ${St("sumVector",a)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < ${C} && i + localOffset < dComp; i++) {
        x[offset + i] = ${st(g,a,"dInv")};
      }
    } else {
      for (var i: u32 = 0; i < ${C} && i + localOffset < dComp; i++) {
        let f32input = ${_t(g,a,"x[offset + i]")};
        x[offset + i] = ${f.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${s}`},getShaderSource:T,getRunData:()=>({outputs:[],dispatchGroup:{x:t}})},{inputs:[r],outputs:[]})},eg=(e,r,t,s,a,f)=>{let p=[a.batchSize,a.numHeads,a.sequenceLength,a.kvSequenceLength+a.pastSequenceLength],g=f.scale===0?1/Math.sqrt(a.headSize):f.scale,u=De(r.dataType),w=ft(a.headSize),C=te("q",r.dataType,r.dims,w),T=te("key",t.dataType,t.dims,w),x=se("output",r.dataType,p),O=a.headSize/w,k=a.sequenceLength,P=a.totalSequenceLength,D=O,M=12,z={x:Math.ceil(a.totalSequenceLength/M),y:Math.ceil(a.sequenceLength/M),z:a.batchSize*a.numHeads},G=[r,t],L=A=>`
  const M: u32 = ${k}u;
  const N: u32 = ${P}u;
  const K: u32 = ${D}u;
  const alpha: ${u} = ${g};
  const beta: ${u} = 1.0;
  const TILE_SIZE = ${M}u;

  var<workgroup> tileQ: array<${C.type.storage}, ${M*M}>;
  var<workgroup> tileK: array<${C.type.storage}, ${M*M}>;

  ${A.declareVariables(C,T,x)}

  @compute @workgroup_size(${M}, ${M}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${z.x*z.y}u +
          workgroup_id.y * ${z.x}u + workgroup_id.x) * ${M*M}u + local_index;

    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = ${a.sequenceLength*O} * headIdx + m * K;
    let kOffset = ${a.kvSequenceLength*O} * headIdx + n * K;

    var value = ${st(u,w)};
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m + local_id.y < M && w + local_id.x < K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];
      }
      if (n + local_id.y < N && w + local_id.x < K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * M * N;
    if (lm < M && ln < N) {
      let outputIdx = headOffset + lm * N + ln;
      output[outputIdx] = ${St("value",w)} * alpha;
    }
  }`,Y=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(a)},getRunData:()=>({outputs:[{dims:p,dataType:r.dataType,gpuDataType:0}],dispatchGroup:z}),getShaderSource:L},{inputs:G,outputs:[-1]})[0];return Jm(e,Y,a.batchSize*a.numHeads*a.sequenceLength,a.totalSequenceLength),Y},tg=(e,r,t,s)=>{let a=[s.batchSize,s.sequenceLength,s.vHiddenSize],f=te("probs",r.dataType,r.dims),p=te("v",t.dataType,t.dims),g=se("output",r.dataType,a),u=De(r.dataType),w=12,C={x:Math.ceil(s.vHeadSize/w),y:Math.ceil(s.sequenceLength/w),z:s.batchSize*s.numHeads},T=x=>`
  const M: u32 = ${s.sequenceLength}u;
  const N: u32 = ${s.vHeadSize}u;
  const K: u32 = ${s.totalSequenceLength}u;
  const numHeads: u32 = ${s.numHeads}u;
  const TILE_SIZE = ${w}u;

  var<workgroup> tileQ: array<${f.type.storage}, ${w*w}>;
  var<workgroup> tileK: array<${f.type.storage}, ${w*w}>;

  ${x.declareVariables(f,p,g)}

  @compute @workgroup_size(${w}, ${w}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${C.x*C.y}u +
          workgroup_id.y * ${C.x}u + workgroup_id.x) * ${w*w}u + local_index;

   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (M * K) + m * K;
   let offsetB = headIdx * (N * K) + n;

   var value = ${u}(0);
   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
     if (m < M && w + local_id.x < K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < N && w + local_id.y < K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / ${s.numHeads};
   let currentBatchHeadNumber = workgroup_id.z % ${s.numHeads};
   let headOffset = (batchIdx * M * ${s.numHeads} + currentBatchHeadNumber) * ${s.vHeadSize};
   if (m < M && n < N) {
     let outputIdx = batchIdx * ${s.sequenceLength*s.vHiddenSize} + m * ${s.vHiddenSize}
       + currentBatchHeadNumber * ${s.vHeadSize} + n;
     output[outputIdx] = value;
   }
  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(s)},getRunData:()=>({outputs:[{dims:a,dataType:r.dataType,gpuDataType:0}],dispatchGroup:C}),getShaderSource:T},{inputs:[r,t],outputs:[0]})[0]},Sn=(e,r,t,s,a,f,p,g,u,w,C)=>{let T=eg(e,r,t,u,w,C);tg(e,T,s,w)},rg=(e,r)=>{let t=[r.batchSize,r.numHeads,r.sequenceLength,r.headSize],s=De(e.inputs[0].dataType),a=r.sequenceLength,f=r.inputHiddenSize,p=r.headSize,g=12,u={x:Math.ceil(r.headSize/g),y:Math.ceil(r.sequenceLength/g),z:r.batchSize*r.numHeads},w=()=>`
  const M: u32 = ${a}u;
  const K: u32 = ${f}u;
  const N: u32 = ${p}u;
  const numHeads: u32 = ${r.numHeads};
  const ldb = ${r.hiddenSize+r.hiddenSize+r.vHiddenSize}u;
  const TILE_SIZE = ${g}u;

  var<workgroup> tileInput: array<${s}, ${g*g}>;
  var<workgroup> tileWeightQ: array<${s}, ${g*g}>;
  var<workgroup> tileWeightK: array<${s}, ${g*g}>;
  var<workgroup> tileWeightV: array<${s}, ${g*g}>;

  @group(0) @binding(0) var<storage, read> input: array<${s}>;
  @group(0) @binding(1) var<storage, read> weight: array<${s}>;
  @group(0) @binding(2) var<storage, read> bias: array<${s}>;
  @group(0) @binding(3) var<storage, read_write> outputQ: array<${s}>;
  @group(0) @binding(4) var<storage, read_write> outputK: array<${s}>;
  @group(0) @binding(5) var<storage, read_write> outputV: array<${s}>;

  @compute @workgroup_size(${g}, ${g}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${u.x*u.y}u +
          workgroup_id.y * ${u.x}u + workgroup_id.x) * ${g*g}u + local_index;

    let batchIndex = workgroup_id.z / ${r.numHeads};
    let headNumber = workgroup_id.z % ${r.numHeads};
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (M * K) + m * K;
    let biasOffsetQ = headNumber * ${r.headSize};
    let biasOffsetK = ${r.hiddenSize} + biasOffsetQ;
    let biasOffsetV = ${r.hiddenSize} + biasOffsetK;

    var valueQ = ${s}(0);
    var valueK = ${s}(0);
    var valueV = ${s}(0);
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m < M && w + local_id.x < K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < N && w + local_id.y < K) {
        let offset = n + (w + local_id.y) * ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * N + n) % ${r.headSize};
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * M * N;
    if (m < M && n < N) {
      let outputIdx = offset + m * N + n;
      outputQ[outputIdx] = valueQ;
      outputK[outputIdx] = valueK;
      outputV[outputIdx] = valueV;
    }
  }`,C=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(r)},getRunData:()=>({outputs:[{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:u}),getShaderSource:w},{inputs:C,outputs:[-1,-1,-1]})},Qu=(e,r)=>{let t=Qm(e.inputs,r),[s,a,f]=rg(e,t);return Sn(e,s,a,f,e.inputs[4],void 0,void 0,void 0,e.inputs[5],t,r)}});var ig,ng,ag,Ju,el=oe(()=>{"use strict";Ut();ke();Fe();Re();ig=(e,r)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(s,a,f)=>{let p=a.length;if(p!==s.length)throw new Error(`${f}: num dimensions != ${p}`);a.forEach((g,u)=>{if(g!==s[u])throw new Error(`${f}: dim[${u}] do not match`)})};if(e[0].dims.length>1){let s=r.format==="NHWC"?r.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,r.spatial?2:void 0);t(e[1].dims,s,"Invalid input scale"),t(e[2].dims,s,"Invalid input B"),t(e[3].dims,s,"Invalid input mean"),t(e[4].dims,s,"Invalid input var")}else t(e[1].dims,[1],"Invalid input scale"),t(e[2].dims,[1],"Invalid input B"),t(e[3].dims,[1],"Invalid input mean"),t(e[4].dims,[1],"Invalid input var")},ng=(e,r)=>{let{epsilon:t,spatial:s,format:a}=r,f=e[0].dims,p=s?ft(f[f.length-1]):1,g=a==="NHWC"&&f.length>1?p:1,u=X.size(f)/p,w=Le(f.length)&&s,C=w?f.length:f,T=te("x",e[0].dataType,e[0].dims,p),x=te("scale",e[1].dataType,e[1].dims,g),O=te("bias",e[2].dataType,e[2].dims,g),k=te("inputMean",e[3].dataType,e[3].dims,g),P=te("inputVar",e[4].dataType,e[4].dims,g),D=se("y",e[0].dataType,C,p),M=()=>{let G="";if(s)G=`let cOffset = ${f.length===1?"0u":a==="NHWC"?`outputIndices[${f.length-1}] / ${p}`:"outputIndices[1]"};`;else if(a==="NCHW")G=`
            ${D.indicesSet("outputIndices","0","0")}
            let cOffset = ${D.indicesToOffset("outputIndices")};`;else{G=`var cIndices = ${x.type.indices}(0);
                       cIndices[0] = outputIndices[${f.length-1}];`;for(let L=1;L<x.rank;L++)G+=`cIndices[${L}] = outputIndices[${L}];`;G+=`let cOffset = ${x.indicesToOffset("cIndices")};`}return G},z=G=>`
  const epsilon = ${t};
  ${G.registerUniform("outputSize","u32").declareVariables(T,x,O,k,P,D)}
  ${G.mainStart()}
  ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${D.offsetToIndices(`global_idx * ${p}`)};
    ${M()}
    let scale = ${x.getByOffset("cOffset")};
    let bias = ${O.getByOffset("cOffset")};
    let inputMean = ${k.getByOffset("cOffset")};
    let inputVar = ${P.getByOffset("cOffset")};
    let x = ${T.getByOffset("global_idx")};
    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;
    ${D.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${r.epsilon}_${r.format}_${s}_${p}`,inputDependencies:w?["rank","type","type","type","type"]:void 0},getShaderSource:z,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:w?[{type:"uint32",data:u},...Se(f)]:[{type:"uint32",data:u}]})}},ag=e=>me(e),Ju=(e,r)=>{let{inputs:t,outputCount:s}=e,a=ag({...r,outputCount:s});if(Ve.webgpu.validateInputContent&&ig(t,a),r.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(ng(t,a))}});var og,sg,tl,rl=oe(()=>{"use strict";ke();Re();og=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},sg=e=>{let r=e[0].dims,t=e[0].dims[2],s=X.size(r)/4,a=e[0].dataType,f=te("input",a,r,4),p=te("bias",a,[t],4),g=te("residual",a,r,4),u=se("output",a,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:C=>`
  const channels = ${t}u / 4;
  ${C.declareVariables(f,p,g,u)}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${f.getByOffset("global_idx")}
      + ${p.getByOffset("global_idx % channels")} + ${g.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},tl=e=>{og(e.inputs),e.compute(sg(e.inputs))}});var ug,ze,il,nl,al,ol,sl,ul,ll,dl,cl,lg,fl,pl,hl,ml,xn,gl,In,yl,bl,vl,wl,$l,Cl,_l,Sl,xl,Il,Al,El,Tl,Ol,kl,Rl,Pl,fa=oe(()=>{"use strict";Ze();ke();Fe();Re();ug=(e,r,t,s,a,f)=>{let p=Math.ceil(r/4),g="";typeof a=="string"?g=`${a}(a)`:g=a("a");let u=te("inputData",t,[p],4),w=se("outputData",s,[p],4);return`
      ${e.registerUniform("vec_size","u32").declareVariables(u,w)}

  ${f??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${w.setByOffset("global_idx",g)}
  }`},ze=(e,r,t,s,a,f=e.dataType)=>({name:r,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:p=>ug(p,X.size(e.dims),e.dataType,f,t,s),getRunData:p=>({outputs:[{dims:e.dims,dataType:f}],dispatchGroup:{x:Math.ceil(X.size(p[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(X.size(e.dims)/4)}]})}),il=e=>{e.compute(ze(e.inputs[0],"Abs","abs"))},nl=e=>{e.compute(ze(e.inputs[0],"Acos","acos"))},al=e=>{e.compute(ze(e.inputs[0],"Acosh","acosh"))},ol=e=>{e.compute(ze(e.inputs[0],"Asin","asin"))},sl=e=>{e.compute(ze(e.inputs[0],"Asinh","asinh"))},ul=e=>{e.compute(ze(e.inputs[0],"Atan","atan"))},ll=e=>{e.compute(ze(e.inputs[0],"Atanh","atanh"))},dl=e=>me(e),cl=(e,r)=>{let t;switch(r.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${r.to}`)}e.compute(ze(e.inputs[0],"Cast",t,void 0,r.cacheKey,r.to))},lg=e=>{let r=e.length>=2?e[1].getFloat32Array()[0]:wn,t=e.length>=3?e[2].getFloat32Array()[0]:$n;return me({min:r,max:t})},fl=(e,r)=>{let t=e.inputs.length===1?r:lg(e.inputs),s=De(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${s}> = vec4(${s}(${t.min}));
    const clip_max_: vec4<${s}> = vec4(${s}(${t.max}));
`,t.cacheKey),{inputs:[0]})},pl=e=>{e.compute(ze(e.inputs[0],"Ceil","ceil"))},hl=e=>{e.compute(ze(e.inputs[0],"Cos","cos"))},ml=e=>{e.compute(ze(e.inputs[0],"Cosh","cosh"))},xn=e=>me(e),gl=(e,r)=>{e.compute(ze(e.inputs[0],"Elu",t=>`elu_vf32(${t})`,`
  const elu_alpha_: f32 = f32(${r.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,r.cacheKey))},In=(e,r="f32")=>`
const r0: ${r} = 0.3275911;
const r1: ${r} = 0.254829592;
const r2: ${r} = -0.284496736;
const r3: ${r} = 1.421413741;
const r4: ${r} = -1.453152027;
const r5: ${r} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,yl=e=>{let r=De(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Erf",t=>`erf_vf32(${t})`,In(`vec4<${r}>`,r)))},bl=e=>{e.compute(ze(e.inputs[0],"Exp","exp"))},vl=e=>{e.compute(ze(e.inputs[0],"Floor","floor"))},wl=e=>{let r=De(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,In(`vec4<${r}>`,r)))},$l=(e,r)=>{e.compute(ze(e.inputs[0],"LeakyRelu",t=>`select(leaky_relu_alpha_ * ${t}, ${t}, ${t} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${r.alpha});`,r.cacheKey))},Cl=e=>{e.compute(ze(e.inputs[0],"Not",r=>`!${r}`))},_l=e=>{e.compute(ze(e.inputs[0],"Neg",r=>`-${r}`))},Sl=e=>{e.compute(ze(e.inputs[0],"Reciprocal",r=>`1.0/${r}`))},xl=e=>{e.compute(ze(e.inputs[0],"Relu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > vec4<f32>(0.0))`))},Il=e=>{e.compute(ze(e.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Al=e=>{e.compute(ze(e.inputs[0],"Sin","sin"))},El=e=>{e.compute(ze(e.inputs[0],"Sinh","sinh"))},Tl=e=>{e.compute(ze(e.inputs[0],"Sqrt","sqrt"))},Ol=e=>{e.compute(ze(e.inputs[0],"Tan","tan"))},kl=e=>{e.compute(ze(e.inputs[0],"Tanh","tanh"))},Rl=(e,r)=>(e.compute(ze(e.inputs[0],"ThresholdedRelu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${r.alpha});`,r.cacheKey)),0),Pl=e=>{e.compute(ze(e.inputs[0],"Log","log"))}});var cg,fg,Bl,Ml=oe(()=>{"use strict";ke();Re();fa();cg=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},fg=e=>{let r=e[0].dims.slice();r[2]=r[2]/2;let t=te("input",e[0].dataType,e[0].dims,4),s=te("bias",e[0].dataType,[e[0].dims[2]],4),a=se("output",e[0].dataType,r,4),f=X.size(r)/4,p=De(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:u=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${u.declareVariables(t,s,a)}

  ${In(`vec4<${p}>`,p)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(f)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${a.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Bl=e=>{cg(e.inputs),e.compute(fg(e.inputs))}});var pg,hg,zt,jl,Dl,zl,Wl,Vl,Nl,Ul,Hl,Ll,Gl,Fl=oe(()=>{"use strict";Ze();ke();Re();pg=(e,r,t,s,a,f,p,g,u,w,C,T,x)=>{let O,k;typeof g=="string"?O=k=(A,Z)=>`${g}((${A}),(${Z}))`:typeof g=="function"?O=k=g:(O=g.scalar,k=g.vector);let P=T?r.length:r,D=T?t.length:t,M=T?s.length:s,z=se("outputData",C,M,4),G=te("aData",u,P,4),L=te("bData",w,D,4),Y;if(a)if(f){let A=X.size(r)===1,Z=X.size(t)===1,J=r.length>0&&r[r.length-1]%4===0,re=t.length>0&&t[t.length-1]%4===0;A||Z?Y=z.setByOffset("global_idx",k(A?`${G.type.value}(${G.getByOffset("0")}.x)`:G.getByOffset("global_idx"),Z?`${L.type.value}(${L.getByOffset("0")}.x)`:L.getByOffset("global_idx"))):Y=`
            let outputIndices = ${z.offsetToIndices("global_idx * 4u")};
            let offsetA = ${G.broadcastedIndicesToOffset("outputIndices",z)};
            let offsetB = ${L.broadcastedIndicesToOffset("outputIndices",z)};
            ${z.setByOffset("global_idx",k(p||J?G.getByOffset("offsetA / 4u"):`${G.type.value}(${G.getByOffset("offsetA / 4u")}[offsetA % 4u])`,p||re?L.getByOffset("offsetB / 4u"):`${L.type.value}(${L.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else Y=z.setByOffset("global_idx",k(G.getByOffset("global_idx"),L.getByOffset("global_idx")));else{if(!f)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let A=(Z,J,re="")=>{let fe=`aData[indexA${J}][componentA${J}]`,F=`bData[indexB${J}][componentB${J}]`;return`
            let outputIndices${J} = ${z.offsetToIndices(`global_idx * 4u + ${J}u`)};
            let offsetA${J} = ${G.broadcastedIndicesToOffset(`outputIndices${J}`,z)};
            let offsetB${J} = ${L.broadcastedIndicesToOffset(`outputIndices${J}`,z)};
            let indexA${J} = offsetA${J} / 4u;
            let indexB${J} = offsetB${J} / 4u;
            let componentA${J} = offsetA${J} % 4u;
            let componentB${J} = offsetB${J} % 4u;
            ${Z}[${J}] = ${re}(${O(fe,F)});
          `};C===9?Y=`
            var data = vec4<u32>(0);
            ${A("data",0,"u32")}
            ${A("data",1,"u32")}
            ${A("data",2,"u32")}
            ${A("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Y=`
            ${A("outputData[global_idx]",0)}
            ${A("outputData[global_idx]",1)}
            ${A("outputData[global_idx]",2)}
            ${A("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(G,L,z)}

        ${x??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Y}
      }`},hg=(e,r,t,s,a,f,p=t.dataType)=>{let g=!X.areEqual(t.dims,s.dims),u=t.dims,w=X.size(t.dims),C=!1,T=!1,x=[g];if(g){let k=Rt.calcShape(t.dims,s.dims,!1);if(!k)throw new Error("Can't perform binary op on the given tensors");u=k,w=X.size(u);let P=X.size(t.dims)===1,D=X.size(s.dims)===1,M=t.dims.length>0&&t.dims[t.dims.length-1]%4===0,z=s.dims.length>0&&s.dims[s.dims.length-1]%4===0;x.push(P),x.push(D),x.push(M),x.push(z);let G=1;for(let L=1;L<u.length;L++){let Y=t.dims[t.dims.length-L]??1,A=s.dims[s.dims.length-L]??1;if(Y===A)G*=Y;else break}G%4===0?(T=!0,C=!0):(P||D||M||z)&&(C=!0)}else C=!0;x.push(C);let O=Le(t.dims.length)&&Le(s.dims.length)&&Le(u.length);return{name:e,shaderCache:{hint:r+x.map(k=>k.toString()).join("_"),inputDependencies:O?["rank","rank"]:["dims","dims"]},getShaderSource:k=>pg(k,t.dims,s.dims,u,C,g,T,a,t.dataType,s.dataType,p,O,f),getRunData:()=>({outputs:[{dims:u,dataType:p}],dispatchGroup:{x:Math.ceil(w/64/4)},programUniforms:O?[{type:"uint32",data:Math.ceil(X.size(u)/4)},...Se(t.dims),...Se(s.dims),...Se(u)]:[{type:"uint32",data:Math.ceil(X.size(u)/4)}]})}},zt=(e,r,t,s,a,f)=>{e.compute(hg(r,a??"",e.inputs[0],e.inputs[1],t,s,f))},jl=e=>{zt(e,"Add",(r,t)=>`${r}+${t}`)},Dl=e=>{zt(e,"Div",(r,t)=>`${r}/${t}`)},zl=e=>{zt(e,"Equal",{scalar:(r,t)=>`u32(${r}==${t})`,vector:(r,t)=>`vec4<u32>(${r}==${t})`},void 0,void 0,9)},Wl=e=>{zt(e,"Mul",(r,t)=>`${r}*${t}`)},Vl=e=>{let r=te("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;zt(e,"Pow",{scalar:(s,a)=>`pow_custom(${s},${a})`,vector:(s,a)=>`pow_vector_custom(${s},${a})`},`
    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {
      if (b == ${r}(0.0)) {
        return ${r}(1.0);
      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {
        return ${r}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {
      // TODO: implement vectorized pow
      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Nl=e=>{zt(e,"Sub",(r,t)=>`${r}-${t}`)},Ul=e=>{zt(e,"Greater",{scalar:(r,t)=>`u32(${r}>${t})`,vector:(r,t)=>`vec4<u32>(${r}>${t})`},void 0,void 0,9)},Hl=e=>{zt(e,"Less",{scalar:(r,t)=>`u32(${r}<${t})`,vector:(r,t)=>`vec4<u32>(${r}<${t})`},void 0,void 0,9)},Ll=e=>{zt(e,"GreaterOrEqual",{scalar:(r,t)=>`u32(${r}>=${t})`,vector:(r,t)=>`vec4<u32>(${r}>=${t})`},void 0,void 0,9)},Gl=e=>{zt(e,"LessOrEqual",{scalar:(r,t)=>`u32(${r}<=${t})`,vector:(r,t)=>`vec4<u32>(${r}<=${t})`},void 0,void 0,9)}});var gg,yg,bg,vg,ql,Kl,Yl=oe(()=>{"use strict";ke();Fe();Re();gg=e=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0].dataType,t=e[0].dims.length;for(let s of e){if(s.dataType!==r)throw new Error("input tensors should be one type");if(s.dims.length!==t)throw new Error("input tensors should have the same shape")}},yg=(e,r)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${r});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,bg=(e,r)=>{let t=e.length,s=[];for(let a=0;a<t;++a){let f=r.setByOffset("global_idx",e[a].getByIndices("indices"));t===1?s.push(f):a===0?s.push(`if (inputIndex == ${a}u) { ${f} }`):a===t-1?s.push(`else { ${f} }`):s.push(`else if (inputIndex == ${a}) { ${f} }`)}return s.join(`
`)},vg=(e,r)=>{let t=e[0].dims.slice();if(r>=t.length||r<-1*t.length)throw new Error("axis specified for concat doesn't match input dimensionality");let s=r<0?t.length+r:r,a=t.slice(0);for(let L=1;L<e.length;L++){let Y=e[L].dims.slice();for(let A=0;A<t.length;A++)if(A===s)a[s]+=Y[A];else if(t[A]!==Y[A])throw new Error("non concat dimensions must match")}let f=X.size(a),p=new Array(e.length),g=new Array(e.length),u=e[0].dataType,w=0,C=[],T=[],x=[],O=[{type:"uint32",data:f}];for(let L=0;L<e.length;++L)w+=e[L].dims[s],p[L]=w,x.push(Le(e[L].dims.length)),T.push(x[L]?e[L].dims.length:e[L].dims),g[L]=te(`input${L}`,u,T[L]),C.push(x[L]?"rank":"dims"),O.push({type:"uint32",data:p[L]});for(let L=0;L<e.length;++L)x[L]&&O.push(...Se(e[L].dims));let k=Le(a.length);k&&O.push(...Se(a));let P=k?a.length:a,D=se("output",u,P),M=D.indicesGet("indices",s),z=Array.from(Array(p.length).keys()).map(L=>`uniforms.sizeInConcatAxis${L}`).join(","),G=L=>`

  ${(()=>{L.registerUniform("outputSize","u32");for(let Y=0;Y<e.length;Y++)L.registerUniform(`sizeInConcatAxis${Y}`,"u32");return L.declareVariables(...g,D)})()}

  ${yg(p.length,z)}

  ${L.mainStart()}
    ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${D.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${M});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${p.length}u>(${z});
      ${M} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${bg(g,D)}
  }`;return{name:"Concat",shaderCache:{hint:`${r}`,inputDependencies:C},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:O}),getShaderSource:G}},ql=(e,r)=>{gg(e.inputs),e.compute(vg(e.inputs,r.axis))},Kl=e=>me({axis:e.axis})});var Ft,An,dr=oe(()=>{"use strict";ke();Ft=(e,r)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${r}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${r}(1.0) / (${r}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${r}(${e.clipMin});const clip_max_=${r}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},An=e=>{let r=e?.activation||"";if(r==="Clip"){let[t,s]=e?.activation_params||[wn,$n];return{activation:r,clipMax:s,clipMin:t,activationCacheKey:`${r}:${t},${s}`}}return{activation:r,activationCacheKey:r}}});var tt,En,Tn=oe(()=>{"use strict";tt=(e,r)=>{switch(e){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${e}-component is not supported.`)}},En=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `});var On,pa=oe(()=>{"use strict";On=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`});var wg,$g,Ei,Xl,Cg,Ti,_g,kn,Oi=oe(()=>{"use strict";ke();Re();dr();Tn();wg=(e,r)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${r?", batchIndices":""});
        `,$g=(e,r)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Ei=(e,r,t="f32",s,a=!1,f=32,p=!1,g=32)=>{let u=r[1]*e[1],w=r[0]*e[0],C=a?u:f,T=a?f:u,x=C/r[0],O=f/r[1];if(!((a&&x===4&&e[1]===4||!a&&(x===3||x===4))&&C%r[0]===0&&f%r[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${x} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${x} must be 3 or 4.
  tileAWidth ${C} must be divisible by workgroupSize[0]${r[0]}. tileInner ${f} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${x}<${t}>, ${C/x}>, ${T}>;
var<workgroup> mm_Bsub: array<array<vec4<${t}>, ${w/e[0]}>, ${f}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${x};
const tileInner = ${f};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${p?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let numTiles = ${p?`${Math.ceil(g/f)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
  var kStart = ${p?`i32(globalId.z) * ${g}`:"0"};

  var acc: array<vec4<${t}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${O};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${wg(a,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${O}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${x===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${$g(a,x)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Xl=(e,r)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${r?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${r?", batchIndices":""});
            `,Cg=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Ti=(e,r,t="f32",s,a=!1,f=32,p=!1,g=32,u=!1)=>{let w=e[1]*r[1],C=e[0]*r[0],T=a?w:f,x=a?f:w;if(!(x%r[1]===0&&T%r[0]===0&&f%r[1]===0))throw new Error(`tileAHight ${x} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${T} must be divisible by workgroupSize[0]${r[0]}, tileInner ${f} must be divisible by workgroupSize[1]${r[1]}`);let O=x/r[1],k=T/r[0],P=f/r[1],D=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${w};
    let globalColStart = i32(workgroupId.x) * ${C};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${x}; inputRow = inputRow + ${r[1]}) {
        for (var inputCol = localCol; inputCol < ${T}; inputCol = inputCol + ${r[0]}) {
          ${Xl(a,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${r[1]}) {
            for (var inputCol = localCol; inputCol < ${C}; inputCol = inputCol + ${r[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${t}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${r[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${r[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${w};

let tileRowA = i32(localId.y) * ${O};
let tileColA = i32(localId.x) * ${k};
let tileRowB = i32(localId.y) * ${P};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${O}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${k}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Xl(a,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${P}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${t}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Cg(a)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${t}, ${T}>, ${x}>;
  var<workgroup> mm_Bsub : array<array<${t}, ${C}>, ${f}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${f};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${p?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${p?`${Math.ceil(g/f)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${p?`i32(globalId.z) * ${g}`:"0"};

    var acc : array<array<${t}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${D}
  }
`},_g=(e,r,t,s,a,f=!1)=>{let[p,g,u]=a,[w,C,T,x]=s,O=ua(p,u),k=ua(g,u),P=De(s[0].type.tensor),D=()=>{let G=C.rank,L=w.rank,Y=`var aIndices: ${C.type.indices};`;for(let A=G-2-1,Z=L-1;A>=0;A--,Z--)Y+=`
aIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return O.forEach(A=>{Y+=`
aIndices[${A}] = 0;`}),Y+=`
aIndices[${G-2}] = u32(row);
                   aIndices[${G-1}] = u32(colIn);`,Y},M=()=>{let G=T.rank,L=w.rank,Y=`var bIndices: ${T.type.indices};`;for(let A=G-2-1,Z=L-1;A>=0;A--,Z--)Y+=`
bIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return k.forEach(A=>{Y+=`
bIndices[${A}] = 0;`}),Y+=`
bIndices[${G-2}] = u32(row);
                   bIndices[${G-1}] = u32(colIn);`,Y};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${w.type.indices}) -> ${tt(e,P)} {
      var value = ${tt(e,P)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dimAOuter && col < uniforms.dimInner)
      {
        ${D()}
        value = ${C.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${w.type.indices}) -> ${tt(e,P)} {
      var value = ${tt(e,P)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dimInner && col < uniforms.dimBOuter)
      {
        ${M()}
        value = ${T.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tt(e,P)}) {
      let col = colIn * ${e};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${r?`value = value + ${f?"bias[colIn]":`${tt(e,P)}(bias[row])`};`:""}
        ${t}
        ${x.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},kn=(e,r,t,s,a=!1)=>{let f=e[0].dims,p=e[1].dims,g=f.slice(0,-2),u=p.slice(0,-2),w=s?s.slice(0,-2):t.slice(0,-2),C=Le(w.length),T=C?w.length:w,x=$u("batchDims",e[0].dataType,T,1),O=X.size(w),k=f[f.length-2],P=f[f.length-1],D=p[p.length-1],M=P%4===0&&D%4===0,z=k<=8?[4,1,1]:[4,4,1],G=[8,8,1],L=[Math.ceil(D/G[0]/z[0]),Math.ceil(k/G[1]/z[1]),Math.ceil(O/G[2]/z[2])],Y=De(e[0].dataType),A=M?4:1,Z=[...g,k,P/A],J=Le(Z.length),re=J?Z.length:Z,fe=[...u,P,D/A],F=Le(fe.length),ae=F?fe.length:fe,_e=[O,k,D/A],he=te("a",e[0].dataType,re,A),Pe=te("b",e[1].dataType,ae,A),ue=se("result",e[0].dataType,_e.length,A),Be=[he,Pe],Me=[{type:"int32",data:k},{type:"int32",data:D},{type:"int32",data:P}];C&&Me.push(...Se(w)),J&&Me.push(...Se(Z)),F&&Me.push(...Se(fe));let je=[];je.push(J?"rank":"dims"),je.push(F?"rank":"dims");let Ae=e.length>2,{activationFunction:At,applyActivation:it}=Ft(r,ue.type.value),nt=_g(A,Ae,it,[x,he,Pe,ue],[g,u,w],a);if(Ae){let we=a?A:1;Be.push(te("bias",e[2].dataType,e[2].dims.length,we)),Me.push(...Se(e[2].dims)),je.push("rank")}Me.push(...Se(_e));let ie=we=>`
  ${we.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(x).declareVariables(...Be,ue)}
  ${At}
  ${nt}
  ${M?Ei(z,G,Y,x):Ti(z,G,Y,x)}
                   `;return{name:"MatMul",shaderCache:{hint:r.activationCacheKey+`${z}${r.activation}${r.clipMax}${r.clipMin}${M}${Ae}${a}`,inputDependencies:je},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:L[0],y:L[1],z:L[2]},programUniforms:Me}),getShaderSource:ie}}});var Sg,Zl,Ql=oe(()=>{"use strict";Gt();Re();dr();Tn();pa();Oi();Sg=(e,r,t,s,a=!1,f,p=4,g=4,u=4,w="f32")=>{let C=F=>{switch(F){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${w}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${F} is not supported.`)}},T=F=>{switch(F){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${F} is not supported.`)}},x=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,O=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,k=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",P=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",D=e?"row":"col",M=e?"col":"row",z=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${D} / outWidth;
    let outCol = ${D} % outWidth;

    let WRow = ${M} / (filterDims[1] * inChannels);
    let WCol = ${M} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${M} % inChannels;
    var resData = ${tt(p,w)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${k} && xCol >= 0 && xCol < ${P}) {
      ${x}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${C(p)}
    }
    return resData;`,G=e?r&&s?`
    let col = colIn * ${p};
    ${z}`:`
    let col = colIn * ${p};
    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${z}
    }
    return ${tt(p,w)}(0.0);`:s&&t?`
    let col = colIn * ${p};
    ${z}`:`
    let col = colIn * ${p};
    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
      ${z}
    }
    return ${tt(p,w)}(0.0);`,L=`${T(g)}`,Y=tt(u,w),A=e?tt(p,w):tt(g,w),Z=e?tt(g,w):tt(p,w),{activationFunction:J,applyActivation:re}=Ft(f,Y);return`
    ${J}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${A} {
      ${e?G:L}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Z} {
      ${e?L:G}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Y}) {
      let col = colIn * ${u};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${O}
      ${En(a)}
      ${re}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Zl=(e,r,t,s,a,f,p,g)=>{let u=r.format==="NHWC",w=u?e[0].dims[3]:e[0].dims[1],C=t[0],T=u?t[2]:t[3],x=u?t[1]:t[2],O=u?t[3]:t[1],k=u&&(w%4===0||w%3===0)&&O%4===0,P=u?O:T*x,D=u?T*x:O,M=[8,8,1],z=s<=8?[4,1,1]:[4,4,1],G=[Math.ceil(P/M[0]/z[0]),Math.ceil(D/M[1]/z[1]),Math.ceil(C/M[2]/z[2])];Ge("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${G}`);let L=k?u&&w%4!==0?3:4:1,Y=M[1]*z[1],A=M[0]*z[0],Z=Math.max(M[0]*L,M[1]),J=s%Y===0,re=a%A===0,fe=f%Z===0,F=k?[L,4,4]:[1,1,1],ae=De(e[0].dataType),_e=k?4:1,he=[{type:"int32",data:s},{type:"int32",data:a},{type:"int32",data:f}],Pe=te("x",e[0].dataType,e[0].dims.length,L===3?1:L),ue=te("w",e[1].dataType,e[1].dims.length,_e),Be=[Pe,ue];he.push(...Se(e[0].dims)),he.push(...Se(e[1].dims));let Me=`
      fn setOutputAtIndex(flatIndex : i32, value : ${k?`vec4<${ae}>`:ae}) {
        result[flatIndex] = ${k?`vec4<${ae}>`:ae}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${k?`vec4<${ae}>`:ae}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${k?"/ 4":""}, value);
      }`;if(p){let Ae=te("bias",e[2].dataType,e[2].dims.length,_e);Be.push(Ae),he.push(...Se(e[2].dims)),Me+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${k?`vec4<${ae}>`:ae} {
          return bias[coords.${u?"w":"y"}${k?"/ 4":""}];
        }`}let je=se("result",e[0].dataType,t.length,_e);return he.push(...Se(t)),{name:"Conv2DMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:G[0],y:G[1],z:G[2]},programUniforms:he}),getShaderSource:Ae=>`
        ${On("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ae.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...Be,je)}
        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[0]}, ${r.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${r.pads[0]}, ${r.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});
        ${Me}
        ${Sg(u,J,re,fe,p,r,F[0],F[1],F[2],ae)}
            ${k?Ei(z,M,ae,void 0,!u,Z):Ti(z,M,ae,void 0,!u,Z,!1,void 0,g)}`}}});var ha,Jl=oe(()=>{"use strict";ke();Re();ga();dr();ha=(e,r,t)=>{let s=e.length>2,a=s?"value += b[output_channel];":"",f=e[0].dims,p=e[1].dims,g=p[0]/r.group,u=r.format==="NHWC",w=ma(f,p,r.dilations,r.pads,r.strides,u),C=X.size(w),T=se("output",e[0].dataType,w),{activationFunction:x,applyActivation:O}=Ft(r,T.type.value),k=te("x",e[0].dataType,f),P=te("w",e[1].dataType,p),D=[k,P];s&&D.push(te("b",e[2].dataType,e[2].dims));let M=z=>`
  const strides: vec2<u32> = vec2(${r.strides[0]}u, ${r.strides[1]}u);
  const pads: vec2<u32> = vec2(${r.pads[0]}u, ${r.pads[1]}u);

  ${z.declareVariables(...D,T)}

  ${x}

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes(C)}

    let outputIndices = ${T.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${u?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${g}u;

    var value: ${T.type.value} = ${T.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${p[1]}u; wInChannel++) {
      let input_channel = group_id * ${p[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${p[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${r.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${f[u?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${p[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${r.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${f[u?2:3]}u) {
            continue;
          }

          let xVal = ${u?k.get("batch","xHeight","xWidth","input_channel"):k.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${P.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${a}
    ${O}
    ${T.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t?t(w):w,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(C/64)}}),getShaderSource:M}}});var ma,ed,xg,td,ya,Ig,Ag,ba,ga=oe(()=>{"use strict";ke();Fe();Ql();Oi();Jl();dr();jr();ma=(e,r,t,s,a,f)=>{let p=e[0],g=e.slice(f?1:2,f?3:4),u=g.length,w=r[0],T=r.slice(2).map((k,P)=>k+(k-1)*(t[P]-1)),O=g.map((k,P)=>k+s[P]+s[P+u]).map((k,P)=>Math.floor((k-T[P]+a[P])/a[P]));return O.splice(0,0,p),O.splice(f?3:1,0,w),O},ed=[2,3,1,0],xg=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],s=e[1].dims[1]*r.group;if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(r.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(r.strides.length!==a)throw new Error(`strides should be ${a}D`);if(r.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},td=(e,r)=>{let t=e.kernelShape.slice();for(let f=2;f<r[1].dims.length;++f)t[f-2]===0&&(t[f-2]=r[1].dims[f]);let s=e.pads.slice();lr.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,t,s,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:t,pads:s,cacheKey:e.cacheKey}),a},ya=e=>{let r=An(e),t=e.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,f=e.group,p=e.kernel_shape,g=e.pads,u=e.strides,w=e.w_is_const();return me({autoPad:s,format:t,dilations:a,group:f,kernelShape:p,pads:g,strides:u,wIsConst:w,...r})},Ig=(e,r,t)=>{let s=td(t,r);if(t.group!==1){e.compute(ha(r,s));return}let a=t.format==="NHWC",f=r.length===3,p=r[0].dims[a?1:2],g=r[0].dims[a?2:3],u=r[0].dims[a?3:1],w=r[1].dims[2],C=r[1].dims[3],T=ma(r[0].dims,r[1].dims,t.dilations,s.pads,t.strides,a),x=T[a?1:2],O=T[a?2:3],k=T[a?3:1],P=a&&w===p&&C===g&&t.pads[0]===0&&t.pads[1]===0;if(P||w===1&&C===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let A=T[0],Z,J,re,fe=[];if(a){let F=e.kernelCustomData.wT??e.compute(xt(r[1],ed),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=F),P){let ae=p*g*u;Z=r[0].reshape([1,A,ae]),J=F.reshape([1,ae,k]),re=[1,A,k]}else Z=r[0].reshape([A,p*g,u]),J=F.reshape([1,u,k]),re=[A,x*O,k];fe.push(Z),fe.push(J)}else Z=r[0].reshape([A,u,p*g]),J=r[1].reshape([1,k,u]),re=[A,k,x*O],fe.push(J),fe.push(Z);f&&fe.push(r[2]),e.compute(kn(fe,s,T,re,a),{inputs:fe});return}let D=!0,M=e.kernelCustomData.wT??e.compute(xt(r[1],ed),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M);let z=[r[0],M];f&&z.push(r[2]);let G=a?x*O:k,L=a?k:x*O,Y=w*C*u;e.compute(Zl(z,s,T,G,L,Y,f,D),{inputs:z})},Ag=(e,r)=>{let t=r.format==="NHWC",s=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&s.push(e.inputs[2]);let a=[0,r.pads[0],0,r.pads[1]],f=[1].concat(r.strides),p=[1].concat(r.dilations),g=[1].concat(r.kernelShape),u=td({...r,pads:a,strides:f,dilations:p,kernelShape:g},s);e.compute(ha(s,u,w=>t?[w[0],w[2],w[3]]:[]))},ba=(e,r)=>{xg(e.inputs,r),e.inputs[0].dims.length===3?Ag(e,r):Ig(e,e.inputs,r)}});var Eg,rd,id=oe(()=>{"use strict";Gt();Re();dr();Tn();pa();Oi();Eg=(e,r=!1,t,s=4)=>{let a=tt(s,"f32"),f=z=>{switch(z){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,g=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,u=e?"outBackprop[1]":"outBackprop[2]",w=e?"outBackprop[2]":"outBackprop[3]",C=e?"row":"col",T=e?"col":"row",x=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${C} / outWidth;
      let outCol = ${C} % outWidth;

      let WRow = ${T} / (filterDims[1] * inChannels);
      let WCol = ${T} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${u}) || fract(xR) > 0.0) {
        return ${a}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${w}) || fract(xC) > 0.0) {
        return ${a}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${T} % inChannels;
      ${p}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${s}];`,O=e?`
      let col = colIn * ${s};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${x}
      }
      return ${a}(0.0);`:`
      let col = colIn * ${s};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${x}
      }
      return ${a}(0.0);`,k=`
      let col = colIn * ${s};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${f(s)}
      }
      return ${a}(0.0);
      `,{activationFunction:P,applyActivation:D}=Ft(t,a);return`
      ${P}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${e?O:k}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${e?k:O}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {
    let col = colIn * ${s};
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${g}
      ${En(r)}
      ${D}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${s}] = value;
    }
  }`},rd=(e,r,t,s,a,f,p,g)=>{let u=r.format==="NHWC",w=u?e[0].dims[3]:e[0].dims[1],C=t[0],T=u?t[2]:t[3],x=u?t[1]:t[2],O=u?t[3]:t[1],k=u?w%4===0&&O%4===0:T%4===0&&O%4===0,P=u?O:T*x,D=u?T*x:O,M=k?[8,8,1]:[P<=4||D<=4?4:16,P>4&&D<=4?4:16,1],z=k?[4,4,1]:[P<=4?1:4,P>4&&D<=4?1:4,1],G=[Math.ceil(P/M[0]/z[0]),Math.ceil(D/M[1]/z[1]),Math.ceil(C/M[2]/z[2])];Ge("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${G}`);let L=k?4:1,Y=Math.max(M[0]*L,M[1]),A=k?4:1,Z=[{type:"int32",data:s},{type:"int32",data:a},{type:"int32",data:f}],J=te("x",e[0].dataType,e[0].dims.length,A),re=te("w",e[1].dataType,e[1].dims.length,1),fe=se("result",e[0].dataType,t.length,A),F=[J,re];Z.push(...Se(e[0].dims)),Z.push(...Se(e[1].dims));let ae="";if(p){let _e=te("bias",e[2].dataType,e[2].dims.length,A);F.push(_e),Z.push(...Se(e[2].dims)),ae+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${k?"vec4<f32>":"f32"} {
          return bias[coords.${u?"w":"y"}${k?"/ 4":""}];
        }`}return Z.push(...Se(t)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:G[0],y:G[1],z:G[2]},programUniforms:Z}),getShaderSource:_e=>`
        ${On("uniforms.result_strides")}
        ${_e.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...F,fe)};
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[u?1:2]}, ${r.kernelShape[u?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${r.dilations[0]<=1?0:(r.kernelShape[u?1:2]-1)*(r.dilations[0]-1)},
              ${r.dilations[1]<=1?0:(r.kernelShape[u?2:3]-1)*(r.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});
        const dimAOuter : i32 = ${s};
        const dimBOuter : i32 = ${a};
        const dimInner : i32 = ${f};
        ${ae}
        ${Eg(u,p,r,L)}
        ${k?Ei(z,M,"f32",void 0,!u,Y):Ti(z,M,"f32",void 0,!u,Y,!1,void 0,g)}`}}});var Tg,va,nd=oe(()=>{"use strict";Gt();ke();Re();Tg=(e,r,t,s,a,f,p=!1,g)=>{let u=t.format==="NHWC",w=u?1:2,C=u?2:3,T=u?3:1,x=X.size(s),O=p?2:1,k=t.group,P=r[1].dims,D=P[0]/k,M=P[1],z=`
  fn setOutputAtIndex(flatIndex : u32, value : ${p?`vec4<${g}>`:g}) {
    result[flatIndex] = ${p?`vec4<${g}>`:g}(value);
  }`;a&&(z+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${p?`vec4<${g}>`:g} {
      return bias[coords.${u?"w":"y"}${p?"/ 4":""}];
    }`);let G=p?4:1,L=te("W",r[1].dataType,r[1].dims,G),Y=te("Dy",r[0].dataType,r[0].dims,G),A=[Y,L];a&&A.push(te("bias",r[2].dataType,[s[T]],G));let Z=se("result",r[0].dataType,s,G),J=`{
        let batch: u32 = ${f?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${f?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${f?"global_id.y":"workgroup_id.y"} * ${O};
        let d1: u32 = ${f?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${g}>, ${O}>;
        for (var i = 0; i < ${O}; i++) {
          dotProd[i] = vec4<${g}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${g}(dyCorner.x) + ${g}(wR)) / ${g}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${g}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${g}(dyCorner.y) + ${g}(wC)) / ${g}(strides.y);
            let dyC2 = (${g}(dyCorner.y) + 1.0 + ${g}(wC)) / ${g}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${g}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${g}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${g}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Y.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${g}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${T}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${g}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${g}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${O}; i = i + 1) {
          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};
          ${Z.set("batch","r","c + i","d1","value")};
        }
      }`,re=`
          let outputIndices = ${Z.offsetToIndices("global_idx")};
          let batch = ${Z.indicesGet("outputIndices",0)};
          let d1 = ${Z.indicesGet("outputIndices",T)};
          let r = ${Z.indicesGet("outputIndices",w)};
          let c = ${Z.indicesGet("outputIndices",C)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${M};
          let wOutChannel = d1 - groupId * ${M};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${g}(dyRCorner) + ${g}(wR)) / ${g}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${g}(outBackprop[${w}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${g}(dyCCorner) + ${g}(wC)) / ${g}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${g}(outBackprop[${C}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${D};
              for (var d2: u32 = 0; d2 < ${D}; d2 = d2 + 1) {
                let xValue = ${u?Y.get("batch","idyR","idyC","inputChannel"):Y.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${L.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${a?"bias[d1]":"0.0"};
          ${Z.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...A,Z)}
  ${z}
  const outShape : vec4<u32> = vec4<u32>(${s.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${r[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${t.strides[0]}, ${t.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${t.kernelShape[u?1:2]}, ${t.kernelShape[u?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${t.dilations[0]}, ${t.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${t.dilations[0]<=1?0:(t.kernelShape[u?1:2]-1)*(t.dilations[0]-1)},
          ${t.dilations[1]<=1?0:(t.kernelShape[u?2:3]-1)*(t.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)};
  ${p?J:re}}`},va=(e,r,t)=>{let s=e.length>2,a=r.outputShape,f=X.size(a),p=[Math.ceil(f/64),1,1];Ge("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${p}`);let g=De(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:r.cacheKey},getRunData:()=>({dispatchGroup:{x:p[0],y:p[1],z:p[2]},outputs:[{dims:t?t(a):a,dataType:e[0].dataType}]}),getShaderSource:u=>Tg(u,e,r,a,s,p[1]===1&&p[2]===1,!1,g)}}});var Og,kg,Rg,ad,od,Pg,Bg,Mg,jg,sd,ud=oe(()=>{"use strict";Fe();id();nd();dr();jr();Og=(e,r,t,s,a,f)=>(e-1)*r+t+(s-1)*a+1-f,kg=(e,r,t,s,a)=>{let f=Math.floor(e/2);r==="SAME_UPPER"?(t[s]=f,t[a]=e-f):r==="SAME_LOWER"&&(t[s]=e-f,t[a]=f)},Rg=(e,r,t,s,a,f,p,g,u,w)=>{let C=e.length-2,T=w.length===0;if(u.length===0)for(let k=0;k<C;++k)u.push(0);let x=e[0],O=r[g?3:1]*a;for(let k=0,P=e.length-C-(g?1:0);k<C;++k,++P){let D=e[P],M=T?D*p[k]:w[k],z=Og(D,p[k],f[k],r[P],t[k],M);kg(z,s,f,k,k+C),T&&w.push(p[k]*(D-1)+u[k]+(r[P]-1)*t[k]+1-f[k]-f[k+C])}w.splice(0,0,x),w.splice(g?3:1,0,O)},ad=(e,r)=>{let t=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((x,O)=>x*O,1)===0){t.length=0;for(let x=2;x<r[1].dims.length;++x)t.push(r[1].dims[x])}let s=e.format==="NHWC";t.splice(0,0,r[1].dims[0]),t.splice(s?3:1,0,r[1].dims[1]);let a=e.pads.slice(),f=e.outputShape.slice(),p=e.outputPadding.slice(),g=r[0].dims,u=e.dilations.slice();if(u.reduce((x,O)=>x+O,0)===0){let x=r[0].dims.length-2;u=new Array(x).fill(1)}let w=e.strides.slice();if(w.reduce((x,O)=>x+O,0)===0){let x=r[0].dims.length-2;w=new Array(x).fill(1)}Rg(g,t,u,e.autoPad,e.group,a,w,s,p,f);let C=Object.assign({},e),T=e.cacheKey+[t.join("n,"),a.join(","),w.join(","),p.join(","),f.join(","),u.join(",")].join("_");return Object.assign(C,{kernelShape:t,pads:a,outputPadding:p,outputShape:f,dilations:u,strides:w,cacheKey:T}),C},od=e=>{let r=An(e),t=e.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,f=e.group,p=e.kernelShape,g=e.pads,u=e.strides,w=e.wIsConst(),C=e.outputPadding,T=e.outputShape;return me({autoPad:s,format:t,dilations:a,group:f,kernelShape:p,outputPadding:C,outputShape:T,pads:g,strides:u,wIsConst:w,...r})},Pg=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],s=e[1].dims[0];if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let f=e[0].dims.length-2;if(r.dilations.reduce((C,T)=>C+T,0)>0&&r.dilations.length!==f)throw new Error(`dilations should be ${f}D`);if(r.strides.reduce((C,T)=>C+T,0)>0&&r.strides.length!==f)throw new Error(`strides should be ${f}D`);if(r.pads.reduce((C,T)=>C+T,0)>0&&r.pads.length!==f*2)throw new Error(`pads should be ${f*2}D`);if(r.outputPadding.length!==f&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${f}D`);if(r.kernelShape.reduce((C,T)=>C+T,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Bg=[2,3,1,0],Mg=(e,r,t)=>{let s=ad(t,r),a=t.format==="NHWC",f=r.length===3;if(s.group!==1){e.compute(va(r,s));return}let p=s.outputShape,g=p[a?1:2],u=p[a?2:3],w=p[a?3:1],C=r[1].dims[2],T=r[1].dims[3],x=r[0].dims[a?3:1],O=a?g*u:w,k=a?w:g*u,P=C*T*x,D=!0,M=e.kernelCustomData.wT??e.compute(xt(r[1],Bg),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M);let z=[r[0],M];f&&(!a&&r[2].dims.length===1?z.push(r[2].reshape([r[2].dims[0],1,1])):z.push(r[2])),e.compute(rd(z,s,p,O,k,P,f,D),{inputs:z})},jg=(e,r)=>{let t=r.format==="NHWC",s=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];s.length===3&&s.push(e.inputs[2]);let a=r.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let f=r.dilations;(f.length===0||f[0]===0)&&(f=[1]);let p=r.strides;(p.length===0||p[0]===0)&&(p=[1]);let g=r.pads;g.length===0&&(g=[0,0]),g=[0,g[0],0,g[1]],p=[1].concat(p),f=[1].concat(f),a=[1].concat(a);let u=ad({...r,pads:g,strides:p,dilations:f,kernelShape:a},s);e.compute(va(s,u,w=>t?[w[0],w[2],w[3]]:[w[0],w[1],w[3]]))},sd=(e,r)=>{Pg(e.inputs,r),e.inputs[0].dims.length===3?jg(e,r):Mg(e,e.inputs,r)}});var wa,Rn,ld,Dg,zg,$a,Ca,dd,Wg,cd,fd,pd=oe(()=>{"use strict";ke();Fe();Re();wa="[a-zA-Z]|\\.\\.\\.",Rn="("+wa+")+",ld="^"+Rn+"$",Dg="("+Rn+",)*"+Rn,zg="^"+Dg+"$",$a=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,t){let s=this.symbolToIndices.get(r);s===void 0?s=[t]:s.push(t),this.symbolToIndices.set(r,s)}},Ca=class{constructor(r,t){this.equation=t;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[s,a]=t.includes("->")?t.split("->",2):[t,""];if(!s.match(RegExp(zg)))throw new Error("Invalid LHS term");if(s.split(",").forEach((g,u)=>{let w=r[u].dims.slice();if(!g.match(RegExp(ld)))throw new Error("Invalid LHS term");let C=this.processTerm(g,!0,w,u);this.lhs.push(C)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([g,u])=>u.count===1||g==="...").map(([g])=>g).join("");else if(!a.match(RegExp(Rn)))throw new Error("Invalid RHS");a.match(RegExp(wa,"g"))?.forEach(g=>{if(g==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let u=this.symbolToInfo.get(g);if(u===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(u.dimValue)}}),this.rhs=this.processTerm(a,!1,this.outputDims)}addSymbol(r,t,s){let a=this.symbolToInfo.get(r);if(a!==void 0){if(a.dimValue!==t&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(s)}else a={count:1,dimValue:t,inputIndices:[s]};this.symbolToInfo.set(r,a)}processTerm(r,t,s,a=-1){let f=s.length,p=!1,g=[],u=0;if(!r.match(RegExp(ld))&&!t&&r!=="")throw new Error("Invalid LHS term");let w=r.match(RegExp(wa,"g")),C=new $a(a);return w?.forEach((T,x)=>{if(T==="..."){if(p)throw new Error("Only one ellipsis is allowed per input term");p=!0;let O=f-w.length+1;if(O<0)throw new Error("Ellipsis out of bounds");if(g=s.slice(u,u+O),this.hasEllipsis){if(this.ellipsisDims.length!==g.length||this.ellipsisDims.toString()!==g.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=g;else throw new Error("Ellipsis must be specified in the LHS");for(let k=0;k<g.length;k++){let P=String.fromCharCode("0".charCodeAt(0)+k);C.addSymbol(P,x+k),this.addSymbol(P,s[u++],a)}}else C.addSymbol(T,x+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(T,s[u++],a)}),C}},dd=e=>e+"_max",Wg=(e,r,t,s,a)=>{let p=r.map((O,k)=>e[k]?O.length:O).map((O,k)=>te(`input${k}`,t,O)),g=X.size(a),u=Le(a.length),w=u?a.length:a,C=se("output",t,w),T=[...s.symbolToInfo.keys()].filter(O=>!s.rhs.symbolToIndices.has(O)),x=O=>{let k=[],P="var prod = 1.0;",D="var sum = 0.0;",M="sum += prod;",z=[],G=[],L=[],Y=[],A=s.symbolToInfo.size===s.rhs.symbolToIndices.size;s.symbolToInfo.forEach((J,re)=>{if(s.rhs.symbolToIndices.has(re)){let fe=s.rhs.symbolToIndices.get(re)?.[0];fe!==void 0&&s.lhs.forEach((F,ae)=>{if(J.inputIndices.includes(ae)){let _e=F.symbolToIndices.get(re);if(_e===void 0)throw new Error("Invalid symbol error");_e.forEach(he=>{k.push(`${p[ae].indicesSet(`input${ae}Indices`,he,C.indicesGet("outputIndices",fe))}`)})}})}else s.lhs.forEach((fe,F)=>{if(J.inputIndices.includes(F)){let ae=fe.symbolToIndices.get(re);if(ae===void 0)throw new Error("Invalid symbol error");ae.forEach(_e=>{z.push(`${p[F].indicesSet(`input${F}Indices`,_e,`${re}`)}`)}),Y.push(`prod *= ${p[F].getByIndices(`input${F}Indices`)};`)}}),G.push(`for(var ${re}: u32 = 0; ${re} < uniforms.${dd(re)}; ${re}++) {`),L.push("}")});let Z=A?[...k,`let sum = ${p.map((J,re)=>J.getByIndices(`input${re}Indices`)).join(" * ")};`]:[...k,D,...G,...z,P,...Y,M,...L];return`
            ${O.registerUniforms(T.map(J=>({name:`${dd(J)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...p,C)}

            ${O.mainStart()}
            ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${C.offsetToIndices("global_idx")};
            ${p.map((J,re)=>`var input${re}Indices: ${p[re].type.indices};`).join(`
`)}
            ${Z.join(`
`)};
            ${C.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:s.equation,inputDependencies:e.map(O=>O?"rank":"dims")},getRunData:()=>{let O=T.filter(P=>s.symbolToInfo.has(P)).map(P=>({type:"uint32",data:s.symbolToInfo.get(P)?.dimValue||0}));O.push({type:"uint32",data:g});let k=r.filter((P,D)=>e[D]).map((P,D)=>[...Se(P)]).reduce((P,D)=>P.concat(D),O);return u&&k.push(...Se(a)),{outputs:[{dims:a,dataType:t}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:k}},getShaderSource:x}},cd=(e,r)=>{let t=new Ca(e.inputs,r.equation),s=e.inputs.map((p,g)=>Le(p.dims.length)),a=t.outputDims,f=e.inputs.map((p,g)=>p.dims);e.compute(Wg(s,f,e.inputs[0].dataType,t,a))},fd=e=>{let r=e.equation.replace(/\s+/g,"");return me({equation:r})}});var Vg,hd,Ng,Ug,md,gd=oe(()=>{"use strict";Ze();ke();Re();Vg=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let r=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),s=t.length<r.length?0:t.length-r.length,a=r.length<t.length?0:r.length-t.length;for(;s<t.length&&a<r.length;++s,++a)if(t[s]!==r[a]&&t[s]!==1&&r[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},hd=(e,r)=>{let t=e.length-r.length,s=[];for(let a=0;a<t;++a)s.push(e[a]);for(let a=0;a<r.length;++a)s.push(r[a]===1?e[a+t]:r[a]);return s},Ng=(e,r)=>e.length>r.length?hd(e,r):hd(r,e),Ug=e=>{let r=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),s=Ng(r,t),a=e[0].dataType,f=a===9?4:1,p=X.size(s)/f,g=Le(r.length),u=Le(s.length),w=T=>{let x=g?r.length:r,O=u?s.length:s,k=te("input",a,x,f),P=se("output",a,O,f),D;if(a===9){let M=(z,G,L="")=>`
          let outputIndices${G} = ${P.offsetToIndices(`outputOffset + ${G}u`)};
          let offset${G} = ${k.broadcastedIndicesToOffset(`outputIndices${G}`,P)};
          let index${G} = offset${G} / 4u;
          let component${G} = offset${G} % 4u;
          ${z}[${G}] = ${L}(${k.getByOffset(`index${G}`)}[component${G}]);
        `;D=`
        let outputOffset = global_idx * ${f};
        var data = vec4<u32>(0);
        ${M("data",0,"u32")}
        ${M("data",1,"u32")}
        ${M("data",2,"u32")}
        ${M("data",3,"u32")}
        ${P.setByOffset("global_idx","data")}
      }`}else D=`
        let outputIndices = ${P.offsetToIndices("global_idx")};
        let inputOffset = ${k.broadcastedIndicesToOffset("outputIndices",P)};
        ${P.setByOffset("global_idx",k.getByOffset("inputOffset"))}
      }`;return`
    ${T.registerUniform("vec_size","u32").declareVariables(k,P)}
    ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${D}`},C=[{type:"uint32",data:p}];return g&&C.push(...Se(r)),u&&C.push(...Se(s)),{name:"Expand",shaderCache:{hint:`${s.length}`,inputDependencies:[g?"rank":"dims"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:C})}},md=e=>{Vg(e.inputs),e.compute(Ug(e.inputs),{inputs:[0]})}});var Hg,Lg,yd,bd,vd=oe(()=>{"use strict";Ze();ke();Fe();Re();Hg=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Lg=(e,r)=>{let t=e[0].dims,s=e[1].dims,a=t.length,f=X.normalizeAxis(r.axis,a),p=t.slice(0);p.splice(f,1,...s);let g=t[f],u=e[0].dataType===9?4:1,w=X.size(p)/u,C=Le(e[0].dims.length),T=C?e[0].dims.length:e[0].dims,x=Le(e[1].dims.length),O=x?e[1].dims.length:e[1].dims,k=Le(p.length),P=k?p.length:p,D=[{type:"uint32",data:w},{type:"int32",data:g},{type:"uint32",data:f}];C&&D.push(...Se(e[0].dims)),x&&D.push(...Se(e[1].dims)),k&&D.push(...Se(p));let M=[];M.push(C?"rank":"dims"),M.push(x?"rank":"dims");let z=G=>{let L=te("data",e[0].dataType,T,u),Y=te("inputIndices",e[1].dataType,O),A=se("output",e[0].dataType,P,u),Z=re=>{let fe=s.length,F=`var indicesIndices${re}  = ${Y.type.indices}(0);`;for(let ae=0;ae<fe;ae++)F+=`${fe>1?`indicesIndices${re}[${ae}]`:`indicesIndices${re}`} = ${p.length>1?`outputIndices${re}[uniforms.axis + ${ae}]`:`outputIndices${re}`};`;F+=`
          var idx${re} = ${Y.getByIndices(`indicesIndices${re}`)};
          if (idx${re} < 0) {
            idx${re} = idx${re} + uniforms.axisDimLimit;
          }
          var dataIndices${re} = ${L.type.indices}(0);
        `;for(let ae=0,_e=0;ae<a;ae++)ae===f?(F+=`${a>1?`dataIndices${re}[${ae}]`:`dataIndices${re}`} = u32(idx${re});`,_e+=fe):(F+=`${a>1?`dataIndices${re}[${ae}]`:`dataIndices${re}`} = ${p.length>1?`outputIndices${re}[${_e}]`:`outputIndices${re}`};`,_e++);return F},J;if(e[0].dataType===9){let re=(fe,F,ae="")=>`
          let outputIndices${F} = ${A.offsetToIndices(`outputOffset + ${F}u`)};
          ${Z(F)};
          let offset${F} = ${L.indicesToOffset(`dataIndices${F}`)};
          let index${F} = offset${F} / 4u;
          let component${F} = offset${F} % 4u;
          ${fe}[${F}] = ${ae}(${L.getByOffset(`index${F}`)}[component${F}]);
        `;J=`
        let outputOffset = global_idx * ${u};
        var value = vec4<u32>(0);
        ${re("value",0,"u32")}
        ${re("value",1,"u32")}
        ${re("value",2,"u32")}
        ${re("value",3,"u32")}
        ${A.setByOffset("global_idx","value")}
      `}else J=`
      let outputIndices = ${A.offsetToIndices("global_idx")};
      ${Z("")};
      let value = ${L.getByIndices("dataIndices")};
      ${A.setByOffset("global_idx","value")};
      `;return`
      ${G.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(L,Y,A)}
      ${G.mainStart()}
        ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${J}
      }`};return{name:"Gather",shaderCache:{hint:r.cacheKey,inputDependencies:M},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:D}),getShaderSource:z}},yd=e=>me({axis:e.axis}),bd=(e,r)=>{let t=e.inputs;Hg(t),e.compute(Lg(e.inputs,r))}});var Gg,Fg,wd,$d,Cd=oe(()=>{"use strict";ke();Fe();Re();Gg=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Fg=(e,r)=>{let t=e[0].dims,s=e[0].dataType,a=t.length,f=X.computeStrides(t),p=X.size(t),g=e[1].dims,u=e[1].dataType,w=X.size(g),C=X.normalizeAxis(r.axis,a),T=t[C],x=g.slice(0),O=X.size(x),k=te("input",s,t),P=te("indices",u,[w]),D=se("output",s,x),M=z=>`
      const inputStrides = array<u32, ${f.length}>(${f.map(G=>`${G}u`).join(",")});
      ${z.declareVariables(k,P,D)}
      ${z.mainStart()}
      ${z.guardAgainstOutOfBoundsWorkgroupSizes(O)}

      let outputIndices = ${D.offsetToIndices("global_idx")};

      var idx = ${P.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${T};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${t.length}; i++) {
        if (i == ${C}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${D.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${p}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)}}),getShaderSource:M}},wd=e=>me({axis:e.axis}),$d=(e,r)=>{let t=e.inputs;Gg(t),e.compute(Fg(e.inputs,r))}});var qg,Kg,Yg,_d,Sd,xd=oe(()=>{"use strict";ke();Fe();Re();qg=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Kg=(e,r,t)=>{if(t.length===0)return"0u";let s=t.length===1&&e!==1||t.length===2&&t[0]!==e,a=t[t.length-1]!==r,f="0u";return s||(f+=`+ m * ${t[t.length-1]}u`),a||(f+="+n"),f},Yg=(e,r)=>{let t=e[0].dims.slice(),s=e[1].dims.slice(),[a,f,p]=vn.getShapeOfGemmResult(t,r.transA,s,r.transB,e.length===3?e[2].dims:void 0),g=[a,f];if(!g)throw new Error("Can't use gemm on the given tensors");let u=X.size(g),w="";r.transA&&r.transB?w="value += a[k * M + m] * b[n * K + k];":r.transA&&!r.transB?w="value += a[k * M + m] * b[k * N + n];":!r.transA&&r.transB?w="value += a[m * K + k] * b[n * K + k];":!r.transA&&!r.transB&&(w="value += a[m * K + k] * b[k * N + n];");let C=De(e[0].dataType),T=r.alpha===1?"":"value *= alpha;",x=e.length===3?`value += beta * c[${Kg(a,f,e[2].dims)}];`:"",O=[`@group(0) @binding(0) var<storage, read> a : array<${C}>;`,`@group(0) @binding(1) var<storage, read> b : array<${C}>;`];e.length===3&&O.push(`@group(0) @binding(2) var<storage, read> c : array<${C}>;`);let k=P=>`
  const M: u32 = ${a}u;
  const N: u32 = ${f}u;
  const K: u32 = ${p}u;
  const alpha = ${C}(${r.alpha});
  const beta = ${C}(${r.beta});

  ${O.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${C}>;

  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${C}(0);
    for (var k: u32 = 0u; k<${p}u; k++) {
      ${w}
    }

    ${T}
    ${x}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:g,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:k}},_d=(e,r)=>{qg(e.inputs),e.compute(Yg(e.inputs,r))},Sd=e=>me(e)});var Xg,Zg,Qg,Jg,Id,Ad,Ed=oe(()=>{"use strict";Ze();ke();Fe();Re();Xg={name:"InstanceNormalization"},Zg=(e,r)=>{let t=e[0].dims,s=t,a=2,f=X.sizeToDimension(t,a),p=X.sizeFromDimension(t,a),g=t[1],u=te("x",e[0].dataType,[t[0],t[1],p]),w=te("scale",e[1].dataType,e[1].dims),C=te("bias",e[2].dataType,e[2].dims),T=se("output",e[0].dataType,[t[0],t[1],p]),x=[u,w,C,T],O=u.type.value,k=64,P=D=>`

  const C: u32 = ${g};
  const normSize: u32 = ${p};
  const epsilon: f32 = ${r.epsilon};
  var<workgroup> meanShared : ${O};
  var<workgroup> squaredNormShared : ${O};
  var<workgroup> workgroupShared : array<${O}, ${k}>;
  const workgroupSize = ${k}u;
  ${D.declareVariables(...x)}
  ${D.mainStart(k)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${O} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${u.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${O}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${u.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${O}(normSize) + epsilon);
    let channelScale = invStdDev * ${w.getByOffset("channel")};
    let channelShift = ${C.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${u.get("batch","channel","h")} * channelScale + channelShift;
      ${T.set("batch","channel","h","value")};
    }
  }`;return{...Xg,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:f}}),getShaderSource:P}},Qg=(e,r,t,s,a,f,p,g)=>{let u=ft(p),w=te("input",r.dataType,r.dims,u),C=te("scale",t.dataType,t.dims,u),T=te("bias",s.dataType,s.dims,u),x=64,O=u===1?"vec2f":`mat2x${u}f`,k=u===1?"f32":`vec${u}f`,P=(Y,A)=>`${O}(${Y}, ${A})`,D=a*p/u,M=Math.ceil(f/x),z=Y=>`
  const H: u32 = ${f};
  const C: u32 = ${p/u};
  const imageSize: u32 = ${f*p/u};

  ${Y.declareVariables(w)}
  @group(0) @binding(1) var<storage, read_write> output : array<${O}>;

  ${Y.mainStart(x)}
    let currentImageNumber = global_idx / ${x} / C;
    let currentChannelNumber = (global_idx / ${x}) % C;
    let wgId = global_idx % ${x};
    let wgOffset = wgId * ${M};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${M}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${st("f32",u)};
    var squaredSum = ${st("f32",u)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${k}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${P("sum","squaredSum")};
  }`,G=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:a,h:f,c:p})},getRunData:()=>({outputs:[{dims:[a,p,x,2],dataType:1}],dispatchGroup:{x:a*p/u}}),getShaderSource:z},{inputs:[r],outputs:[-1]})[0],L=Y=>`
  const H: u32 = ${f};
  const C: u32 = ${p/u};
  const imageSize: u32 = ${x*p/u};
  const epsilon: f32 = ${g};

  @group(0) @binding(0) var<storage, read> input : array<${O}>;
  @group(0) @binding(1) var<storage, read> scale : array<${C.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${T.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${O}>;

  ${Y.mainStart()}
    ${Y.guardAgainstOutOfBoundsWorkgroupSizes(D)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${st("f32",u)};
    var squaredSum = ${st("f32",u)};
    for (var i: u32 = 0; i < ${x}; i++) {
        let value = input[offset + i + currentChannelNumber * ${x}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${k}(scale[currentChannelNumber]);
    let channelShift = ${k}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${P("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:a,h:f,c:p,epsilon:g})},getRunData:()=>({outputs:[{dims:[a,p,2],dataType:1}],dispatchGroup:{x:Math.ceil(D/64)}}),getShaderSource:L},{inputs:[G,t,s],outputs:[-1]})[0]},Jg=(e,r,t)=>{let s=r[0].dims,a=s,f=s[0],p=s[s.length-1],g=X.sizeFromDimension(s,1)/p,u=ft(p),w=X.size(a)/u,C=te("input",r[0].dataType,r[0].dims,u),T=se("output",r[0].dataType,a,u),x=De(r[0].dataType),O=u===1?"vec2f":`mat2x${u}f`,k=u===1?x:`vec${u}<${x}>`,P=Qg(e,r[0],r[1],r[2],f,g,p,t.epsilon),D=M=>`
  const H: u32 = ${g};
  const C: u32 = ${p/u};

  @group(0) @binding(0) var<storage, read> input : array<${C.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${O}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${T.type.storage}>;

  ${M.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${k}(scale[0]), ${k}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${t.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:D},{inputs:[r[0],P]})},Id=e=>me({epsilon:e.epsilon,format:e.format}),Ad=(e,r)=>{r.format==="NHWC"?Jg(e,e.inputs,r):e.compute(Zg(e.inputs,r))}});var ey,ty,Td,Od,kd=oe(()=>{"use strict";Ze();ke();Fe();Re();ey=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ty=(e,r,t)=>{let s=e[0].dims,a=e[1],f=e[2],p=s,g=X.normalizeAxis(r.axis,s.length),u=X.sizeToDimension(s,g),w=X.sizeFromDimension(s,g),C=X.size(a.dims),T=f?X.size(f.dims):0;if(C!==w||f&&T!==w)throw new Error(`Size of X.shape()[axis:] == ${w}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${C} and bias size of ${T}`);let x=[];for(let L=0;L<s.length;++L)L<g?x.push(s[L]):x.push(1);let O=ft(w),k=De(e[0].dataType),P=[te("x",e[0].dataType,e[0].dims,O),te("scale",a.dataType,a.dims,O)];f&&P.push(te("bias",f.dataType,f.dims,O)),P.push(se("output",e[0].dataType,p,O));let D=t>1,M=t>2;D&&P.push(se("meanDataOutput",1,x)),M&&P.push(se("invStdOutput",1,x));let z=L=>`
  const normSize: f32 = ${w};
  const normSizeVectorized: u32 = ${w/O};
  const epsilon: f32 = ${r.epsilon};

  ${L.declareVariables(...P)}
  ${L.mainStart()}
    ${L.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${st("f32",O)};
    var meanSquareVector = ${st("f32",O)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${_t(k,O,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${St("meanVector",O)} / normSize;
    let meanSquare = sqrt(${St("meanSquareVector",O)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${_t(k,O,"x[j + offset]")};
      let f32scale = ${_t(k,O,"scale[j]")};
      output[j + offset] = ${P[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${f?`+ ${_t(k,O,"bias[j]")}`:""}
      );
    }

    ${D?"meanDataOutput[global_idx] = mean":""};
    ${M?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,G=[{dims:p,dataType:e[0].dataType}];return D&&G.push({dims:x,dataType:1}),M&&G.push({dims:x,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${r.cacheKey}|${t}|${e.length}`},getRunData:()=>({outputs:G,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:z}},Td=e=>me({axis:e.axis,epsilon:e.epsilon}),Od=(e,r)=>{ey(e.inputs),e.compute(ty(e.inputs,r,e.outputCount))}});var ry,Rd,Pd=oe(()=>{"use strict";ke();Oi();ry=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Rd=e=>{ry(e.inputs);let r=Rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!r)throw new Error("Can't use matmul on the given tensors");e.compute(kn(e.inputs,{activation:"",activationCacheKey:""},r))}});var iy,Md,Bd,ny,_a,jd,Dd=oe(()=>{"use strict";ke();Fe();yn();ca();Re();jr();iy=(e,r)=>{let t=e[0],s=e[1],a=e[2],f=e[3],p=e[4],g=e[5],u=e[6],w=e[7];if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let C=!1,T=t.dims[0],x=t.dims[1],O=t.dims.length===3?C?t.dims[2]/3:t.dims[2]:r.numHeads*t.dims[4],k=x,P=0,D=0,M=Math.floor(O/r.numHeads);if(u&&w){if(u.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(w.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');P=u.dims[2],D=u.dims[2]}else if(u||w)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let z;if(s){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==t.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');z=2,k=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==r.numHeads||s.dims[3]!==2||s.dims[4]!==M)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');z=5,k=s.dims[1]}else{if(s.dims[1]!==r.numHeads||s.dims[3]!==M)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');z=0,k=s.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(t.dims.length===5&&(t.dims[2]!==r.numHeads||t.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');z=3}if(f){if(f.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(a&&t.dims.length===5&&t.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let G=0;if(p){G=8;let J=p.dims;throw J.length===1?J[0]===T?G=1:J[0]===3*T+2&&(G=3):J.length===2&&J[0]===T&&J[1]===k&&(G=5),G===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let L=!1,Y=O;if(a){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(k!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');Y=a.dims[2]}else{if(k!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');Y=a.dims[1]*a.dims[3],L=!0}}let A=P+k,Z=!1;if(p)throw new Error("Key padding mask is not supported");if(g)throw new Error("extraAddQk is not supported");if(u)throw new Error("pastKey is not supported");if(w)throw new Error("pastValue is not supported");return{batchSize:T,sequenceLength:x,pastSequenceLength:P,kvSequenceLength:k,totalSequenceLength:A,maxSequenceLength:D,inputHiddenSize:0,hiddenSize:O,vHiddenSize:Y,headSize:M,vHeadSize:Math.floor(Y/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:G,scale:r.scale,broadcastResPosBias:Z,passPastInKv:L,qkvFormat:z}},Md=e=>me({...e}),Bd=me({perm:[0,2,1,3]}),ny=(e,r,t,s,a,f,p)=>{let g=[s,a,f],u=X.size(g),w=De(r.dataType),C=T=>`
  const biasOffset = ${p}u;
  const hiddenSize = ${f}u;

  @group(0) @binding(0) var<storage, read> qkv: array<${w}>;
  @group(0) @binding(1) var<storage, read> bias: array<${w}>;
  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${w}>;

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];
  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:s,sequenceLength:a,hiddenSize:f,biasOffset:p})},getRunData:()=>({outputs:[{dims:g,dataType:r.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:C},{inputs:[r,t],outputs:[-1]})[0]},_a=(e,r,t,s,a,f,p,g)=>{let u=f;if(p){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=ny(e,f,p,r,s,t*a,g),u=u.reshape([r,s,t,a]),e.compute(xt(u,Bd.perm),{inputs:[u],outputs:[-1]})[0]}else return f.dims.length===3&&(u=f.reshape([r,s,t,a])),e.compute(xt(u,Bd.perm),{inputs:[u],outputs:[-1]})[0]},jd=(e,r)=>{let t=iy(e.inputs,r);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let s=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,a=_a(e,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,e.inputs[0],e.inputs[3],0);if(s)return Sn(e,a,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],t,r);let f=_a(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,e.inputs[1],e.inputs[3],t.hiddenSize),p=_a(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,e.inputs[2],e.inputs[3],2*t.hiddenSize);Sn(e,a,f,p,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],t,r)}});var ay,oy,sy,uy,ly,dy,cy,fy,py,zd,Wd,Vd=oe(()=>{"use strict";Ze();ke();Fe();Re();ay=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let r=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(r=e[3].dims[0]*2===e[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},oy=(e,r,t,s,a,f)=>{let p=r.length,g="";for(let u=p-1;u>=0;--u)g+=`
            k = i32(${e.indicesGet("indices",u)}) - ${s[u]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[u]}) {
              break;
            }
            offset += k * ${t[u]};
        `;return`
          value = ${a}(${f});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${g}
            value = x[offset];
          }
      `},sy=(e,r,t,s)=>{let a=r.length,f="";for(let p=a-1;p>=0;--p)f+=`
                k = i32(${e.indicesGet("indices",p)}) - ${s[p]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[p]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[p]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${t[p]};
            `;return`
              var offset = 0;
              var k = 0;
              ${f}
              value = x[offset];
          `},uy=(e,r,t,s)=>{let a=r.length,f="";for(let p=a-1;p>=0;--p)f+=`
                k = i32(${e.indicesGet("indices",p)}) - ${s[p]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[p]}) {
                  k = ${r[p]-1};
                }
                offset += k * ${t[p]};
            `;return`
              var offset = 0;
              var k = 0;
              ${f}
              value = x[offset];
          `},ly=(e,r,t,s)=>{let a=r.length,f="";for(let p=a-1;p>=0;--p)f+=`
                k = i32(${e.indicesGet("indices",p)}) - ${s[p]};
                if (k < 0)  {
                  k += ${r[p]};
                }
                if (k >= ${r[p]}) {
                  k -= ${r[p]};
                }
                offset += k * ${t[p]};
            `;return`
              var offset = 0;
              var k = 0;
              ${f}
              value = x[offset];
          `},dy=(e,r,t,s,a)=>{switch(s.mode){case 0:return oy(e,r,t,s.pads,a,s.value);case 1:return sy(e,r,t,s.pads);case 2:return uy(e,r,t,s.pads);case 3:return ly(e,r,t,s.pads);default:throw new Error("Invalid mode")}},cy=(e,r,t,s)=>{let a=r[0].dims,f=X.padShape(a.slice(),t.pads),p=X.size(f),g=X.computeStrides(a),u=se("output",r[0].dataType,f),w=te("x",r[0].dataType,a),C=dy(u,a,g,t,s);return`
              ${e.declareVariables(w,u)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}

              let indices = ${u.offsetToIndices("global_idx")};

              var value = ${s}(0);
              ${C}
              output[global_idx] = value;
          }`},fy=(e,r)=>{let t=X.padShape(e[0].dims.slice(),r.pads);return{name:"Pad",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(X.size(t)/64)}}),getShaderSource:s=>cy(s,e,r,"f32")}},py=(e,r)=>{if(e.length>1){let t=e[1].getBigInt64Array(),s=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,f=new Int32Array(2*a).fill(0);if(e.length>=4){let g=e[3].getBigInt64Array();for(let u=0;u<g.length;u++)f[Number(g[u])]=Number(t[u]),f[Number(g[u])+a]=Number(t[u+g.length])}else t.forEach((g,u)=>f[Number(u)]=Number(g));let p=[];return f.forEach(g=>p.push(g)),me({mode:r.mode,value:s,pads:p})}else return r},zd=(e,r)=>{ay(e.inputs);let t=py(e.inputs,r);e.compute(fy(e.inputs,t),{inputs:[0]})},Wd=e=>{let r=e.mode,t=e.value,s=e.pads;return me({mode:r,value:t,pads:s})}});var Pn,Nd,Ud,Hd,Ld,Gd,Fd,qd,Kd,Yd,Xd,Zd,Qd,Jd,ec,tc=oe(()=>{"use strict";ke();Fe();Re();Pn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Nd=(e,r,t)=>{let s=r.format==="NHWC",a=e.dims.slice();s&&a.splice(1,0,a.pop());let f=Object.hasOwnProperty.call(r,"dilations"),p=r.kernelShape.slice(),g=r.strides.slice(),u=f?r.dilations.slice():[],w=r.pads.slice();lr.adjustPoolAttributes(t,a,p,g,u,w);let C=lr.computePoolOutputShape(t,a,g,u,p,w,r.autoPad),T=Object.assign({},r);f?Object.assign(T,{kernelShape:p,strides:g,pads:w,dilations:u,cacheKey:r.cacheKey}):Object.assign(T,{kernelShape:p,strides:g,pads:w,cacheKey:r.cacheKey});let x=C.slice();return x.push(x.splice(1,1)[0]),[T,s?x:C]},Ud=(e,r,t,s,a,f,p,g)=>{let u=a.format==="NHWC",w=t,C=r.type.value,T=w.length,x=X.size(s),O=se("output",r.type.tensor,s);if(a.kernelShape.length<=2){let k=a.kernelShape[a.kernelShape.length-1],P=a.strides[a.strides.length-1],D=a.pads[a.pads.length/2-1],M=a.pads[a.pads.length-1],z=T-(u?2:1),G="",L="",Y="";if(D+M!==0?G=`
                for (var i: u32 = 0u; i < ${k}u; i++) {
                  xIndices[${z}] = indices[${z}] * ${P} - ${D} + i;
                  if (xIndices[${z}] < 0 || xIndices[${z}] >= ${w[z]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${r.indicesToOffset("xIndices")}];
                  ${f}
                }`:G=`
                for (var i: u32 = 0u; i < ${k}u; i++) {
                  xIndices[${z}] = indices[${z}] * ${P} - ${D} + i;
                  let x_val = x[${r.indicesToOffset("xIndices")}];
                  ${f}
                }`,a.kernelShape.length===2){let Z=a.kernelShape[a.kernelShape.length-2],J=a.strides[a.strides.length-2],re=a.pads[a.pads.length/2-2],fe=a.pads[a.pads.length-2],F=T-(u?3:2),ae=w[F];re+fe!==0?L=`
                for (var j: u32 = 0u; j < ${Z}u; j++) {
                  xIndices[${F}] = indices[${F}] * ${J} - ${re} + j;
                  if (xIndices[${F}] < 0 || xIndices[${F}] >= ${ae}) {
                    pad+= ${k};
                    continue;
                  }
              `:L=`
                for (var j: u32 = 0u; j < ${Z}u; j++) {
                  xIndices[${F}] = indices[${F}] * ${J} - ${re} + j;
                `,Y=`
              }
            `}return`
            ${e.declareVariables(r,O)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}

              let indices = ${O.offsetToIndices("global_idx")};
              var xIndices = ${O.offsetToIndices("global_idx")};

              var value: ${C} = ${C}(${g});
              var pad = 0;
              ${L}
              ${G}
              ${Y}
              ${p}

              output[global_idx] = value;
            }`}else{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let k=X.size(a.kernelShape),P=X.computeStrides(a.kernelShape),D=P.length,M=a.pads.length,z=a.pads.reduce((Y,A)=>Y+A),G="";return z?G=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${r.indicesToOffset("xIndices")}];
                ${f}
              }`:G=`
              }
              let x_val = x[${r.indicesToOffset("xIndices")}];
              ${f}
            `,`
            ${e.declareVariables(r,O)}

            const pads = array<u32, ${M}>(${a.pads.map(Y=>`${Y}u`).join(",")});
            const inputDims = array<u32, ${T}>(${w.map(Y=>`${Y}u`).join(",")});
            const kernelStrides = array<u32, ${D}>(${P.map(Y=>`${Y}u`).join(",")});
            const strides = array<u32, ${D}>(${a.strides.map(Y=>`${Y}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}

              let indices = ${O.offsetToIndices("global_idx")};
              let xIndices = ${O.offsetToIndices("global_idx")};

              var offsets: array<u32, ${D}>;

              var value = ${O.type.value}(${g});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${k}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${D-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${D-1}] = offset;

                isPad = false;
                for (var j = ${T-D}u; j < ${T}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${T-D}u]
                    + offsets[j - ${T-D}u] - pads[j - 2u];
                  ${G}
              }
              ${p}

              output[global_idx] = value;
            }`}},Hd=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ld=(e,r,t,s)=>{let[a,f]=Nd(r,s,t),p=X.size(a.kernelShape),g=te("x",r.dataType,r.dims),u=g.type.value,w="value += x_val;",C="";return a.countIncludePad?C+=`value /= ${u}(${p});`:C+=`value /= ${u}(${p} - pad);`,{name:e,shaderCache:{hint:s.cacheKey},getRunData:()=>({outputs:[{dims:f,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(X.size(f)/64)}}),getShaderSource:T=>Ud(T,g,r.dims,f,a,w,C,"0.0")}},Gd=e=>{let r=e.count_include_pad!==0,t=Hd(e);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return me({countIncludePad:r,...t})},Fd=(e,r)=>{Pn(e.inputs),e.compute(Ld("AveragePool",e.inputs[0],!1,r))},qd={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Kd=e=>{let r=e.format;return{format:r,...qd,cacheKey:r}},Yd=(e,r)=>{Pn(e.inputs),e.compute(Ld("GlobalAveragePool",e.inputs[0],!0,r))},Xd=(e,r,t,s)=>{let[a,f]=Nd(r,s,t),p=`
      value = max(x_val, value);
    `,g="",u=te("x",r.dataType,r.dims);return{name:e,shaderCache:{hint:s.cacheKey},getRunData:()=>({outputs:[{dims:f,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(X.size(f)/64)}}),getShaderSource:w=>Ud(w,u,r.dims,f,a,p,g,"-1e5")}},Zd=(e,r)=>{Pn(e.inputs),e.compute(Xd("MaxPool",e.inputs[0],!1,r))},Qd=e=>{let r=e.storage_order,t=e.dilations,s=Hd(e);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return me({storageOrder:r,dilations:t,...s})},Jd=e=>{let r=e.format;return{format:r,...qd,cacheKey:r}},ec=(e,r)=>{Pn(e.inputs),e.compute(Xd("GlobalMaxPool",e.inputs[0],!0,r))}});var my,gy,rc,ic=oe(()=>{"use strict";Ut();Ze();Re();my=(e,r,t)=>{let s=e===r,a=e<r&&t<0,f=e>r&&t>0;if(s||a||f)throw new Error("Range these inputs' contents are invalid.")},gy=(e,r,t,s)=>{let a=Math.abs(Math.ceil((r-e)/t)),f=[a],p=a,g=se("output",s,f),u=g.type.storage,w=C=>`
        ${C.declareVariables(g)}
        ${C.mainStart()}
        ${C.guardAgainstOutOfBoundsWorkgroupSizes(p)}
        output[global_idx] = ${u}(${e}) + ${u}(global_idx) * ${u}(${t});
      }`;return{name:"Range",shaderCache:{hint:[e,r,t].map(C=>C.toString()).join("_")},getShaderSource:w,getRunData:()=>({outputs:[{dims:f,dataType:s}],dispatchGroup:{x:Math.ceil(p/64)}})}},rc=e=>{let r=0,t=0,s=0;e.inputs[0].dataType===6?(r=e.inputs[0].getInt32Array()[0],t=e.inputs[1].getInt32Array()[0],s=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(r=e.inputs[0].getFloat32Array()[0],t=e.inputs[1].getFloat32Array()[0],s=e.inputs[2].getFloat32Array()[0]),Ve.webgpu.validateInputContent&&my(r,t,s),e.compute(gy(r,t,s,e.inputs[0].dataType),{inputs:[]})}});var yy,by,vy,wy,$y,Cy,_y,Sy,xy,Iy,Ay,Ey,Ty,Oy,ky,nc,ac,oc=oe(()=>{"use strict";ke();Fe();Re();yy=(e,r)=>{if(e.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(r.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(r.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},by=(e,r,t)=>{r.every(a=>a>=0&&a<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(t).fill(1);return r.forEach((a,f)=>s[a]=e[f]),s},vy=(e,r,t,s,a,f)=>{let[p,g,u]=t>10?[1,2,3]:[-1,e.length>1?1:-1,-1],w=e[0].dims.length;if(p>0&&e.length>p&&e[p].dims.length>0)e[p].getFloat32Array().forEach(C=>f.push(C));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(g>0&&e.length>g&&e[g].dims.length>0){if(e[g].getFloat32Array().forEach(C=>s.push(C)),s.length!==0&&s.length!==w&&t>=18&&s.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");yy(s,r),r.axes.length>0&&by(s,r.axes,w).forEach((C,T)=>s[T]=C)}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach(C=>a.push(Number(C))),a.length!==w||t>=18&&a.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(s.length!==r.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==r.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof a<"u"&&s.length>0&&a.length>w)throw new Error("Resize requires only of scales or sizes to be specified")},wy=(e,r)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${r}, xScale: ${r}, lengthResized: ${r},
     lengthOriginal: ${r}, roiStart: ${r}, roiEnd: ${r}) -> ${r} { `+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${r}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",$y=(e,r,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Cy=(e,r,t)=>{let s=new Array(t).fill(0).concat(new Array(t).fill(1)),a=e.length===0?s:e.slice();return r.length>0?(r.forEach((f,p)=>{s[f]=a[p],s[p+t]=a[r.length+p]}),s):a},_y=(e,r,t,s)=>{let a=[];if(t.length>0)if(s.length>0){if(e.forEach(f=>a.push(f)),Math.max(...s)>e.length)throw new Error("axes is out of bound");s.forEach((f,p)=>a[f]=t[p])}else t.forEach(f=>a.push(f));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((f,p)=>Math.round(f*r[p]))}return a},Sy=(e,r,t)=>{let s=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(f=>r[f]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(f=>r[f]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let a=e.slice();return t.axes.length>0?(t.axes.forEach(f=>r[f]=s),t.axes.forEach(f=>a[f]=Math.round(e[f]*r[f]))):(r.fill(s,0,r.length),a.forEach((f,p)=>a[p]=Math.round(f*r[p]))),a},xy=(e,r,t,s,a)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<${e.type.value}, ${t.length}> {
      const inputShape = array<u32, ${r.length}>(${r.map(f=>`${f}u`).join(",")});
      const outputShape = array<u32, ${t.length}>(${t.map(f=>`${f}u`).join(",")});
      const scales = array<${e.type.value}, ${s.length}>(${s.map(f=>`${f}f`).join(",")});
      const roi = array<${e.type.value}, ${a.length}>(${a.map(f=>`${f}f`).join(",")});
      var originalIndices: array<${e.type.value}, ${t.length}>;
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = ${e.type.value}(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(${e.type.value}(outputIndex), scales[i],
                ${e.type.value}(outputShape[i]), ${e.type.value}(inputShape[i]), roi[i], roi[i + ${r.length}]);
        }
      }
      return originalIndices;
    }`,Iy=(e,r,t,s,a,f,p)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${t.length}>(${t.map(g=>`${g}u`).join(",")});
        const outputShape = array<u32, ${s.length}>(${s.map(g=>`${g}u`).join(",")});
        const scales = array<${e.type.value}, ${a.length}>(${a.map(g=>`${g}`).join(",")});
        const roi = array<${e.type.value}, ${f.length}>(${f.map(g=>`${g}`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${s.length}; i++) {
          var outputIndex = ${s.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(${e.type.value}(outputIndex), scales[i],
                    ${e.type.value}(outputShape[i]), ${e.type.value}(inputShape[i]), roi[i], roi[i + ${t.length}]);
            if (!${p} || (original_idx >= 0 && original_idx < ${e.type.value}(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (${e.type.value}(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,Ay=(e,r)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${r.length}>(${r.map(t=>`${t}u`).join(",")});
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var inputIndex = ${r.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,Ey=(e,r,t,s,a,f)=>{let[p,g,u,w]=t.length===2?[-1,0,1,-1]:s[1]===1?[0,2,3,1]:[0,1,2,3],C=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${C} {
      var inputIndices: ${e.type.indices};
      inputIndices[${g}] = max(0, min(row, ${t[g]} - 1));
      inputIndices[${u}] = max(0, min(col, ${t[u]} - 1));
      if (${t.length} > 2) {
        inputIndices[${w}] = channel;
        inputIndices[${p}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${r.type.indices}) -> ${C} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:${C} = originalIndices[${g}];
      var col:${C} = originalIndices[${u}];
      if (${a} && (row < 0 || row > (${t[g]} - 1) || col < 0 || col > ${t[u]} - 1)) {
        return ${f};
      }
      row = max(0, min(row, ${t[g]} - 1));
      col = max(0, min(col, ${t[u]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${t.length>2}) {
        channel = u32(originalIndices[${w}]);
        batch = u32(originalIndices[${p}]);
      }
      var x11: ${C} = getInputValue(batch, channel, row1, col1);
      var x12: ${C} = getInputValue(batch, channel, row1, col2);
      var x21: ${C} = getInputValue(batch, channel, row2, col1);
      var x22: ${C} = getInputValue(batch, channel, row2, col2);
      var dx1: ${C} = row - ${C}(row1);
      var dx2: ${C} = ${C}(row2) - row;
      var dy1 = col - ${C}(col1);
      var dy2 = ${C}(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Ty=(e,r,t,s,a,f,p,g,u,w)=>{let[C,T]=t.length===2?[0,1]:a[1]===1?[2,3]:[1,2],x=e.type.value,O=k=>{let P=k===C?"row":"col";return`
      fn ${P}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${r.type.indices}) -> ${x} {
        var outputIndex = ${s.length===1?"outputIndices":`outputIndices[${k}]`};
        var originalIdx: ${x} = getOriginalCoordinateFromResizedCoordinate(${x}(outputIndex), ${a[k]},
        ${x}(${s[k]}), ${x}(${t[k]}), ${f[k]}, ${f[k]} + ${t.length});
        var fractOriginalIdx: ${x} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${g} && (originalIdx < 0 || originalIdx > (${t[k]} - 1))) {
          return ${u};
        }
        var data: array<${x}, 4> = array<${x}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${P}: ${x} = originalIdx + ${x}(i);
          if (${P} < 0 || ${P} >= ${t[k]}) {
            if (${w}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${g}) {
              return ${u};
            } else {
              ${P} = max(0, min(${P}, ${t[k]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${k}] = u32(${P});
          data[i + 1] = ${k===C?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${O(C)};
    ${O(T)};
  fn getCubicInterpolationCoefs(s: ${x}) -> array<${x}, 4> {
    var absS = abs(s);
    var coeffs: array<${x}, 4> = array<${x}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${x} = 1.0 - absS;
    var twoMinusAbsS: ${x} = 2.0 - absS;
    var onePlusAbsS: ${x} = 1.0 + absS;
    coeffs[0] = ((${p} * onePlusAbsS - 5 * ${p}) * onePlusAbsS + 8 * ${p}) * onePlusAbsS - 4 * ${p};
    coeffs[1] = ((${p} + 2) * absS - (${p} + 3)) * absS * absS + 1;
    coeffs[2] = ((${p} + 2) * oneMinusAbsS - (${p} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${p} * twoMinusAbsS - 5 * ${p}) * twoMinusAbsS + 8 * ${p}) * twoMinusAbsS - 4 * ${p};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${x}, 4>, coefs: array<${x}, 4>) -> ${x} {
    var coefsSum: ${x} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${r.type.indices}) -> ${x} {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},Oy=(e,r,t,s,a,f)=>{let p=e.dims,g=Cy(f,r.axes,p.length),u=_y(p,s,a,r.axes),w=s.slice();s.length===0&&(w=p.map((M,z)=>M===0?1:u[z]/M),r.keepAspectRatioPolicy!=="stretch"&&(u=Sy(p,w,r)));let C=se("output",e.dataType,u),T=te("input",e.dataType,p),x=X.size(u),O=p.length===u.length&&p.every((M,z)=>M===u[z]),k=r.coordinateTransformMode==="tf_crop_and_resize",P=T.type.value,D=M=>`
      ${O?"":`
      ${wy(r.coordinateTransformMode,P)};
      ${(()=>{switch(r.mode){case"nearest":return`
              ${Ay(T,p)};
              ${$y(r.nearestMode,t,P)};
              ${Iy(T,C,p,u,w,g,k)};
              `;case"linear":return`
              ${xy(C,p,u,w,g)};
              ${Ey(T,C,p,w,k,r.extrapolationValue)};
              `;case"cubic":return`
            ${Ty(T,C,p,u,w,g,r.cubicCoeffA,k,r.extrapolationValue,r.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${M.declareVariables(T,C)}
      ${M.mainStart()}
        ${M.guardAgainstOutOfBoundsWorkgroupSizes(x)}
        ${O?"output[global_idx] = input[global_idx];":`
        let outputIndices = ${C.offsetToIndices("global_idx")};
        var inputIndices: ${T.type.indices};
        ${(()=>{switch(r.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                if (checkInputIndices(inputIndices)) {
                  output[global_idx] = input[${T.indicesToOffset("inputIndices")}];
                } else {
                  output[global_idx] = ${r.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${t}|${w.length>0?w:""}|${a.length>0?a:""}|${O}`},getShaderSource:D,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(x/64)}})}},ky=e=>{let r=e.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},nc=(e,r)=>{let t=[],s=[],a=[],f=ky(e);vy(e.inputs,r,f,t,s,a),e.compute(Oy(e.inputs[0],r,f,t,s,a),{inputs:[0]})},ac=e=>{let r=e.antialias,t=e.axes,s=e.coordinateTransformMode,a=e.cubicCoeffA,f=e.excludeOutside!==0,p=e.extrapolationValue,g=e.keepAspectRatioPolicy,u=e.mode,w=e.nearestMode===""?"simple":e.nearestMode;return me({antialias:r,axes:t,coordinateTransformMode:s,cubicCoeffA:a,excludeOutside:f,extrapolationValue:p,keepAspectRatioPolicy:g,mode:u,nearestMode:w})}});var Ry,Py,sc,uc,lc=oe(()=>{"use strict";Ze();ke();Fe();Re();Ry=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=e[0],t=e[1],s=e[2];if(r.dataType!==t.dataType||r.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=r.dims[r.dims.length-1],f=r.dims[r.dims.length-2];if(t.dims[t.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==f)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let p=e[3];if(p.dims.length!==1)throw new Error("Beta must be 1D");if(p.dims[p.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let p=e[4];if(p.dims.length!==1)throw new Error("Bias must be 1D");if(p.dims[p.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Py=(e,r,t,s)=>{let a=e[0].dims,f=X.size(a),p=a,g=f,u=a.slice(-1)[0],w=s?a.slice(0,-1).concat(1):[],C=e.length>3,T=e.length>4,x=s&&t>1,O=s&&t>2,k=t>3,P=ft(u),D=[te("x",e[0].dataType,e[0].dims,P),te("skip",e[1].dataType,e[1].dims,P),te("gamma",e[2].dataType,e[2].dims,P)];C&&D.push(te("beta",e[3].dataType,e[3].dims,P)),T&&D.push(te("bias",e[4].dataType,e[4].dims,P)),D.push(se("output",e[0].dataType,p,P)),x&&D.push(se("meanOutput",1,w)),O&&D.push(se("invStdOutput",1,w)),k&&D.push(se("inputSkipBiasSum",e[0].dataType,p,P));let M=De(e[0].dataType),z=L=>`
      const hiddenSize: f32 = ${u};
      const hiddenSizeVectorized: u32 = ${u/P};
      const epsilon: f32 = ${r.epsilon};

      ${L.declareVariables(...D)}

      ${L.mainStart()}
        ${L.guardAgainstOutOfBoundsWorkgroupSizes(g/u)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${st("f32",P)};
        var squareSum = ${st("f32",P)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${T?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${k?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${_t(M,P,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${St("sum",P)} / hiddenSize;
        let variance = sqrt(${St("squareSum",P)} / hiddenSize - mean * mean + epsilon);
        ${x?"meanOutput[global_idx] = mean;":""}
        ${O?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${M}(mean)) / ${M}(variance) * gamma[i]
           + ${C?"beta[i]":"0.0"};
        }
      }`,G=[{dims:p,dataType:e[0].dataType}];return t>1&&G.push({dims:w,dataType:1}),t>2&&G.push({dims:w,dataType:1}),t>3&&G.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:r.cacheKey},getShaderSource:z,getRunData:()=>({outputs:G,dispatchGroup:{x:Math.ceil(g/u/64)}})}},sc=(e,r)=>{Ry(e.inputs);let s=[0];e.outputCount>1&&s.push(-3),e.outputCount>2&&s.push(-3),e.outputCount>3&&s.push(3),e.compute(Py(e.inputs,r,e.outputCount,!1),{outputs:s})},uc=e=>{let r=e.epsilon;return me({epsilon:r})}});var By,Bn,My,dc,jy,Dy,cc,fc,pc=oe(()=>{"use strict";Ze();ke();Fe();Re();By=(e,r)=>{if(!e||e.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,s)=>{if(e[s+1].dataType!==6&&e[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},Bn=(e,r)=>{let t=[];if(e.length>r)if(e[r].dataType===7)e[r].getBigInt64Array().forEach(s=>t.push(Number(s)));else if(e[r].dataType===6)e[r].getInt32Array().forEach(s=>t.push(Number(s)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return t},My=(e,r)=>{if(e.length>1){let t=Bn(e,1),s=Bn(e,2),a=Bn(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),me({starts:t,ends:s,axes:a})}else return r},dc=(e,r,t,s,a)=>{let f=e;return e<0&&(f+=t[s[r]]),a[r]<0?Math.max(0,Math.min(f,t[s[r]]-1)):Math.max(0,Math.min(f,t[s[r]]))},jy=(e,r,t,s)=>`fn calculateInputIndices(outputIndices: ${r.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${t.length}; i >= 0; i--) {
            let input_shape_i = ${Pt("uniforms.input_shape","i",t.length)};
            let steps_i = ${Pt("uniforms.steps","i",t.length)};
            let signs_i = ${Pt("uniforms.signs","i",t.length)};
            let starts_i = ${Pt("uniforms.starts","i",t.length)};
            var outputIndex = ${s.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps_i + starts_i + carry;
            carry = inputIndex / input_shape_i;
            inputIndex = inputIndex % input_shape_i;
            if (signs_i < 0) {
              inputIndex = input_shape_i - inputIndex - 1u + starts_i;
            }
            ${t.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,Dy=(e,r)=>{let t=e[0].dims,s=X.size(t),a=r.axes.length>0?X.normalizeAxes(r.axes,t.length):[...Array(t.length).keys()],f=Bn(e,4);f.forEach(M=>M!==0||(()=>{throw new Error("step cannot be 0")})),f.length===0&&(f=Array(a.length).fill(1));let p=r.starts.map((M,z)=>dc(M,z,t,a,f)),g=r.ends.map((M,z)=>dc(M,z,t,a,f));if(a.length!==p.length||a.length!==g.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==t.length)for(let M=0;M<t.length;++M)a.includes(M)||(p.splice(M,0,0),g.splice(M,0,t[M]),f.splice(M,0,1));let u=f.map(M=>Math.sign(M));f.forEach((M,z,G)=>{if(M<0){let L=(g[z]-p[z])/M,Y=p[z],A=Y+L*f[z];p[z]=A,g[z]=Y,G[z]=-M}});let w=t.slice(0);a.forEach((M,z)=>{w[M]=Math.ceil((g[M]-p[M])/f[M])});let C={dims:w,dataType:e[0].dataType},T=se("output",e[0].dataType,w.length),x=te("input",e[0].dataType,e[0].dims.length),O=X.size(w),k=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:p.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:f.length}],P=[{type:"uint32",data:O},{type:"uint32",data:p},{type:"int32",data:u},{type:"uint32",data:f},...Se(e[0].dims),...Se(w)],D=M=>`
      ${M.registerUniforms(k).declareVariables(x,T)}
        ${jy(x,T,t,w)}
        ${M.mainStart()}
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let outputIndices = ${T.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${T.setByOffset("global_idx",x.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${u.length}_${p.length}_${f.length}`,inputDependencies:["rank"]},getShaderSource:D,getRunData:()=>({outputs:[C],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:P})}},cc=(e,r)=>{By(e.inputs,r);let t=My(e.inputs,r);e.compute(Dy(e.inputs,t),{inputs:[0]})},fc=e=>{let r=e.starts,t=e.ends,s=e.axes;return me({starts:r,ends:t,axes:s})}});var zy,Wy,hc,mc,gc=oe(()=>{"use strict";ke();Fe();Re();zy=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Wy=(e,r)=>{let t=e.dims,s=X.size(t),a=64,f=r.axis;if(f<0&&(f=t.length+f),f<t.length-1)throw new Error("softmax only supports last axis for now.");let p=t[f],g=s/p,u=ft(p),w=p/u,C=(D,M)=>M===4?`max(max(${D}.x, ${D}.y), max(${D}.z, ${D}.w))`:M===2?`max(${D}.x, ${D}.y)`:M===3?`max(max(${D}.x, ${D}.y), ${D}.z)`:D,T=te("x",e.dataType,e.dims,u),x=se("result",e.dataType,e.dims,u),O=T.type.value,k=De(e.dataType)==="f32"?`var threadMax = ${O}(-3.402823e+38f);`:`var threadMax = ${O}(-65504.0h);`,P=D=>`
      var<workgroup> rowMaxShared : ${O};
      var<workgroup> rowSumShared : ${O};
      var<workgroup> threadShared : array<${O}, ${a}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${O} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${O}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${D.registerUniform("packedCols","i32").declareVariables(T,x)}
      ${D.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${a};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${k}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${O}(${C("threadShared[0]",u)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${O}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${O}(${St("threadShared[0]",u)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${u}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:t,dataType:e.dataType}],dispatchGroup:{x:g},programUniforms:[{type:"uint32",data:w}]}),getShaderSource:P}},hc=(e,r)=>{zy(e.inputs),e.compute(Wy(e.inputs[0],r))},mc=e=>me({axis:e.axis})});var Vy,Ny,Uy,Hy,Ly,yc,bc,vc=oe(()=>{"use strict";ke();Fe();Re();Vy=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Ny=(e,r)=>{let t=[],s=r.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>t.push(Number(a))),s=t.length),me({numOutputs:s,axis:r.axis,splitSizes:t})},Uy=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,Hy=e=>{let r=e.length,t=[];for(let s=0;s<r;++s){let a=e[s].setByIndices("indices","input[global_idx]");r===1?t.push(a):s===0?t.push(`if (outputNumber == ${s}u) { ${a} }`):s===r-1?t.push(`else { ${a} }`):t.push(`else if (outputNumber == ${s}) { ${a} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${t.join(`
`)}
      }`},Ly=(e,r)=>{let t=e[0].dims,s=X.size(t),a=e[0].dataType,f=t.length,p=r.axis,g=p<0?t.length+p:p,u=new Array(r.numOutputs),w=te("input",a,t),C=new Array(r.numOutputs),T=[],x=[],O=0;for(let D=0;D<r.numOutputs;D++){O+=r.splitSizes[D],C[D]=O;let M=t.slice();M[r.axis]=r.splitSizes[D],x.push(M),u[D]=se(`output${D}`,a,x[D]),T.push({dims:x[D],dataType:e[0].dataType})}let k=f<2?"indices":`indices[${g}]`,P=D=>`
  ${D.declareVariables(w,...u)}
  const sizeInConcatAxis = array<u32, ${C.length}>(${C.map(M=>`${M}u`).join(",")});
  ${Uy(C.length)}
  ${Hy(u)}

  ${D.mainStart()}
    ${D.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    var indices = ${w.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${k});
    if (outputNumber != 0) {
        ${k} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:r.cacheKey},getShaderSource:P,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(s/64)}})}},yc=(e,r)=>{Vy(e.inputs);let t=e.inputs.length===1?r:Ny(e.inputs,r);e.compute(Ly(e.inputs,t),{inputs:[0]})},bc=e=>{let r=e.axis,t=e.splitSizes,s=e.numOutputs<0?t.length:e.numOutputs;if(s!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return me({axis:r,numOutputs:s,splitSizes:t})}});var wc,Gy,Fy,qy,$c,Cc=oe(()=>{"use strict";Ze();ke();Re();wc=e=>Array.from(e.getBigInt64Array(),Number),Gy=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(wc(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Fy=(e,r)=>{let t=[];for(let s=0;s<e.length;++s)t.push(e[s]*r[s]);return t},qy=e=>{let r=e[0].dims,t=wc(e[1]),s=Fy(r,t),a=X.size(s),f=e[0].dataType,p=te("input",f,r),g=se("output",f,s),u=w=>`
      const inputShape = ${p.indices(...r)};
      ${w.declareVariables(p,g)}
      ${w.mainStart()}
      ${w.guardAgainstOutOfBoundsWorkgroupSizes(a)}
      let outputIndices = ${g.offsetToIndices("global_idx")};
      var inputIndices: ${p.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let inputDimValue = ${g.indicesGet("outputIndices","i")}  % ${p.indicesGet("inputShape","i")};

        ${p.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${g.setByOffset("global_idx",p.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:u}},$c=e=>{Gy(e.inputs),e.compute(qy(e.inputs),{inputs:[0]})}});var Ky,Yy,_c,Sc=oe(()=>{"use strict";Ze();ke();Re();Ky=(e,r,t,s,a)=>{let f=X.size(t),p=Math.ceil(f/4),g=se("outputData",a,t,4),u=te("aData",r[1].dataType,r[1].dims,4),w=te("bData",r[2].dataType,r[2].dims,4),C=te("cData",r[0].dataType,r[0].dims,4),T,x=(O,k,P)=>`select(${k}, ${O}, ${P})`;if(!s)T=g.setByOffset("global_idx",x(u.getByOffset("global_idx"),w.getByOffset("global_idx"),C.getByOffset("global_idx")));else{let O=(k,P,D="")=>{let M=`aData[indexA${P}][componentA${P}]`,z=`bData[indexB${P}][componentB${P}]`,G=`bool(cData[indexC${P}] & ${4278190080>>>(3-P)*8}u)`;return`
            let outputIndices${P} = ${g.offsetToIndices(`global_idx * 4u + ${P}u`)};
            let offsetA${P} = ${u.broadcastedIndicesToOffset(`outputIndices${P}`,g)};
            let offsetB${P} = ${w.broadcastedIndicesToOffset(`outputIndices${P}`,g)};
            let offsetC${P} = ${C.broadcastedIndicesToOffset(`outputIndices${P}`,g)};
            let indexA${P} = offsetA${P} / 4u;
            let indexB${P} = offsetB${P} / 4u;
            let indexC${P} = offsetC${P} / 4u;
            let componentA${P} = offsetA${P} % 4u;
            let componentB${P} = offsetB${P} % 4u;
            ${k}[${P}] = ${D}(${x(M,z,G)});
          `};a===9?T=`
            var data = vec4<u32>(0);
            ${O("data",0,"u32")}
            ${O("data",1,"u32")}
            ${O("data",2,"u32")}
            ${O("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:T=`
            ${O("outputData[global_idx]",0)}
            ${O("outputData[global_idx]",1)}
            ${O("outputData[global_idx]",2)}
            ${O("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(C,u,w,g)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}
        ${T}
      }`},Yy=e=>{let r=e[1].dims,t=e[2].dims,s=e[0].dims,a=e[1].dataType,f=!(X.areEqual(r,t)&&X.areEqual(t,s)),p=r,g=X.size(r);if(f){let u=Rt.calcShape(Rt.calcShape(r,t,!1),s,!1);if(!u)throw new Error("Can't perform where op on the given tensors");p=u,g=X.size(p)}return{name:"Where",getShaderSource:u=>Ky(u,e,p,f,a),getRunData:()=>({outputs:[{dims:p,dataType:a}],dispatchGroup:{x:Math.ceil(g/64/4)}})}},_c=e=>{e.compute(Yy(e.inputs))}});var xc,Ic=oe(()=>{"use strict";Xu();ca();el();rl();Ml();Fl();Yl();ga();ud();pd();gd();vd();Cd();xd();Ed();kd();Pd();Dd();Vd();tc();ic();Cn();oc();lc();pc();gc();vc();Cc();jr();fa();Sc();xc=new Map([["Abs",[il]],["Acos",[nl]],["Acosh",[al]],["Add",[jl]],["ArgMax",[Yu,da]],["ArgMin",[Ku,da]],["Asin",[ol]],["Asinh",[sl]],["Atan",[ul]],["Atanh",[ll]],["Attention",[Qu,Zu]],["AveragePool",[Fd,Gd]],["BatchNormalization",[Ju]],["BiasAdd",[tl]],["BiasSplitGelu",[Bl]],["Cast",[cl,dl]],["Ceil",[pl]],["Clip",[fl]],["Concat",[ql,Kl]],["Conv",[ba,ya]],["ConvTranspose",[sd,od]],["Cos",[hl]],["Cosh",[ml]],["Div",[Dl]],["Einsum",[cd,fd]],["Elu",[gl,xn]],["Equal",[zl]],["Erf",[yl]],["Exp",[bl]],["Expand",[md]],["Floor",[vl]],["FusedConv",[ba,ya]],["Gather",[bd,yd]],["GatherElements",[$d,wd]],["Gelu",[wl]],["Gemm",[_d,Sd]],["GlobalAveragePool",[Yd,Kd]],["GlobalMaxPool",[ec,Jd]],["Greater",[Ul]],["GreaterOrEqual",[Ll]],["InstanceNormalization",[Ad,Id]],["LayerNormalization",[Od,Td]],["LeakyRelu",[$l,xn]],["Less",[Hl]],["LessOrEqual",[Gl]],["Log",[Pl]],["MatMul",[Rd]],["MaxPool",[Zd,Qd]],["Mul",[Wl]],["MultiHeadAttention",[jd,Md]],["Neg",[_l]],["Not",[Cl]],["Pad",[zd,Wd]],["Pow",[Vl]],["Range",[rc]],["Reciprocal",[Sl]],["ReduceMin",[Uu,It]],["ReduceMean",[Du,It]],["ReduceMax",[Nu,It]],["ReduceSum",[Lu,It]],["ReduceProd",[Hu,It]],["ReduceL1",[zu,It]],["ReduceL2",[Wu,It]],["ReduceLogSum",[Fu,It]],["ReduceLogSumExp",[Vu,It]],["ReduceSumSquare",[Gu,It]],["Relu",[xl]],["Resize",[nc,ac]],["Sigmoid",[Il]],["Sin",[Al]],["Sinh",[El]],["Slice",[cc,fc]],["SkipLayerNormalization",[sc,uc]],["Split",[yc,bc]],["Sqrt",[Tl]],["Softmax",[hc,mc]],["Sub",[Nl]],["Tan",[Ol]],["Tanh",[kl]],["ThresholdedRelu",[Rl,xn]],["Tile",[$c]],["Transpose",[Su,xu]],["Where",[_c]]])});var Mn,Ac=oe(()=>{"use strict";Ze();Gt();Re();Mn=class{constructor(r){this.backend=r;this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,t){this.repo.set(r,t)}run(r,t,s,a,f,p,g){let u=this.backend.device,w=this.backend.getComputePassEncoder();w.setPipeline(r.computePipeline);let C=[];for(let x of a)C.push({binding:C.length,resource:{buffer:x.buffer}});for(let x of f)C.push({binding:C.length,resource:{buffer:x.buffer}});g&&C.push({binding:C.length,resource:g});let T=u.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:C,label:r.programInfo.name});if(w.setBindGroup(0,T),w.dispatchWorkgroups(...p),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let x=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,x.buffer,0,this.backend.querySetCount*8),this.backend.flush();let O=this.backend.currentKernelId,k=this.backend.kernels.get(O),P=`[${k[0]}] ${k[1]}`;x.buffer.mapAsync(GPUMapMode.READ).then(()=>{let D=new BigUint64Array(x.buffer.getMappedRange()),M=D[0],z=D[1];x.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=M);let G=Number(M-this.backend.queryTimeBase),L=Number(z-this.backend.queryTimeBase);if(!Number.isSafeInteger(G)||!Number.isSafeInteger(L))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(x.id);let Y="";t.forEach((Z,J)=>{Y+=`input[${J}]: [${Z.dims}] | ${xi(Z.dataType)}, `});let A="";s.forEach((Z,J)=>{A+=`output[${J}]: [${Z.dims}] | ${xi(Z.dataType)}, `}),console.log(`[profiling] kernel "${O}|${P}|${r.programInfo.name}" ${Y}${A}execution time: ${L-G} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(r,t){let s=this.backend.device,a=[];s.features.has("shader-f16")&&a.push("enable f16;");let f=Cu(t),p=r.getShaderSource(f),g=`${a.join(`
`)}
${f.additionalImplementations}
${p}`,u=s.createShaderModule({code:g,label:r.name});Ge("verbose",()=>`[WebGPU] ${r.name} shader code: ${g}`);let w=s.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto",label:r.name});return{programInfo:r,computePipeline:w}}normalizeDispatchGroupSize(r){let t=typeof r=="number"?r:r.x,s=typeof r=="number"?1:r.y||1,a=typeof r=="number"?1:r.z||1,f=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=f&&s<=f&&a<=f)return[t,s,a];let p=t*s*a,g=Math.ceil(Math.sqrt(p));if(g>f){if(g=Math.ceil(Math.cbrt(p)),g>f)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[g,g,g]}else return[g,g,1]}}});var Xy,Zy,jn,Ec=oe(()=>{"use strict";Gt();mu();vu();Ic();Ac();Xy=(e,r)=>{if(r.length!==e.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${e.length}.`);let t=[];for(let s=0;s<e.length;++s){let a=e[s].dataType;switch(r[s]){case"none":{t.push("");break}case"type":{t.push(`${a}`);break}case"rank":{let f=e[s].dims.length;t.push(`${a};${f}`);break}case"dims":{let f=e[s].dims.join(",");t.push(`${a};${f}`);break}default:throw new Error(`unsupported input dependency: ${r[s]}`)}}return t.join("|")},Zy=(e,r,t)=>{let s=e.name;return e.shaderCache?.hint&&(s+="["+e.shaderCache.hint+"]"),s+=":"+t+`:${Xy(r,e.shaderCache?.inputDependencies??new Array(r.length).fill("dims"))}`,s},jn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=r;let s=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:s};t.features.has("timestamp-query")&&s.push("timestamp-query"),t.features.has("shader-f16")&&s.push("shader-f16"),this.device=await t.requestDevice(a),this.gpuDataManager=bu(this),this.programManager=new Mn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,pu(r.logLevel,!!r.debug),this.device.onuncapturederror=f=>{f.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${f.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let r={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(r,t,s,a,f){let p=[];for(let z=0;z<t.length;++z){let G=this.gpuDataManager.get(t[z].data);if(!G)throw new Error(`no GPU data for input: ${t[z].data}`);p[z]=G}let{outputs:g,dispatchGroup:u,programUniforms:w}=r.getRunData(t),C=s.length===0?g.map((z,G)=>G):s;if(C.length!==g.length)throw new Error(`Output size ${C.length} must be equal to ${g.length}.`);let T=[],x=[];for(let z=0;z<g.length;++z){if(!Number.isInteger(C[z])||C[z]<-3||C[z]>=g.length)throw new Error(`Invalid output index: ${C[z]}`);if(C[z]===-3)continue;let G=C[z]===-1,L=C[z]===-2,Y=G||L?f(g[z].dataType,g[z].dims):a(C[z],g[z].dataType,g[z].dims),A=this.gpuDataManager.get(Y.data);if(!A)throw new Error(`no GPU data for output: ${Y.data}`);if(G&&this.temporaryData.push(A),L){let Z=this.kernelPersistentData.get(this.currentKernelId);Z||(Z=[],this.kernelPersistentData.set(this.currentKernelId,Z)),Z.push(A)}T.push(Y),x.push(A)}let O;if(w){let z=0,G=[];w.forEach(Z=>{let J=typeof Z.data=="number"?[Z.data]:Z.data;if(J.length===0)return;let re=J.length<=2?J.length*4:16;z=Math.ceil(z/re)*re,G.push(z),z+=J.length>4?Math.ceil(J.length/4)*16:J.length*4});let L=16;z=Math.ceil(z/L)*L;let Y=new ArrayBuffer(z);w.forEach((Z,J)=>{let re=G[J],fe=typeof Z.data=="number"?[Z.data]:Z.data;Z.type==="int32"?new Int32Array(Y,re,fe.length).set(fe):Z.type==="uint32"?new Uint32Array(Y,re,fe.length).set(fe):new Float32Array(Y,re,fe.length).set(fe)});let A=this.gpuDataManager.create(z,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,Y,0,z),this.gpuDataManager.release(A.id),O={offset:0,size:z,buffer:A.buffer}}let k=this.programManager.normalizeDispatchGroupSize(u),P=k[1]===1&&k[2]===1,D=Zy(r,t,P),M=this.programManager.getArtifact(D);return M||(M=this.programManager.build(r,k),this.programManager.setArtifact(D,M),Ge("info",()=>`[artifact] key: ${D}, programName: ${r.name}`)),Ge("info",()=>`[ProgramManager] run "${r.name}" (key=${D}) with ${k[0]}x${k[1]}x${k[2]}`),this.programManager.run(M,t,T,p,x,k,O),T}upload(r,t){this.gpuDataManager.upload(r,t)}memcpy(r,t){this.gpuDataManager.memcpy(r,t)}async download(r,t){await this.gpuDataManager.download(r,t)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,t,s,a){let f=xc.get(r);if(!f)throw new Error(`kernel not implemented: ${r}`);this.kernels.set(t,[r,a,f[0],[f[1],s]])}releaseKernel(r){let t=this.kernelPersistentData.get(r);if(t){for(let s of t)this.gpuDataManager.release(s.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,t,s){let a=this.kernels.get(r);if(!a)throw new Error(`kernel not created: ${r}`);let[f,p,g,u]=a;if(this.currentKernelId!==null)throw new Error(`kernel "[${f}] ${p}" is not allowed to be called recursively`);this.currentKernelId=r,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),Ge("info",()=>`[WebGPU] Start to run kernel "[${f}] ${p}"...`);let w=this.env.debug;this.temporaryData=[];try{return w&&this.device.pushErrorScope("validation"),g(t,u[1]),0}catch(C){return s.push(Promise.resolve(`[WebGPU] Kernel "[${f}] ${p}" failed. ${C}`)),1}finally{w&&s.push(this.device.popErrorScope().then(C=>C?`GPU validation error for kernel "[${f}] ${p}": ${C.message}`:null));for(let C of this.temporaryData)this.gpuDataManager.release(C.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,t,s,a){let f=this.sessionExternalDataMapping.get(r);f||(f=new Map,this.sessionExternalDataMapping.set(r,f));let p=f.get(t),g=this.gpuDataManager.registerExternalBuffer(s,a,p?.[1]);return f.set(t,[g,s]),g}unregisterBuffers(r){let t=this.sessionExternalDataMapping.get(r);t&&(t.forEach(s=>this.gpuDataManager.unregisterExternalBuffer(s[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let t=this.gpuDataManager.get(r);if(!t)throw new Error(`no GPU data for buffer: ${r}`);return t.buffer}createDownloader(r,t,s){return async()=>{let a=await ia(this,r,t);return hu(a.buffer,s)}}}});var Tc={};Br(Tc,{init:()=>Qy});var ki,Sa,Qy,Oc=oe(()=>{"use strict";Ze();Ec();Gt();ke();ki=class e{constructor(r,t,s,a){this.module=r;this.dataType=t;this.data=s;this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=X.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=X.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=X.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(X.size(r)!==X.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,r)}},Sa=class{constructor(r,t,s){this.module=r;this.backend=t;this.customDataOffset=0;this.customDataSize=0;let a=r.HEAPU32,f=s>>2;this.opKernelContext=a[f++];let p=a[f++];this.outputCount=a[f++],this.customDataOffset=a[f++],this.customDataSize=a[f++];let g=[];for(let u=0;u<p;u++){let w=a[f++],C=a[f++],T=a[f++],x=[];for(let O=0;O<T;O++)x.push(a[f++]);g.push(new ki(r,w,C,x))}this.inputs=g}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(r,t){let s=t?.inputs?.map(g=>typeof g=="number"?this.inputs[g]:g)??this.inputs,a=t?.outputs??[],f=(g,u,w)=>new ki(this.module,u,this.output(g,w),w),p=(g,u)=>{let w=Ii(g);if(!w)throw new Error(`Unsupported data type: ${g}`);let C=w*X.size(u);return new ki(this.module,g,this.backend.gpuDataManager.create(C).id,u)};return this.backend.run(r,s,a,f,p)}output(r,t){let s=this.module.stackSave();try{let a=this.module.stackAlloc((1+t.length)*4),f=a>>2;this.module.HEAPU32[f++]=t.length;for(let p=0;p<t.length;p++)this.module.HEAPU32[f++]=t[p];return this.module._JsepOutput(this.opKernelContext,r,a)}catch(a){throw new Error(`Failed to generate kernel's output[${r}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(s)}}},Qy=async(e,r)=>{let t=e.jsepInit;if(t&&navigator.gpu){if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let s=new jn;await s.initialize(r),t(s,a=>s.alloc(a),a=>s.free(a),(a,f,p,g=!1)=>{if(g)Ge("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${f}, size=${p}`),s.memcpy(a,f);else{Ge("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${f}, size=${p}`);let u=e.HEAPU8.subarray(a,a+p);s.upload(f,u)}},async(a,f,p)=>{Ge("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${f}, size=${p}`),await s.download(a,()=>e.HEAPU8.subarray(f,f+p))},(a,f,p)=>s.createKernel(a,f,p,r.debug||r.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(f)):`${f}`),a=>s.releaseKernel(a),(a,f,p,g)=>{Ge("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${p}, kernel=${a}, contextDataOffset=${f}`);let u=new Sa(e,s,f);return s.computeKernel(a,u,g)})}}});var Rc,Jy,e0,Pc,Ri,Bc,xa,Ia,Mc,jc,kc,Dc,zc,Wc,Vc=oe(()=>{"use strict";uu();du();Ze();Mr();hn();Rc=!1,Jy=e=>{let r=Ke(),t=r.stackSave();try{let s=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,s,s+4)!==0&&Ne("Can't get session input/output count."),[r.HEAP32[s/4],r.HEAP32[s/4+1]]}finally{r.stackRestore(t)}},e0=(e,r)=>{Ke()._OrtInit(e,r)!==0&&Ne("Can't initialize onnxruntime.")},Pc=async e=>{e0(e.wasm.numThreads,Ai(e.logLevel));{let r=(Oc(),sr(Tc)).init;await r(Ke(),e)}Rc=!0},Ri=new Map,Bc=()=>Rc,xa=e=>{let r=Ke(),t=r._malloc(e.byteLength);if(t===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,t),[t,e.byteLength]},Ia=(e,r)=>{let t=Ke(),s=0,a=0,f=0,p=[],g=[],u=[];try{[a,p]=lu(r),s=t._OrtCreateSession(e[0],e[1],a),s===0&&Ne("Can't create a session.");let[w,C]=Jy(s),T=[],x=[],O=[];for(let P=0;P<w;P++){let D=t._OrtGetInputName(s,P);D===0&&Ne("Can't get an input name."),g.push(D),T.push(t.UTF8ToString(D))}for(let P=0;P<C;P++){let D=t._OrtGetOutputName(s,P);D===0&&Ne("Can't get an output name."),u.push(D);let M=t.UTF8ToString(D);x.push(M);{let z=typeof r?.preferredOutputLocation=="string"?r.preferredOutputLocation:r?.preferredOutputLocation?.[M]??"cpu";if(z!=="cpu"&&z!=="cpu-pinned"&&z!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${z}.`);O.push(z)}}let k=null;return O.some(P=>P==="gpu-buffer")&&(f=t._OrtCreateBinding(s),f===0&&Ne("Can't create IO binding."),k={handle:f,outputPreferredLocations:O,outputPreferredLocationsEncoded:O.map(P=>ta(P))}),Ri.set(s,[s,g,u,k]),[s,T,x]}catch(w){throw g.forEach(C=>t._OrtFree(C)),u.forEach(C=>t._OrtFree(C)),f!==0&&t._OrtReleaseBinding(f),s!==0&&t._OrtReleaseSession(s),w}finally{t._free(e[0]),a!==0&&t._OrtReleaseSessionOptions(a),p.forEach(w=>t._free(w))}},Mc=(e,r)=>{let t=xa(e);return Ia(t,r)},jc=e=>{let r=Ke(),t=Ri.get(e);if(!t)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,a,f,p]=t;p&&r._OrtReleaseBinding(p.handle),r.jsepUnregisterBuffers?.(e),a.forEach(g=>r._OrtFree(g)),f.forEach(g=>r._OrtFree(g)),r._OrtReleaseSession(s),Ri.delete(e)},kc=(e,r,t,s,a)=>{if(!e){r.push(0);return}let f=Ke(),p=e[0],g=e[1],u=e[3],w,C;if(p==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u==="gpu-buffer"){let O=e[2].gpuBuffer,k=Ii(ea(p));C=g.reduce((P,D)=>P*D,1)*k,w=f.jsepRegisterBuffer(s,a,O,C)}else{let O=e[2];if(Array.isArray(O)){C=4*O.length,w=f._malloc(C),t.push(w);let k=w/4;for(let P=0;P<O.length;P++){if(typeof O[P]!="string")throw new TypeError(`tensor data at index ${P} is not a string`);f.HEAPU32[k++]=Xe(O[P],t)}}else C=O.byteLength,w=f._malloc(C),t.push(w),f.HEAPU8.set(new Uint8Array(O.buffer,O.byteOffset,C),w)}let T=f.stackSave(),x=f.stackAlloc(4*g.length);try{let O=x/4;g.forEach(P=>f.HEAP32[O++]=P);let k=f._OrtCreateTensor(ea(p),w,C,x,g.length,ta(u));k===0&&Ne(`Can't create tensor for input/output. session=${s}, index=${a}.`),r.push(k)}finally{f.stackRestore(T)}},Dc=async(e,r,t,s,a,f)=>{let p=Ke(),g=Ri.get(e);if(!g)throw new Error(`cannot run inference. invalid session id: ${e}`);let[u,w,C,T]=g,x=r.length,O=s.length,k=0,P=[],D=[],M=[],z=[],G=p.stackSave(),L=p.stackAlloc(x*4),Y=p.stackAlloc(x*4),A=p.stackAlloc(O*4),Z=p.stackAlloc(O*4);try{[k,P]=su(f);for(let he=0;he<x;he++)kc(t[he],D,z,e,r[he]);for(let he=0;he<O;he++)kc(a[he],M,z,e,x+s[he]);let J=L/4,re=Y/4,fe=A/4,F=Z/4;for(let he=0;he<x;he++)p.HEAPU32[J++]=D[he],p.HEAPU32[re++]=w[r[he]];for(let he=0;he<O;he++)p.HEAPU32[fe++]=M[he],p.HEAPU32[F++]=C[s[he]];if(T){let{handle:he,outputPreferredLocations:Pe,outputPreferredLocationsEncoded:ue}=T;if(w.length!==x)throw new Error(`input count from feeds (${x}) is expected to be always equal to model's input count (${w.length}).`);for(let Be=0;Be<x;Be++){let Me=r[Be];await p._OrtBindInput(he,w[Me],D[Be])!==0&&Ne(`Can't bind input[${Be}] for session=${e}.`)}for(let Be=0;Be<O;Be++){let Me=s[Be];a[Be]?.[3]?p._OrtBindOutput(he,C[Me],M[Be],0)!==0&&Ne(`Can't bind pre-allocated output[${Be}] for session=${e}.`):p._OrtBindOutput(he,C[Me],0,ue[Me])!==0&&Ne(`Can't bind output[${Be}] to ${Pe[Be]} for session=${e}.`)}}let ae;T?ae=await p._OrtRunWithBinding(u,T.handle,O,A,k):ae=await p._OrtRun(u,Y,L,x,Z,O,A,k),ae!==0&&Ne("failed to call OrtRun().");let _e=[];for(let he=0;he<O;he++){let Pe=p.HEAPU32[A/4+he];if(Pe===M[he]){_e.push(a[he]);continue}let ue=p.stackSave(),Be=p.stackAlloc(4*4),Me=!1,je,Ae=0;try{p._OrtGetTensorData(Pe,Be,Be+4,Be+8,Be+12)!==0&&Ne(`Can't access output tensor data on index ${he}.`);let it=Be/4,nt=p.HEAPU32[it++];Ae=p.HEAPU32[it++];let ie=p.HEAPU32[it++],we=p.HEAPU32[it++],Ie=[];for(let qe=0;qe<we;qe++)Ie.push(p.HEAPU32[ie/4+qe]);p._OrtFree(ie);let rt=Ie.reduce((qe,Je)=>qe*Je,1);je=xi(nt);let dt=T?.outputPreferredLocations[s[he]];if(je==="string"){if(dt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let qe=[],Je=Ae/4;for(let ut=0;ut<rt;ut++){let Et=p.HEAPU32[Je++],ht=ut===rt-1?void 0:p.HEAPU32[Je]-Et;qe.push(p.UTF8ToString(Et,ht))}_e.push([je,Ie,qe,"cpu"])}else if(dt==="gpu-buffer"&&rt>0){let qe=p.jsepGetBuffer(Ae),Je=Ii(nt);if(Je===void 0||!gn(je))throw new Error(`Unsupported data type: ${je}`);Me=!0,_e.push([je,Ie,{gpuBuffer:qe,download:p.jsepCreateDownloader(qe,rt*Je,je),dispose:()=>{p._OrtReleaseTensor(Pe)}},"gpu-buffer"])}else{let qe=mn(je),Je=new qe(rt);new Uint8Array(Je.buffer,Je.byteOffset,Je.byteLength).set(p.HEAPU8.subarray(Ae,Ae+Je.byteLength)),_e.push([je,Ie,Je,"cpu"])}}finally{p.stackRestore(ue),je==="string"&&Ae&&p._free(Ae),Me||p._OrtReleaseTensor(Pe)}}return T&&p._OrtClearBoundOutputs(T.handle),_e}finally{p.stackRestore(G),D.forEach(J=>p._OrtReleaseTensor(J)),M.forEach(J=>p._OrtReleaseTensor(J)),z.forEach(J=>p._free(J)),k!==0&&p._OrtReleaseRunOptions(k),P.forEach(J=>p._free(J))}},zc=e=>{let r=Ke(),t=Ri.get(e);if(!t)throw new Error("invalid session id");let s=t[0],a=r._OrtEndProfiling(s);a===0&&Ne("Can't get an profile file name."),r._OrtFree(a)},Wc=e=>{let r=[];for(let t of e){let s=t[2];!Array.isArray(s)&&"buffer"in s&&r.push(s.buffer)}return r}});var Nc=Pr((J2,r0)=>{r0.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var wi=Object.defineProperty;var Zp=Object.getOwnPropertyDescriptor;var Xp=Object.getOwnPropertyNames;var Qp=Object.prototype.hasOwnProperty;var ae=(e,r)=>()=>(e&&(r=e(e=0)),r);var fn=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),qn=(e,r)=>{for(var t in r)wi(e,t,{get:r[t],enumerable:!0})},Jp=(e,r,t,u)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of Xp(r))!Qp.call(e,a)&&a!==t&&wi(e,a,{get:()=>r[a],enumerable:!(u=Zp(r,a))||u.enumerable});return e};var Sr=e=>Jp(wi({},"__esModule",{value:!0}),e);var $i={};qn($i,{readFile:()=>em});var em,Ci=ae(()=>{em=void 0});var Si={};qn(Si,{join:()=>tm});var tm,xi=ae(()=>{tm=void 0});var Ua=fn((Wa,_i)=>{"use strict";var Va=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(r={}){var t=r,u,a;t.ready=new Promise((n,i)=>{u=n,a=i}),t.jsepInit=(n,i,o,s,d,f,h,g)=>{t.zh=n,t.ph=i,t.rh=o,t.eh=s,t.qh=d,t.Cd=f,t.sh=h,t.th=g,i=(b,w,$)=>(...I)=>{let E=ft,C=w?.();I=b(...I);let D=w?.();return C!==D&&(b=D,$(C),w=$=null),ft!=E?In():I},o=b=>async(...w)=>{try{if(t.Xg)throw Error("Session already started");let $=t.Xg={uh:w[0],errors:[]},I=await b(...w);if(t.Xg!==$)throw Error("Session mismatch");n.flush();let E=$.errors;if(0<E.length){let C=await Promise.all(E);if(C=C.filter(D=>D),0<C.length)throw Error(C.join(`\n`))}return I}finally{t.Xg=null}},t._OrtRun=o(i(t._OrtRun,()=>t._OrtRun,b=>t._OrtRun=b)),t._OrtRunWithBinding=o(i(t._OrtRunWithBinding,()=>t._OrtRunWithBinding,b=>t._OrtRunWithBinding=b)),t._OrtBindInput=i(t._OrtBindInput,()=>t._OrtBindInput,b=>t._OrtBindInput=b),t.jsepRegisterBuffer=(b,w,$,I)=>n.registerBuffer(b,w,$,I),t.jsepUnregisterBuffers=b=>{n.unregisterBuffers(b)},t.jsepGetBuffer=b=>n.getBuffer(b),t.jsepCreateDownloader=(b,w,$)=>n.createDownloader(b,w,$)};var p=Object.assign({},t),m="./this.program",y=(n,i)=>{throw i},l=typeof window=="object",S=typeof importScripts=="function",A=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",P="",T,k,O;if(A){var R=(Ci(),Sr($i)),j=(xi(),Sr(Si));P=S?j.dirname(P)+"/":__dirname+"/",T=(n,i)=>(n=n.startsWith("file://")?new URL(n):j.normalize(n),R.readFileSync(n,i?void 0:"utf8")),O=n=>(n=T(n,!0),n.buffer||(n=new Uint8Array(n)),n),k=(n,i,o,s=!0)=>{n=n.startsWith("file://")?new URL(n):j.normalize(n),R.readFile(n,s?void 0:"utf8",(d,f)=>{d?o(d):i(s?f.buffer:f)})},!t.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),y=(n,i)=>{throw process.exitCode=n,i},t.inspect=()=>"[Emscripten Module object]"}else(l||S)&&(S?P=self.location.href:typeof document<"u"&&document.currentScript&&(P=document.currentScript.src),e&&(P=e),P.indexOf("blob:")!==0?P=P.substr(0,P.replace(/[?#].*/,"").lastIndexOf("/")+1):P="",T=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.send(null),i.responseText},S&&(O=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.responseType="arraybuffer",i.send(null),new Uint8Array(i.response)}),k=(n,i,o)=>{var s=new XMLHttpRequest;s.open("GET",n,!0),s.responseType="arraybuffer",s.onload=()=>{s.status==200||s.status==0&&s.response?i(s.response):o()},s.onerror=o,s.send(null)});var M=t.print||console.log.bind(console),z=t.printErr||console.error.bind(console);Object.assign(t,p),p=null,t.thisProgram&&(m=t.thisProgram),t.quit&&(y=t.quit);var q;t.wasmBinary&&(q=t.wasmBinary);var G=t.noExitRuntime||!0;typeof WebAssembly!="object"&&nt("no native wasm support detected");var Y,_,X=!1,J,re,fe,L,oe,Se,me;function Re(){var n=Y.buffer;t.HEAP8=re=new Int8Array(n),t.HEAP16=new Int16Array(n),t.HEAP32=L=new Int32Array(n),t.HEAPU8=fe=new Uint8Array(n),t.HEAPU16=new Uint16Array(n),t.HEAPU32=oe=new Uint32Array(n),t.HEAPF32=Se=new Float32Array(n),t.HEAPF64=me=new Float64Array(n)}var ue=[],Be=[],Me=[];function De(){var n=t.preRun.shift();ue.unshift(n)}var Ae=0,St=null,rt=null;function nt(n){throw t.onAbort&&t.onAbort(n),n="Aborted("+n+")",z(n),X=!0,J=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),a(n),n}function ne(n){return n.startsWith("data:application/octet-stream;base64,")}var we;if(we="ort-wasm-simd.wasm",!ne(we)){var Ie=we;we=t.locateFile?t.locateFile(Ie,P):P+Ie}function tt(n){if(n==we&&q)return new Uint8Array(q);if(O)return O(n);throw"both async and sync fetching of the wasm failed"}function st(n){if(!q&&(l||S)){if(typeof fetch=="function"&&!n.startsWith("file://"))return fetch(n,{credentials:"same-origin"}).then(i=>{if(!i.ok)throw"failed to load wasm binary file at \'"+n+"\'";return i.arrayBuffer()}).catch(()=>tt(n));if(k)return new Promise((i,o)=>{k(n,s=>i(new Uint8Array(s)),o)})}return Promise.resolve().then(()=>tt(n))}function Fe(n,i,o){return st(n).then(s=>WebAssembly.instantiate(s,i)).then(s=>s).then(o,s=>{z("failed to asynchronously prepare wasm: "+s),nt(s)})}function Qe(n,i){var o=we;return q||typeof WebAssembly.instantiateStreaming!="function"||ne(o)||o.startsWith("file://")||A||typeof fetch!="function"?Fe(o,n,i):fetch(o,{credentials:"same-origin"}).then(s=>WebAssembly.instantiateStreaming(s,n).then(i,function(d){return z("wasm streaming compile failed: "+d),z("falling back to ArrayBuffer instantiation"),Fe(o,n,i)}))}var at,xt={1336376:n=>{t.Cd("Abs",n,void 0)},1336427:n=>{t.Cd("Neg",n,void 0)},1336478:n=>{t.Cd("Floor",n,void 0)},1336531:n=>{t.Cd("Ceil",n,void 0)},1336583:n=>{t.Cd("Reciprocal",n,void 0)},1336641:n=>{t.Cd("Sqrt",n,void 0)},1336693:n=>{t.Cd("Exp",n,void 0)},1336744:n=>{t.Cd("Erf",n,void 0)},1336795:n=>{t.Cd("Sigmoid",n,void 0)},1336850:n=>{t.Cd("Log",n,void 0)},1336901:n=>{t.Cd("Sin",n,void 0)},1336952:n=>{t.Cd("Cos",n,void 0)},1337003:n=>{t.Cd("Tan",n,void 0)},1337054:n=>{t.Cd("Asin",n,void 0)},1337106:n=>{t.Cd("Acos",n,void 0)},1337158:n=>{t.Cd("Atan",n,void 0)},1337210:n=>{t.Cd("Sinh",n,void 0)},1337262:n=>{t.Cd("Cosh",n,void 0)},1337314:n=>{t.Cd("Asinh",n,void 0)},1337367:n=>{t.Cd("Acosh",n,void 0)},1337420:n=>{t.Cd("Atanh",n,void 0)},1337473:n=>{t.Cd("Tanh",n,void 0)},1337525:n=>{t.Cd("Not",n,void 0)},1337576:(n,i,o)=>{t.Cd("Clip",n,{min:i,max:o})},1337645:n=>{t.Cd("Clip",n,void 0)},1337697:(n,i)=>{t.Cd("Elu",n,{alpha:i})},1337755:n=>{t.Cd("Relu",n,void 0)},1337807:(n,i)=>{t.Cd("LeakyRelu",n,{alpha:i})},1337871:(n,i)=>{t.Cd("ThresholdedRelu",n,{alpha:i})},1337941:(n,i)=>{t.Cd("Cast",n,{to:i})},1337999:n=>{t.Cd("Add",n,void 0)},1338050:n=>{t.Cd("Sub",n,void 0)},1338101:n=>{t.Cd("Mul",n,void 0)},1338152:n=>{t.Cd("Div",n,void 0)},1338203:n=>{t.Cd("Pow",n,void 0)},1338254:n=>{t.Cd("Equal",n,void 0)},1338307:n=>{t.Cd("Greater",n,void 0)},1338362:n=>{t.Cd("GreaterOrEqual",n,void 0)},1338424:n=>{t.Cd("Less",n,void 0)},1338476:n=>{t.Cd("LessOrEqual",n,void 0)},1338535:(n,i,o,s,d)=>{t.Cd("ReduceMean",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1338699:(n,i,o,s,d)=>{t.Cd("ReduceMax",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1338862:(n,i,o,s,d)=>{t.Cd("ReduceMin",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339025:(n,i,o,s,d)=>{t.Cd("ReduceProd",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339189:(n,i,o,s,d)=>{t.Cd("ReduceSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339352:(n,i,o,s,d)=>{t.Cd("ReduceL1",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339514:(n,i,o,s,d)=>{t.Cd("ReduceL2",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339676:(n,i,o,s,d)=>{t.Cd("ReduceLogSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1339842:(n,i,o,s,d)=>{t.Cd("ReduceSumSquare",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1340011:(n,i,o,s,d)=>{t.Cd("ReduceLogSumExp",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1340180:n=>{t.Cd("Where",n,void 0)},1340233:(n,i,o)=>{t.Cd("Transpose",n,{perm:i?Array.from(L.subarray(o>>>0,o+i>>>0)):[]})},1340346:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>{t.Cd("ConvTranspose",n,{format:b?"NHWC":"NCHW",autoPad:i,dilations:[o],group:s,kernel_shape:[d],pads:[f,h],strides:[g],wIsConst:()=>!!re[w>>>0],outputPadding:$?Array.from(L.subarray(I>>>0,I+$>>>0)):[],outputShape:E?Array.from(L.subarray(C>>>0,C+E>>>0)):[],activation:it(D)})},1340760:(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>{t.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(L.subarray(o>>>0,o+2>>>0)),group:s,kernelShape:Array.from(L.subarray(d>>>0,d+2>>>0)),pads:Array.from(L.subarray(f>>>0,f+4>>>0)),strides:Array.from(L.subarray(h>>>0,h+2>>>0)),wIsConst:()=>!!re[b>>>0],outputPadding:0<w?Array.from(L.subarray($>>>0,$+w>>>0)):[],outputShape:0<I?Array.from(L.subarray(E>>>0,E+I>>>0)):[],activation:it(C)})},1341317:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>{t.Cd("ConvTranspose",n,{format:b?"NHWC":"NCHW",autoPad:i,dilations:[o],group:s,kernel_shape:[d],pads:[f,h],strides:[g],wIsConst:()=>!!re[w>>>0],outputPadding:$?Array.from(L.subarray(I>>>0,I+$>>>0)):[],outputShape:E?Array.from(L.subarray(C>>>0,C+E>>>0)):[],activation:it(D)})},1341731:(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>{t.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(L.subarray(o>>>0,o+2>>>0)),group:s,kernelShape:Array.from(L.subarray(d>>>0,d+2>>>0)),pads:Array.from(L.subarray(f>>>0,f+4>>>0)),strides:Array.from(L.subarray(h>>>0,h+2>>>0)),wIsConst:()=>!!re[b>>>0],outputPadding:0<w?Array.from(L.subarray($>>>0,$+w>>>0)):[],outputShape:0<I?Array.from(L.subarray(E>>>0,E+I>>>0)):[],activation:it(C)})},1342288:(n,i)=>{t.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1342379:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>{t.Cd("AveragePool",n,{format:V?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:s,storage_order:d,dilations:[f,h],kernel_shape:[g,b],pads:[w,$,I,E],strides:[C,D]})},1342663:(n,i)=>{t.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1342754:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>{t.Cd("AveragePool",n,{format:V?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:s,storage_order:d,dilations:[f,h],kernel_shape:[g,b],pads:[w,$,I,E],strides:[C,D]})},1343038:(n,i)=>{t.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1343125:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>{t.Cd("MaxPool",n,{format:V?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:s,storage_order:d,dilations:[f,h],kernel_shape:[g,b],pads:[w,$,I,E],strides:[C,D]})},1343405:(n,i)=>{t.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1343492:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>{t.Cd("MaxPool",n,{format:V?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:s,storage_order:d,dilations:[f,h],kernel_shape:[g,b],pads:[w,$,I,E],strides:[C,D]})},1343772:(n,i,o,s,d)=>{t.Cd("Gemm",n,{alpha:i,beta:o,transA:s,transB:d})},1343876:n=>{t.Cd("MatMul",n,void 0)},1343930:(n,i,o,s)=>{t.Cd("ArgMax",n,{keepDims:!!i,selectLastIndex:!!o,axis:s})},1344038:(n,i,o,s)=>{t.Cd("ArgMin",n,{keepDims:!!i,selectLastIndex:!!o,axis:s})},1344146:(n,i)=>{t.Cd("Softmax",n,{axis:i})},1344209:(n,i)=>{t.Cd("Concat",n,{axis:i})},1344269:(n,i,o,s,d)=>{t.Cd("Split",n,{axis:i,numOutputs:o,splitSizes:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1344414:n=>{t.Cd("Expand",n,void 0)},1344468:(n,i)=>{t.Cd("Gather",n,{axis:Number(i)})},1344539:(n,i)=>{t.Cd("GatherElements",n,{axis:Number(i)})},1344618:(n,i,o,s,d,f,h,g,b,w,$)=>{t.Cd("Resize",n,{antialias:i,axes:o?Array.from(L.subarray(s>>>0,s+o>>>0)):[],coordinateTransformMode:it(d),cubicCoeffA:f,excludeOutside:h,extrapolationValue:g,keepAspectRatioPolicy:it(b),mode:it(w),nearestMode:it($)})},1344969:(n,i,o,s,d,f,h)=>{t.Cd("Slice",n,{starts:i?Array.from(L.subarray(o>>>0,o+i>>>0)):[],ends:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[],axes:f?Array.from(L.subarray(h>>>0,h+f>>>0)):[]})},1345200:n=>{t.Cd("Tile",n,void 0)},1345252:(n,i,o)=>{t.Cd("LayerNormalization",n,{axis:Number(i),epsilon:Number(o)})},1345359:(n,i,o)=>{t.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1345473:(n,i,o)=>{t.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1345587:n=>{t.Cd("Range",n,void 0)},1345640:(n,i)=>{t.Cd("Einsum",n,{equation:it(i)})},1345721:(n,i,o,s,d)=>{t.Cd("Pad",n,{mode:i,value:o,pads:s?Array.from(L.subarray(d>>>0,d+s>>>0)):[]})},1345853:(n,i,o,s,d,f)=>{t.Cd("BatchNormalization",n,{epsilon:i,momentum:o,spatial:!!d,trainingMode:!!s,format:f?"NHWC":"NCHW"})},1346022:(n,i,o,s,d,f)=>{t.Cd("BatchNormalization",n,{epsilon:i,momentum:o,spatial:!!d,trainingMode:!!s,format:f?"NHWC":"NCHW"})},1346191:(n,i,o,s,d,f,h,g,b)=>{t.Cd("Attention",n,{numHeads:i,isUnidirectional:o,maskFilterValue:s,scale:d,doRotary:f,qkvHiddenSizes:h?Array.from(L.subarray(Number(g)>>>0,Number(g)+h>>>0)):[],pastPresentShareBuffer:!!b})},1346463:n=>{t.Cd("Gelu",n,void 0)},1346515:(n,i,o,s,d,f)=>{t.Cd("MultiHeadAttention",n,{numHeads:i,isUnidirectional:o,maskFilterValue:s,scale:d,doRotary:f})},1346674:n=>{t.Cd("BiasAdd",n,void 0)},1346729:n=>{t.Cd("BiasSplitGelu",n,void 0)},1346790:(n,i)=>{t.Cd("SkipLayerNormalization",n,{epsilon:i})},1346871:(n,i,o,s,d,f,h,g,b,w,$,I,E)=>{t.Cd("Conv",n,{format:b?"NHWC":"NCHW",auto_pad:i,dilations:[o],group:s,kernel_shape:[d],pads:f?Array.from(L.subarray(h>>>0,h+f>>>0)):[],strides:[g],w_is_const:()=>!!re[w>>>0],activation:it($),activation_params:I?Array.from(Se.subarray(E>>>0,E+I>>>0)):[]})},1347252:(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>{t.Cd("Conv",n,{format:I?"NHWC":"NCHW",auto_pad:i,dilations:[o,s],group:d,kernel_shape:[f,h],pads:g?Array.from(L.subarray(b>>>0,b+g>>>0)):[],strides:[w,$],w_is_const:()=>!!re[E>>>0],activation:it(C),activation_params:D?Array.from(Se.subarray(V>>>0,V+D>>>0)):[]})},1347654:n=>{t.sh(n)},1347688:(n,i)=>t.th(n,i,t.Xg.uh,t.Xg.errors),1347800:n=>t.ph(n),1347833:n=>t.rh(n),1347865:(n,i,o)=>{t.eh(n,i,o,!0)},1347904:(n,i,o)=>{t.eh(n,i,o)}};function dt(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Wt=n=>{for(;0<n.length;)n.shift()(t)},_t=[],Ut=0,gt=0;function yt(n){this.Wg=n,this.Sg=n-24,this.mh=function(i){oe[this.Sg+4>>2>>>0]=i},this.bh=function(){return oe[this.Sg+4>>2>>>0]},this.lh=function(i){oe[this.Sg+8>>2>>>0]=i},this.fh=function(i){re[this.Sg+12>>0>>>0]=i?1:0},this.ih=function(){return re[this.Sg+12>>0>>>0]!=0},this.gh=function(i){re[this.Sg+13>>0>>>0]=i?1:0},this.oh=function(){return re[this.Sg+13>>0>>>0]!=0},this.kh=function(i,o){this.dh(0),this.mh(i),this.lh(o)},this.dh=function(i){oe[this.Sg+16>>2>>>0]=i},this.hh=function(){return oe[this.Sg+16>>2>>>0]},this.jh=function(){if(Br(this.bh()))return oe[this.Wg>>2>>>0];var i=this.hh();return i!==0?i:this.Wg}}var Nt=n=>{var i=gt;if(!i)return Dt(0),0;var o=new yt(i);o.dh(i);var s=o.bh();if(!s)return Dt(0),i;for(var d in n){var f=n[d];if(f===0||f===s)break;if(Rr(f,s,o.Sg+16))return Dt(f),i}return Dt(s),i},Mt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,_r=(n,i,o)=>{i>>>=0;var s=i+o;for(o=i;n[o]&&!(o>=s);)++o;if(16<o-i&&n.buffer&&Mt)return Mt.decode(n.subarray(i,o));for(s="";i<o;){var d=n[i++];if(d&128){var f=n[i++]&63;if((d&224)==192)s+=String.fromCharCode((d&31)<<6|f);else{var h=n[i++]&63;d=(d&240)==224?(d&15)<<12|f<<6|h:(d&7)<<18|f<<12|h<<6|n[i++]&63,65536>d?s+=String.fromCharCode(d):(d-=65536,s+=String.fromCharCode(55296|d>>10,56320|d&1023))}}else s+=String.fromCharCode(d)}return s},it=(n,i)=>(n>>>=0)?_r(fe,n,i):"",tr=n=>{for(var i=0,o=0;o<n.length;++o){var s=n.charCodeAt(o);127>=s?i++:2047>=s?i+=2:55296<=s&&57343>=s?(i+=4,++o):i+=3}return i},Ir=(n,i,o,s)=>{if(o>>>=0,!(0<s))return 0;var d=o;s=o+s-1;for(var f=0;f<n.length;++f){var h=n.charCodeAt(f);if(55296<=h&&57343>=h){var g=n.charCodeAt(++f);h=65536+((h&1023)<<10)|g&1023}if(127>=h){if(o>=s)break;i[o++>>>0]=h}else{if(2047>=h){if(o+1>=s)break;i[o++>>>0]=192|h>>6}else{if(65535>=h){if(o+2>=s)break;i[o++>>>0]=224|h>>12}else{if(o+3>=s)break;i[o++>>>0]=240|h>>18,i[o++>>>0]=128|h>>12&63}i[o++>>>0]=128|h>>6&63}i[o++>>>0]=128|h&63}}return i[o>>>0]=0,o-d},ct=n=>n%4===0&&(n%100!==0||n%400===0),rr=[0,31,60,91,121,152,182,213,244,274,305,335],Ht=[0,31,59,90,120,151,181,212,243,273,304,334],nr=n=>{var i=tr(n)+1,o=cr(i);return o&&Ir(n,fe,o,i),o},ir=[],Ar=(n,i)=>{ir.length=0;var o;for(i>>=2;o=fe[n++>>>0];)i+=o!=105&i,ir.push(o==105?L[i>>>0]:me[i++>>>1]),++i;return ir},or={},Tr=()=>{if(!Je){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"},i;for(i in or)or[i]===void 0?delete n[i]:n[i]=or[i];var o=[];for(i in n)o.push(`${i}=${n[i]}`);Je=o}return Je},Je,Cn=[null,[],[]],ar=[31,29,31,30,31,30,31,31,30,31,30,31],be=[31,28,31,30,31,30,31,31,30,31,30,31];function sr(n){var i=Array(tr(n)+1);return Ir(n,i,0,i.length),i}function Er(n,i,o,s){function d(C,D,V){for(C=typeof C=="number"?C.toString():C||"";C.length<D;)C=V[0]+C;return C}function f(C,D){return d(C,D,"0")}function h(C,D){function V(ie){return 0>ie?-1:0<ie?1:0}var Q;return(Q=V(C.getFullYear()-D.getFullYear()))===0&&(Q=V(C.getMonth()-D.getMonth()))===0&&(Q=V(C.getDate()-D.getDate())),Q}function g(C){switch(C.getDay()){case 0:return new Date(C.getFullYear()-1,11,29);case 1:return C;case 2:return new Date(C.getFullYear(),0,3);case 3:return new Date(C.getFullYear(),0,2);case 4:return new Date(C.getFullYear(),0,1);case 5:return new Date(C.getFullYear()-1,11,31);case 6:return new Date(C.getFullYear()-1,11,30)}}function b(C){var D=C.Ug;for(C=new Date(new Date(C.Vg+1900,0,1).getTime());0<D;){var V=C.getMonth(),Q=(ct(C.getFullYear())?ar:be)[V];if(D>Q-C.getDate())D-=Q-C.getDate()+1,C.setDate(1),11>V?C.setMonth(V+1):(C.setMonth(0),C.setFullYear(C.getFullYear()+1));else{C.setDate(C.getDate()+D);break}}return V=new Date(C.getFullYear()+1,0,4),D=g(new Date(C.getFullYear(),0,4)),V=g(V),0>=h(D,C)?0>=h(V,C)?C.getFullYear()+1:C.getFullYear():C.getFullYear()-1}n>>>=0,i>>>=0,o>>>=0,s>>>=0;var w=L[s+40>>2>>>0];s={xh:L[s>>2>>>0],wh:L[s+4>>2>>>0],Yg:L[s+8>>2>>>0],ah:L[s+12>>2>>>0],Zg:L[s+16>>2>>>0],Vg:L[s+20>>2>>>0],Tg:L[s+24>>2>>>0],Ug:L[s+28>>2>>>0],Ah:L[s+32>>2>>>0],vh:L[s+36>>2>>>0],yh:w?it(w):""},o=it(o),w={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var $ in w)o=o.replace(new RegExp($,"g"),w[$]);var I="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),E="January February March April May June July August September October November December".split(" ");w={"%a":C=>I[C.Tg].substring(0,3),"%A":C=>I[C.Tg],"%b":C=>E[C.Zg].substring(0,3),"%B":C=>E[C.Zg],"%C":C=>f((C.Vg+1900)/100|0,2),"%d":C=>f(C.ah,2),"%e":C=>d(C.ah,2," "),"%g":C=>b(C).toString().substring(2),"%G":C=>b(C),"%H":C=>f(C.Yg,2),"%I":C=>(C=C.Yg,C==0?C=12:12<C&&(C-=12),f(C,2)),"%j":C=>{for(var D=0,V=0;V<=C.Zg-1;D+=(ct(C.Vg+1900)?ar:be)[V++]);return f(C.ah+D,3)},"%m":C=>f(C.Zg+1,2),"%M":C=>f(C.wh,2),"%n":()=>`\n`,"%p":C=>0<=C.Yg&&12>C.Yg?"AM":"PM","%S":C=>f(C.xh,2),"%t":()=>"	","%u":C=>C.Tg||7,"%U":C=>f(Math.floor((C.Ug+7-C.Tg)/7),2),"%V":C=>{var D=Math.floor((C.Ug+7-(C.Tg+6)%7)/7);if(2>=(C.Tg+371-C.Ug-2)%7&&D++,D)D==53&&(V=(C.Tg+371-C.Ug)%7,V==4||V==3&&ct(C.Vg)||(D=1));else{D=52;var V=(C.Tg+7-C.Ug-1)%7;(V==4||V==5&&ct(C.Vg%400-1))&&D++}return f(D,2)},"%w":C=>C.Tg,"%W":C=>f(Math.floor((C.Ug+7-(C.Tg+6)%7)/7),2),"%y":C=>(C.Vg+1900).toString().substring(2),"%Y":C=>C.Vg+1900,"%z":C=>{C=C.vh;var D=0<=C;return C=Math.abs(C)/60,(D?"+":"-")+("0000"+(C/60*100+C%60)).slice(-4)},"%Z":C=>C.yh,"%%":()=>"%"},o=o.replace(/%%/g,"\\0\\0");for($ in w)o.includes($)&&(o=o.replace(new RegExp($,"g"),w[$](s)));return o=o.replace(/\\0\\0/g,"%"),$=sr(o),$.length>i?0:(re.set($,n>>>0),$.length-1)}function ur(n){try{n()}catch(i){nt(i)}}function Sn(n){var i={},o;for(o in n)(function(s){var d=n[s];i[s]=typeof d=="function"?function(){Gt.push(s);try{return d.apply(null,arguments)}finally{X||(Gt.pop()===s||nt(),ft&&It===1&&Gt.length===0&&(It=0,ur(Ma),typeof Fibers<"u"&&Fibers.Bh()))}}:d})(o);return i}var It=0,ft=null,Or=0,Gt=[],kr={},lr={},xn=0,dr=null,_n=[];function In(){return new Promise((n,i)=>{dr={resolve:n,reject:i}})}function An(){var n=cr(65548),i=n+12;oe[n>>2>>>0]=i,oe[n+4>>2>>>0]=i+65536,i=Gt[0];var o=kr[i];return o===void 0&&(o=xn++,kr[i]=o,lr[o]=i),L[n+8>>2>>>0]=o,n}function Tn(n){if(!X){if(It===0){var i=!1,o=!1;n((s=0)=>{if(!X&&(Or=s,i=!0,o)){It=2,ur(()=>Da(ft)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),s=!1;try{var d=(0,_[lr[L[ft+8>>2>>>0]]])()}catch(g){d=g,s=!0}var f=!1;if(!ft){var h=dr;h&&(dr=null,(s?h.reject:h.resolve)(d),f=!0)}if(s&&!f)throw d}}),o=!0,i||(It=1,ft=An(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),ur(()=>Ba(ft)))}else It===2?(It=0,ur(ja),Pr(ft),ft=null,_n.forEach(s=>{if(!X)try{if(s(),!G)try{J=J=s=J,G||(t.onExit&&t.onExit(s),X=!0),y(s,new dt(s))}catch(d){d instanceof dt||d=="unwind"||y(1,d)}}catch(d){d instanceof dt||d=="unwind"||y(1,d)}})):nt(`invalid state: ${It}`);return Or}}function En(n){return Tn(i=>{n().then(i)})}var On={Ha:function(n,i,o){return En(async()=>{await t.qh(n,i,o)})},u:function(n){return n=new yt(n>>>0),n.ih()||(n.fh(!0),Ut--),n.gh(!1),_t.push(n),jt(n.Wg),n.jh()},C:function(){W(0,0);var n=_t.pop();Lt(n.Wg),gt=0},a:function(){return Nt([])},k:function(n){return Nt([n>>>0])},w:function(n,i){return Nt([n>>>0,i>>>0])},q:function(n,i,o){return Nt([n>>>0,i>>>0,o>>>0])},pa:function(){var n=_t.pop();n||nt("no exception to throw");var i=n.Wg;throw n.oh()||(_t.push(n),n.gh(!0),n.fh(!1),Ut++),gt=i,gt},s:function(n,i,o){throw n>>>=0,new yt(n).kh(i>>>0,o>>>0),gt=n,Ut++,gt},$:function(){return Ut},g:function(n){throw gt||(gt=n>>>0),gt},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),L[o>>2>>>0]=n.getUTCSeconds(),L[o+4>>2>>>0]=n.getUTCMinutes(),L[o+8>>2>>>0]=n.getUTCHours(),L[o+12>>2>>>0]=n.getUTCDate(),L[o+16>>2>>>0]=n.getUTCMonth(),L[o+20>>2>>>0]=n.getUTCFullYear()-1900,L[o+24>>2>>>0]=n.getUTCDay(),L[o+28>>2>>>0]=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),L[o>>2>>>0]=n.getSeconds(),L[o+4>>2>>>0]=n.getMinutes(),L[o+8>>2>>>0]=n.getHours(),L[o+12>>2>>>0]=n.getDate(),L[o+16>>2>>>0]=n.getMonth(),L[o+20>>2>>>0]=n.getFullYear()-1900,L[o+24>>2>>>0]=n.getDay(),L[o+28>>2>>>0]=(ct(n.getFullYear())?rr:Ht)[n.getMonth()]+n.getDate()-1|0,L[o+36>>2>>>0]=-(60*n.getTimezoneOffset()),i=new Date(n.getFullYear(),6,1).getTimezoneOffset();var s=new Date(n.getFullYear(),0,1).getTimezoneOffset();L[o+32>>2>>>0]=(i!=s&&n.getTimezoneOffset()==Math.min(s,i))|0},Qc:function(n){n>>>=0;var i=new Date(L[n+20>>2>>>0]+1900,L[n+16>>2>>>0],L[n+12>>2>>>0],L[n+8>>2>>>0],L[n+4>>2>>>0],L[n>>2>>>0],0),o=L[n+32>>2>>>0],s=i.getTimezoneOffset(),d=new Date(i.getFullYear(),6,1).getTimezoneOffset(),f=new Date(i.getFullYear(),0,1).getTimezoneOffset(),h=Math.min(f,d);return 0>o?L[n+32>>2>>>0]=+(d!=f&&h==s):0<o!=(h==s)&&(d=Math.max(f,d),i.setTime(i.getTime()+6e4*((0<o?h:d)-s))),L[n+24>>2>>>0]=i.getDay(),L[n+28>>2>>>0]=(ct(i.getFullYear())?rr:Ht)[i.getMonth()]+i.getDate()-1|0,L[n>>2>>>0]=i.getSeconds(),L[n+4>>2>>>0]=i.getMinutes(),L[n+8>>2>>>0]=i.getHours(),L[n+12>>2>>>0]=i.getDate(),L[n+16>>2>>>0]=i.getMonth(),L[n+20>>2>>>0]=i.getYear(),n=i.getTime()/1e3,Dt((at=n,1<=+Math.abs(at)?0<at?+Math.floor(at/4294967296)>>>0:~~+Math.ceil((at-+(~~at>>>0))/4294967296)>>>0:0)),n>>>0},Mc:function(){return-52},Nc:function(){},La:function(n,i,o){function s(b){return(b=b.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?b[1]:"GMT"}o>>>=0;var d=new Date().getFullYear(),f=new Date(d,0,1),h=new Date(d,6,1);d=f.getTimezoneOffset();var g=h.getTimezoneOffset();oe[n>>>0>>2>>>0]=60*Math.max(d,g),L[i>>>0>>2>>>0]=+(d!=g),n=s(f),i=s(h),n=nr(n),i=nr(i),g<d?(oe[o>>2>>>0]=n,oe[o+4>>2>>>0]=i):(oe[o>>2>>>0]=i,oe[o+4>>2>>>0]=n)},ja:()=>{nt("")},x:function(n,i,o){return n>>>=0,i=Ar(i>>>0,o>>>0),xt[n].apply(null,i)},wa:function(n,i,o){return n>>>=0,i=Ar(i>>>0,o>>>0),xt[n].apply(null,i)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(n,i,o){return i>>>=0,fe.copyWithin(n>>>0>>>0,i>>>0,i+(o>>>0)>>>0)},Ka:function(n){n>>>=0;var i=fe.length;if(4294901760<n)return!1;for(var o=1;4>=o;o*=2){var s=i*(1+.2/o);s=Math.min(s,n+100663296);var d=Math;s=Math.max(n,s);e:{d=d.min.call(d,4294901760,s+(65536-s%65536)%65536)-Y.buffer.byteLength+65535>>>16;try{Y.grow(d),Re();var f=1;break e}catch{}f=void 0}if(f)return!0}return!1},cb:function(n,i){n>>>=0,i>>>=0;var o=0;return Tr().forEach(function(s,d){var f=i+o;for(d=oe[n+4*d>>2>>>0]=f,f=0;f<s.length;++f)re[d++>>0>>>0]=s.charCodeAt(f);re[d>>0>>>0]=0,o+=s.length+1}),0},nb:function(n,i){n>>>=0,i>>>=0;var o=Tr();oe[n>>2>>>0]=o.length;var s=0;return o.forEach(function(d){s+=d.length+1}),oe[i>>2>>>0]=s,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(n,i,o,s){i>>>=0,o>>>=0,s>>>=0;for(var d=0,f=0;f<o;f++){var h=oe[i>>2>>>0],g=oe[i+4>>2>>>0];i+=8;for(var b=0;b<g;b++){var w=fe[h+b>>>0],$=Cn[n];w===0||w===10?((n===1?M:z)(_r($,0)),$.length=0):$.push(w)}d+=g}return oe[s>>2>>>0]=d,0},ia:uc,Sc:uf,M:Mc,K:sc,Uc:sf,Wc:nf,B:Cc,z:ic,b:Zd,Da:ef,aa:Hc,f:Kd,ra:tf,h:qd,F:Jc,i:tc,Vc:of,j:ec,t:Jd,r:ac,n:lc,W:fc,Y:Kc,J:gc,oa:Tc,ba:Oc,la:Yc,vb:wp,fb:Mp,yc:Cf,ab:Vp,db:jp,Sa:Kp,Rb:ep,Dc:yf,ib:Pp,Va:Fp,Nb:ip,eb:Dp,fc:Wf,Lc:lf,nc:Pf,gb:Bp,bb:zp,Bb:hp,jc:Df,mc:Rf,ec:Uf,Kc:df,Za:Np,$a:Wp,qb:_p,mb:Tp,_a:Up,hc:zf,Ib:up,lb:Ep,Ua:qp,Sb:Jf,Ic:ff,zc:$f,sc:Tf,pb:Ip,kc:Mf,Hb:lp,Gb:dp,c:Qd,_:xc,p:Xd,P:rf,Z:Vc,ha:bc,e:Yd,za:hc,G:Qc,da:Ic,O:Dc,ub:$p,fa:vc,d:rc,xa:$c,Fa:Zc,l:nc,va:_c,m:oc,ya:wc,ua:Ac,Ga:Gc,o:dc,V:Rc,ga:Pc,U:Bc,na:Wc,y:cc,A:pc,E:mc,X:Xc,ta:jc,ea:Sc,N:kc,L:Uc,D:Ec,ca:yc,T:zc,ka:af,R:Lc,sa:qc,Q:Fc,S:Nc,ic:jf,zb:yp,rb:xp,Db:pp,Ab:gp,Ac:wf,Mb:op,xb:bp,Eb:fp,Ob:np,cc:Nf,ob:Ap,Lb:ap,sb:Sp,kb:Op,qc:Of,Fc:hf,Ya:Hp,Pb:rp,wc:xf,jb:kp,uc:If,Hc:pf,vc:_f,Bc:vf,Xa:Gp,Ec:gf,wb:vp,Kb:sp,xc:Sf,Jc:cf,hb:Rp,Cb:mp,Xb:Yf,tb:Cp,Gc:mf,Yb:Kf,Qb:tp,gc:Vf,Cc:bf,pc:kf,Fb:cp,Wb:Zf,rc:Ef,lc:Bf,Wa:Lp,tc:Af,Tb:Qf,Vb:Xf,_b:Ff,$b:Lf,bc:Hf,Zb:qf,ac:Gf,v:function(n){return n>>>0},Ia:Er,H:function(n,i,o,s){return Er(n>>>0,i>>>0,o>>>0,s>>>0)}};(function(){function n(o){if(o=o.exports,o=Sn(o),_=o=Yp(o),Y=_.Xc,Re(),Be.unshift(_.Yc),Ae--,t.monitorRunDependencies&&t.monitorRunDependencies(Ae),Ae==0&&(St!==null&&(clearInterval(St),St=null),rt)){var s=rt;rt=null,s()}return o}var i={a:On};if(Ae++,t.monitorRunDependencies&&t.monitorRunDependencies(Ae),t.instantiateWasm)try{return t.instantiateWasm(i,n)}catch(o){z("Module.instantiateWasm callback failed with error: "+o),a(o)}return Qe(i,function(o){n(o.instance)}).catch(a),{}})(),t._OrtInit=(n,i)=>(t._OrtInit=_.Zc)(n,i),t._OrtGetLastError=(n,i)=>(t._OrtGetLastError=_._c)(n,i),t._OrtCreateSessionOptions=(n,i,o,s,d,f,h,g,b,w)=>(t._OrtCreateSessionOptions=_.$c)(n,i,o,s,d,f,h,g,b,w),t._OrtAppendExecutionProvider=(n,i)=>(t._OrtAppendExecutionProvider=_.ad)(n,i),t._OrtAddFreeDimensionOverride=(n,i,o)=>(t._OrtAddFreeDimensionOverride=_.bd)(n,i,o),t._OrtAddSessionConfigEntry=(n,i,o)=>(t._OrtAddSessionConfigEntry=_.cd)(n,i,o),t._OrtReleaseSessionOptions=n=>(t._OrtReleaseSessionOptions=_.dd)(n),t._OrtCreateSession=(n,i,o)=>(t._OrtCreateSession=_.ed)(n,i,o),t._OrtReleaseSession=n=>(t._OrtReleaseSession=_.fd)(n),t._OrtGetInputOutputCount=(n,i,o)=>(t._OrtGetInputOutputCount=_.gd)(n,i,o),t._OrtGetInputName=(n,i)=>(t._OrtGetInputName=_.hd)(n,i),t._OrtGetOutputName=(n,i)=>(t._OrtGetOutputName=_.id)(n,i),t._OrtFree=n=>(t._OrtFree=_.jd)(n),t._OrtCreateTensor=(n,i,o,s,d,f)=>(t._OrtCreateTensor=_.kd)(n,i,o,s,d,f),t._OrtGetTensorData=(n,i,o,s,d)=>(t._OrtGetTensorData=_.ld)(n,i,o,s,d),t._OrtReleaseTensor=n=>(t._OrtReleaseTensor=_.md)(n),t._OrtCreateRunOptions=(n,i,o,s)=>(t._OrtCreateRunOptions=_.nd)(n,i,o,s),t._OrtAddRunConfigEntry=(n,i,o)=>(t._OrtAddRunConfigEntry=_.od)(n,i,o),t._OrtReleaseRunOptions=n=>(t._OrtReleaseRunOptions=_.pd)(n),t._OrtCreateBinding=n=>(t._OrtCreateBinding=_.qd)(n),t._OrtBindInput=(n,i,o)=>(t._OrtBindInput=_.rd)(n,i,o),t._OrtBindOutput=(n,i,o,s)=>(t._OrtBindOutput=_.sd)(n,i,o,s),t._OrtClearBoundOutputs=n=>(t._OrtClearBoundOutputs=_.td)(n),t._OrtReleaseBinding=n=>(t._OrtReleaseBinding=_.ud)(n),t._OrtRunWithBinding=(n,i,o,s,d)=>(t._OrtRunWithBinding=_.vd)(n,i,o,s,d),t._OrtRun=(n,i,o,s,d,f,h,g)=>(t._OrtRun=_.wd)(n,i,o,s,d,f,h,g),t._OrtEndProfiling=n=>(t._OrtEndProfiling=_.xd)(n),t._JsepOutput=(n,i,o)=>(t._JsepOutput=_.yd)(n,i,o),t._JsepGetNodeName=n=>(t._JsepGetNodeName=_.zd)(n);var cr=t._malloc=n=>(cr=t._malloc=_.Ad)(n),Pr=t._free=n=>(Pr=t._free=_.Bd)(n),W=(n,i)=>(W=_.Dd)(n,i),Dt=n=>(Dt=_.Ed)(n),U=()=>(U=_.Fd)(),N=n=>(N=_.Gd)(n),fr=n=>(fr=_.Hd)(n),Lt=n=>(Lt=_.Id)(n),jt=n=>(jt=_.Jd)(n),Rr=(n,i,o)=>(Rr=_.Kd)(n,i,o),Br=n=>(Br=_.Ld)(n),Mr=t.dynCall_vi=(n,i)=>(Mr=t.dynCall_vi=_.Md)(n,i),Dr=t.dynCall_vii=(n,i,o)=>(Dr=t.dynCall_vii=_.Nd)(n,i,o),jr=t.dynCall_iiii=(n,i,o,s)=>(jr=t.dynCall_iiii=_.Od)(n,i,o,s),pr=t.dynCall_iii=(n,i,o)=>(pr=t.dynCall_iii=_.Pd)(n,i,o),zr=t.dynCall_ii=(n,i)=>(zr=t.dynCall_ii=_.Qd)(n,i),kn=t.dynCall_iiiiiii=(n,i,o,s,d,f,h)=>(kn=t.dynCall_iiiiiii=_.Rd)(n,i,o,s,d,f,h),Ve=t.dynCall_v=n=>(Ve=t.dynCall_v=_.Sd)(n),mr=t.dynCall_iiiiii=(n,i,o,s,d,f)=>(mr=t.dynCall_iiiiii=_.Td)(n,i,o,s,d,f),hr=t.dynCall_iiij=(n,i,o,s,d)=>(hr=t.dynCall_iiij=_.Ud)(n,i,o,s,d),Vr=t.dynCall_iiiii=(n,i,o,s,d)=>(Vr=t.dynCall_iiiii=_.Vd)(n,i,o,s,d),gr=t.dynCall_viii=(n,i,o,s)=>(gr=t.dynCall_viii=_.Wd)(n,i,o,s),Wr=t.dynCall_j=n=>(Wr=t.dynCall_j=_.Xd)(n),Ur=t.dynCall_i=n=>(Ur=t.dynCall_i=_.Yd)(n),Nr=t.dynCall_iij=(n,i,o,s)=>(Nr=t.dynCall_iij=_.Zd)(n,i,o,s),Hr=t.dynCall_iiiiij=(n,i,o,s,d,f,h)=>(Hr=t.dynCall_iiiiij=_._d)(n,i,o,s,d,f,h),Gr=t.dynCall_vij=(n,i,o,s)=>(Gr=t.dynCall_vij=_.$d)(n,i,o,s),Pn=t.dynCall_viiiii=(n,i,o,s,d,f)=>(Pn=t.dynCall_viiiii=_.ae)(n,i,o,s,d,f),Lr=t.dynCall_viiii=(n,i,o,s,d)=>(Lr=t.dynCall_viiii=_.be)(n,i,o,s,d),Fr=t.dynCall_iiiiiiii=(n,i,o,s,d,f,h,g)=>(Fr=t.dynCall_iiiiiiii=_.ce)(n,i,o,s,d,f,h,g),qr=t.dynCall_fi=(n,i)=>(qr=t.dynCall_fi=_.de)(n,i),Rn=t.dynCall_fii=(n,i,o)=>(Rn=t.dynCall_fii=_.ee)(n,i,o),Bn=t.dynCall_ji=(n,i)=>(Bn=t.dynCall_ji=_.fe)(n,i),Kr=t.dynCall_di=(n,i)=>(Kr=t.dynCall_di=_.ge)(n,i),Ft=t.dynCall_jii=(n,i,o)=>(Ft=t.dynCall_jii=_.he)(n,i,o),Mn=t.dynCall_dii=(n,i,o)=>(Mn=t.dynCall_dii=_.ie)(n,i,o),bt=t.dynCall_iiiiiiiii=(n,i,o,s,d,f,h,g,b)=>(bt=t.dynCall_iiiiiiiii=_.je)(n,i,o,s,d,f,h,g,b),pt=t.dynCall_viij=(n,i,o,s,d)=>(pt=t.dynCall_viij=_.ke)(n,i,o,s,d),Yr=t.dynCall_viiiiii=(n,i,o,s,d,f,h)=>(Yr=t.dynCall_viiiiii=_.le)(n,i,o,s,d,f,h),qt=t.dynCall_vijj=(n,i,o,s,d,f)=>(qt=t.dynCall_vijj=_.me)(n,i,o,s,d,f),Zr=t.dynCall_viiiiiii=(n,i,o,s,d,f,h,g)=>(Zr=t.dynCall_viiiiiii=_.ne)(n,i,o,s,d,f,h,g),Xr=t.dynCall_iiiiiiiiii=(n,i,o,s,d,f,h,g,b,w)=>(Xr=t.dynCall_iiiiiiiiii=_.oe)(n,i,o,s,d,f,h,g,b,w),Dn=t.dynCall_viiiiiiii=(n,i,o,s,d,f,h,g,b)=>(Dn=t.dynCall_viiiiiiii=_.pe)(n,i,o,s,d,f,h,g,b),yr=t.dynCall_iiiiijiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(yr=t.dynCall_iiiiijiiiii=_.qe)(n,i,o,s,d,f,h,g,b,w,$,I),jn=t.dynCall_vijjjiiij=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(jn=t.dynCall_vijjjiiij=_.re)(n,i,o,s,d,f,h,g,b,w,$,I,E),zn=t.dynCall_viiji=(n,i,o,s,d,f)=>(zn=t.dynCall_viiji=_.se)(n,i,o,s,d,f),Vn=t.dynCall_viijiii=(n,i,o,s,d,f,h,g)=>(Vn=t.dynCall_viijiii=_.te)(n,i,o,s,d,f,h,g),Wn=t.dynCall_viiiiij=(n,i,o,s,d,f,h,g)=>(Wn=t.dynCall_viiiiij=_.ue)(n,i,o,s,d,f,h,g),Un=t.dynCall_viiiiiiiii=(n,i,o,s,d,f,h,g,b,w)=>(Un=t.dynCall_viiiiiiiii=_.ve)(n,i,o,s,d,f,h,g,b,w),Nn=t.dynCall_viid=(n,i,o,s)=>(Nn=t.dynCall_viid=_.we)(n,i,o,s),Hn=t.dynCall_iiiiiiiij=(n,i,o,s,d,f,h,g,b,w)=>(Hn=t.dynCall_iiiiiiiij=_.xe)(n,i,o,s,d,f,h,g,b,w),Gn=t.dynCall_iiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(Gn=t.dynCall_iiiiiiiiiiii=_.ye)(n,i,o,s,d,f,h,g,b,w,$,I),Kt=t.dynCall_viiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(Kt=t.dynCall_viiiiiiiiiiiii=_.ze)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),br=t.dynCall_viijjjiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(br=t.dynCall_viijjjiiiiii=_.Ae)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),Qr=t.dynCall_viiijiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(Qr=t.dynCall_viiijiiiiiii=_.Be)(n,i,o,s,d,f,h,g,b,w,$,I,E),Jr=t.dynCall_viffiii=(n,i,o,s,d,f,h)=>(Jr=t.dynCall_viffiii=_.Ce)(n,i,o,s,d,f,h),en=t.dynCall_viiijjjii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(en=t.dynCall_viiijjjii=_.De)(n,i,o,s,d,f,h,g,b,w,$,I),vr=t.dynCall_viifiii=(n,i,o,s,d,f,h)=>(vr=t.dynCall_viifiii=_.Ee)(n,i,o,s,d,f,h),wr=t.dynCall_viiiiidiidi=(n,i,o,s,d,f,h,g,b,w,$)=>(wr=t.dynCall_viiiiidiidi=_.Fe)(n,i,o,s,d,f,h,g,b,w,$),tn=t.dynCall_viiiiiiiiidi=(n,i,o,s,d,f,h,g,b,w,$,I)=>(tn=t.dynCall_viiiiiiiiidi=_.Ge)(n,i,o,s,d,f,h,g,b,w,$,I),rn=t.dynCall_vjiiiiii=(n,i,o,s,d,f,h,g,b)=>(rn=t.dynCall_vjiiiiii=_.He)(n,i,o,s,d,f,h,g,b),nn=t.dynCall_jiii=(n,i,o,s)=>(nn=t.dynCall_jiii=_.Ie)(n,i,o,s),$r=t.dynCall_viiid=(n,i,o,s,d)=>($r=t.dynCall_viiid=_.Je)(n,i,o,s,d),Yt=t.dynCall_viiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(Yt=t.dynCall_viiiiiiiiiii=_.Ke)(n,i,o,s,d,f,h,g,b,w,$,I),Cr=t.dynCall_vijjjjjjjjjjjjji=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht)=>(Cr=t.dynCall_vijjjjjjjjjjjjji=_.Le)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht),on=t.dynCall_viiiji=(n,i,o,s,d,f,h)=>(on=t.dynCall_viiiji=_.Me)(n,i,o,s,d,f,h),an=t.dynCall_vijjjiiji=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(an=t.dynCall_vijjjiiji=_.Ne)(n,i,o,s,d,f,h,g,b,w,$,I,E),sn=t.dynCall_iiiji=(n,i,o,s,d,f)=>(sn=t.dynCall_iiiji=_.Oe)(n,i,o,s,d,f),un=t.dynCall_iiijiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(un=t.dynCall_iiijiiiiiiiiii=_.Pe)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),ln=t.dynCall_vj=(n,i,o)=>(ln=t.dynCall_vj=_.Qe)(n,i,o),Ln=t.dynCall_jjj=(n,i,o,s,d)=>(Ln=t.dynCall_jjj=_.Re)(n,i,o,s,d),Zt=t.dynCall_iiijiiiiii=(n,i,o,s,d,f,h,g,b,w,$)=>(Zt=t.dynCall_iiijiiiiii=_.Se)(n,i,o,s,d,f,h,g,b,w,$),dn=t.dynCall_viiff=(n,i,o,s,d)=>(dn=t.dynCall_viiff=_.Te)(n,i,o,s,d),c=t.dynCall_viiiiiff=(n,i,o,s,d,f,h,g)=>(c=t.dynCall_viiiiiff=_.Ue)(n,i,o,s,d,f,h,g),v=t.dynCall_vfiii=(n,i,o,s,d)=>(v=t.dynCall_vfiii=_.Ve)(n,i,o,s,d),x=t.dynCall_viiiiff=(n,i,o,s,d,f,h)=>(x=t.dynCall_viiiiff=_.We)(n,i,o,s,d,f,h),B=t.dynCall_viiiiiiiiifiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(B=t.dynCall_viiiiiiiiifiii=_.Xe)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),H=t.dynCall_viiiiiiiijj=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(H=t.dynCall_viiiiiiiijj=_.Ye)(n,i,o,s,d,f,h,g,b,w,$,I,E),K=t.dynCall_iiiiiiiiiiiiiifii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)=>(K=t.dynCall_iiiiiiiiiiiiiifii=_.Ze)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q),ee=t.dynCall_viiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(ee=t.dynCall_viiiiiiiiiiii=_._e)(n,i,o,s,d,f,h,g,b,w,$,I,E),pe=t.dynCall_ij=(n,i,o)=>(pe=t.dynCall_ij=_.$e)(n,i,o),de=t.dynCall_iiiiiiiiiiiiiiiiifii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)=>(de=t.dynCall_iiiiiiiiiiiiiiiiifii=_.af)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve),ce=t.dynCall_vijjiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(ce=t.dynCall_vijjiiiiii=_.bf)(n,i,o,s,d,f,h,g,b,w,$,I),ge=t.dynCall_iiiijjj=(n,i,o,s,d,f,h,g,b,w)=>(ge=t.dynCall_iiiijjj=_.cf)(n,i,o,s,d,f,h,g,b,w),_e=t.dynCall_viiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$)=>(_e=t.dynCall_viiiiiiiiii=_.df)(n,i,o,s,d,f,h,g,b,w,$),Ee=t.dynCall_iiijjj=(n,i,o,s,d,f,h,g,b)=>(Ee=t.dynCall_iiijjj=_.ef)(n,i,o,s,d,f,h,g,b),F=t.dynCall_fffffff=(n,i,o,s,d,f,h)=>(F=t.dynCall_fffffff=_.ff)(n,i,o,s,d,f,h),ye=t.dynCall_viiiij=(n,i,o,s,d,f,h)=>(ye=t.dynCall_viiiij=_.gf)(n,i,o,s,d,f,h),Te=t.dynCall_viijj=(n,i,o,s,d,f,h)=>(Te=t.dynCall_viijj=_.hf)(n,i,o,s,d,f,h),At=t.dynCall_vjjjjjjffiifiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue)=>(At=t.dynCall_vjjjjjjffiifiiiiii=_.jf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue),cn=t.dynCall_viiiiiiffiifiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)=>(cn=t.dynCall_viiiiiiffiifiiiii=_.kf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q),io=t.dynCall_viiiiiiffifiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(io=t.dynCall_viiiiiiffifiiiii=_.lf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),oo=t.dynCall_viiiiiiffiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(oo=t.dynCall_viiiiiiffiiiiii=_.mf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),ao=t.dynCall_vjjjjjjjjfffiifiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht)=>(ao=t.dynCall_vjjjjjjjjfffiifiiiiii=_.nf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht),so=t.dynCall_vjjjjjjfffifiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne)=>(so=t.dynCall_vjjjjjjfffifiiiiiii=_.of)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne),uo=t.dynCall_vjjjjjjfffifiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe)=>(uo=t.dynCall_vjjjjjjfffifiiiii=_.pf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe),lo=t.dynCall_vjjjjjjjjfffiifiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt)=>(lo=t.dynCall_vjjjjjjjjfffiifiiiii=_.qf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt),co=t.dynCall_vijjfffiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(co=t.dynCall_vijjfffiii=_.rf)(n,i,o,s,d,f,h,g,b,w,$,I),fo=t.dynCall_vijiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(fo=t.dynCall_vijiiiiiiii=_.sf)(n,i,o,s,d,f,h,g,b,w,$,I),po=t.dynCall_vijjjjjjifiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e)=>(po=t.dynCall_vijjjjjjifiiiii=_.tf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e),mo=t.dynCall_vjjjjjiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(mo=t.dynCall_vjjjjjiiii=_.uf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),ho=t.dynCall_vjjjjfiii=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(ho=t.dynCall_vjjjjfiii=_.vf)(n,i,o,s,d,f,h,g,b,w,$,I,E),go=t.dynCall_viifi=(n,i,o,s,d)=>(go=t.dynCall_viifi=_.wf)(n,i,o,s,d),yo=t.dynCall_iiiiiji=(n,i,o,s,d,f,h,g)=>(yo=t.dynCall_iiiiiji=_.xf)(n,i,o,s,d,f,h,g),bo=t.dynCall_vijjii=(n,i,o,s,d,f,h,g)=>(bo=t.dynCall_vijjii=_.yf)(n,i,o,s,d,f,h,g),vo=t.dynCall_viiijiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I)=>(vo=t.dynCall_viiijiiiiii=_.zf)(n,i,o,s,d,f,h,g,b,w,$,I),wo=t.dynCall_viiiiijjiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(wo=t.dynCall_viiiiijjiiiii=_.Af)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),$o=t.dynCall_iiiiji=(n,i,o,s,d,f,h)=>($o=t.dynCall_iiiiji=_.Bf)(n,i,o,s,d,f,h),Co=t.dynCall_viiiiijiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(Co=t.dynCall_viiiiijiiiiii=_.Cf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),So=t.dynCall_viiiijii=(n,i,o,s,d,f,h,g,b)=>(So=t.dynCall_viiiijii=_.Df)(n,i,o,s,d,f,h,g,b),xo=t.dynCall_viijjiii=(n,i,o,s,d,f,h,g,b,w)=>(xo=t.dynCall_viijjiii=_.Ef)(n,i,o,s,d,f,h,g,b,w),_o=t.dynCall_ijii=(n,i,o,s,d)=>(_o=t.dynCall_ijii=_.Ff)(n,i,o,s,d),Io=t.dynCall_jjjjjjj=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(Io=t.dynCall_jjjjjjj=_.Gf)(n,i,o,s,d,f,h,g,b,w,$,I,E),Ao=t.dynCall_jjjjjj=(n,i,o,s,d,f,h,g,b,w,$)=>(Ao=t.dynCall_jjjjjj=_.Hf)(n,i,o,s,d,f,h,g,b,w,$),To=t.dynCall_vijjjjiij=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(To=t.dynCall_vijjjjiij=_.If)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),Eo=t.dynCall_viiiiijij=(n,i,o,s,d,f,h,g,b,w,$)=>(Eo=t.dynCall_viiiiijij=_.Jf)(n,i,o,s,d,f,h,g,b,w,$),Oo=t.dynCall_viiiiiijij=(n,i,o,s,d,f,h,g,b,w,$,I)=>(Oo=t.dynCall_viiiiiijij=_.Kf)(n,i,o,s,d,f,h,g,b,w,$,I),ko=t.dynCall_vijiii=(n,i,o,s,d,f,h)=>(ko=t.dynCall_vijiii=_.Lf)(n,i,o,s,d,f,h),Po=t.dynCall_viiiiiiiiifi=(n,i,o,s,d,f,h,g,b,w,$,I)=>(Po=t.dynCall_viiiiiiiiifi=_.Mf)(n,i,o,s,d,f,h,g,b,w,$,I),Ro=t.dynCall_iiijiiii=(n,i,o,s,d,f,h,g,b)=>(Ro=t.dynCall_iiijiiii=_.Nf)(n,i,o,s,d,f,h,g,b),Bo=t.dynCall_viiiiiijjiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(Bo=t.dynCall_viiiiiijjiiiii=_.Of)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),Mo=t.dynCall_viiiiiiijiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(Mo=t.dynCall_viiiiiiijiiiiii=_.Pf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),Do=t.dynCall_vif=(n,i,o)=>(Do=t.dynCall_vif=_.Qf)(n,i,o),jo=t.dynCall_viif=(n,i,o,s)=>(jo=t.dynCall_viif=_.Rf)(n,i,o,s),zo=t.dynCall_viiiiiifii=(n,i,o,s,d,f,h,g,b,w)=>(zo=t.dynCall_viiiiiifii=_.Sf)(n,i,o,s,d,f,h,g,b,w),Vo=t.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe)=>(Vo=t.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=_.Tf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe),Wo=t.dynCall_viijji=(n,i,o,s,d,f,h,g)=>(Wo=t.dynCall_viijji=_.Uf)(n,i,o,s,d,f,h,g),Uo=t.dynCall_iiiiiiiiiiiji=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(Uo=t.dynCall_iiiiiiiiiiiji=_.Vf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),No=t.dynCall_viifiifijjjii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(No=t.dynCall_viifiifijjjii=_.Wf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),Ho=t.dynCall_viiiiiiiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e)=>(Ho=t.dynCall_viiiiiiiiiiiiiiiiiiii=_.Xf)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e),Go=t.dynCall_iif=(n,i,o)=>(Go=t.dynCall_iif=_.Yf)(n,i,o),Lo=t.dynCall_viiiiifiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(Lo=t.dynCall_viiiiifiiiiii=_.Zf)(n,i,o,s,d,f,h,g,b,w,$,I,E),Fo=t.dynCall_vijiiiiiiijjii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)=>(Fo=t.dynCall_vijiiiiiiijjii=_._f)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q),qo=t.dynCall_iiiiid=(n,i,o,s,d,f)=>(qo=t.dynCall_iiiiid=_.$f)(n,i,o,s,d,f),Ko=t.dynCall_viiiijjj=(n,i,o,s,d,f,h,g,b,w,$)=>(Ko=t.dynCall_viiiijjj=_.ag)(n,i,o,s,d,f,h,g,b,w,$),Yo=t.dynCall_viiiiiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le)=>(Yo=t.dynCall_viiiiiiiiiiiiiiiiii=_.bg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le),Zo=t.dynCall_viiiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)=>(Zo=t.dynCall_viiiiiiiiiiiiiiii=_.cg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q),Xo=t.dynCall_viiiiiiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)=>(Xo=t.dynCall_viiiiiiiiiiiiiiiiiii=_.dg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve),Qo=t.dynCall_viiiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(Qo=t.dynCall_viiiiiiiiiiiiiii=_.eg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),Jo=t.dynCall_viiiiiiijjj=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(Jo=t.dynCall_viiiiiiijjj=_.fg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),ea=t.dynCall_iiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$)=>(ea=t.dynCall_iiiiiiiiiii=_.gg)(n,i,o,s,d,f,h,g,b,w,$),ta=t.dynCall_iiiiiiiiiiiiiiiiiifi=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)=>(ta=t.dynCall_iiiiiiiiiiiiiiiiiifi=_.hg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve),ra=t.dynCall_viiif=(n,i,o,s,d)=>(ra=t.dynCall_viiif=_.ig)(n,i,o,s,d),na=t.dynCall_iijjj=(n,i,o,s,d,f,h,g)=>(na=t.dynCall_iijjj=_.jg)(n,i,o,s,d,f,h,g),ia=t.dynCall_viiiiji=(n,i,o,s,d,f,h,g)=>(ia=t.dynCall_viiiiji=_.kg)(n,i,o,s,d,f,h,g),oa=t.dynCall_iijjji=(n,i,o,s,d,f,h,g,b)=>(oa=t.dynCall_iijjji=_.lg)(n,i,o,s,d,f,h,g,b),aa=t.dynCall_ijijji=(n,i,o,s,d,f,h,g,b)=>(aa=t.dynCall_ijijji=_.mg)(n,i,o,s,d,f,h,g,b),sa=t.dynCall_viiij=(n,i,o,s,d,f)=>(sa=t.dynCall_viiij=_.ng)(n,i,o,s,d,f),ua=t.dynCall_viiijjiii=(n,i,o,s,d,f,h,g,b,w,$)=>(ua=t.dynCall_viiijjiii=_.og)(n,i,o,s,d,f,h,g,b,w,$),la=t.dynCall_iiiiijji=(n,i,o,s,d,f,h,g,b,w)=>(la=t.dynCall_iiiiijji=_.pg)(n,i,o,s,d,f,h,g,b,w),da=t.dynCall_viji=(n,i,o,s,d)=>(da=t.dynCall_viji=_.qg)(n,i,o,s,d),ca=t.dynCall_iiiifi=(n,i,o,s,d,f)=>(ca=t.dynCall_iiiifi=_.rg)(n,i,o,s,d,f),fa=t.dynCall_iiijii=(n,i,o,s,d,f,h)=>(fa=t.dynCall_iiijii=_.sg)(n,i,o,s,d,f,h),pa=t.dynCall_iiiiiiiiijii=(n,i,o,s,d,f,h,g,b,w,$,I,E)=>(pa=t.dynCall_iiiiiiiiijii=_.tg)(n,i,o,s,d,f,h,g,b,w,$,I,E),ma=t.dynCall_iiiijjii=(n,i,o,s,d,f,h,g,b,w)=>(ma=t.dynCall_iiiijjii=_.ug)(n,i,o,s,d,f,h,g,b,w),ha=t.dynCall_iiiiiijjjii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(ha=t.dynCall_iiiiiijjjii=_.vg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),ga=t.dynCall_iiijiii=(n,i,o,s,d,f,h,g)=>(ga=t.dynCall_iiijiii=_.wg)(n,i,o,s,d,f,h,g),ya=t.dynCall_iiiiiiiijjjfi=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)=>(ya=t.dynCall_iiiiiiiijjjfi=_.xg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V),ba=t.dynCall_iijiiii=(n,i,o,s,d,f,h,g)=>(ba=t.dynCall_iijiiii=_.yg)(n,i,o,s,d,f,h,g),va=t.dynCall_iijjjii=(n,i,o,s,d,f,h,g,b,w)=>(va=t.dynCall_iijjjii=_.zg)(n,i,o,s,d,f,h,g,b,w),wa=t.dynCall_iiji=(n,i,o,s,d)=>(wa=t.dynCall_iiji=_.Ag)(n,i,o,s,d),$a=t.dynCall_viiijiiiii=(n,i,o,s,d,f,h,g,b,w,$)=>($a=t.dynCall_viiijiiiii=_.Bg)(n,i,o,s,d,f,h,g,b,w,$),Ca=t.dynCall_iid=(n,i,o)=>(Ca=t.dynCall_iid=_.Cg)(n,i,o),Sa=t.dynCall_iiif=(n,i,o,s)=>(Sa=t.dynCall_iiif=_.Dg)(n,i,o,s),xa=t.dynCall_vidi=(n,i,o,s)=>(xa=t.dynCall_vidi=_.Eg)(n,i,o,s),_a=t.dynCall_vjiii=(n,i,o,s,d,f)=>(_a=t.dynCall_vjiii=_.Fg)(n,i,o,s,d,f),Ia=t.dynCall_iiiij=(n,i,o,s,d,f)=>(Ia=t.dynCall_iiiij=_.Gg)(n,i,o,s,d,f),Aa=t.dynCall_viiijii=(n,i,o,s,d,f,h,g)=>(Aa=t.dynCall_viiijii=_.Hg)(n,i,o,s,d,f,h,g),Ta=t.dynCall_viijiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C)=>(Ta=t.dynCall_viijiiiiiiiii=_.Ig)(n,i,o,s,d,f,h,g,b,w,$,I,E,C),Ea=t.dynCall_fiiii=(n,i,o,s,d)=>(Ea=t.dynCall_fiiii=_.Jg)(n,i,o,s,d),Oa=t.dynCall_jfi=(n,i,o)=>(Oa=t.dynCall_jfi=_.Kg)(n,i,o),ka=t.dynCall_viiiiiiiiiiiiii=(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)=>(ka=t.dynCall_viiiiiiiiiiiiii=_.Lg)(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D),Pa=t.dynCall_jiij=(n,i,o,s,d)=>(Pa=t.dynCall_jiij=_.Mg)(n,i,o,s,d),Ra=t.dynCall_fiii=(n,i,o,s)=>(Ra=t.dynCall_fiii=_.Ng)(n,i,o,s),Ba=n=>(Ba=_.Og)(n),Ma=()=>(Ma=_.Pg)(),Da=n=>(Da=_.Qg)(n),ja=()=>(ja=_.Rg)();t.___start_em_js=1347937,t.___stop_em_js=1348098;function qd(n,i,o,s){var d=U();try{return jr(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function Kd(n,i,o){var s=U();try{return pr(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Yd(n,i,o){var s=U();try{Dr(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Zd(n,i){var o=U();try{return zr(n,i)}catch(s){if(N(o),s!==s+0)throw s;W(1,0)}}function Xd(n,i){var o=U();try{Mr(n,i)}catch(s){if(N(o),s!==s+0)throw s;W(1,0)}}function Qd(n){var i=U();try{Ve(n)}catch(o){if(N(i),o!==o+0)throw o;W(1,0)}}function Jd(n,i,o,s,d,f,h){var g=U();try{return kn(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function ec(n,i,o,s,d,f){var h=U();try{return mr(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function tc(n,i,o,s,d){var f=U();try{return Vr(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function rc(n,i,o,s){var d=U();try{gr(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function nc(n,i,o,s,d){var f=U();try{Lr(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function ic(n){var i=U();try{return Ur(n)}catch(o){if(N(i),o!==o+0)throw o;W(1,0)}}function oc(n,i,o,s,d,f){var h=U();try{Pn(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function ac(n,i,o,s,d,f,h,g){var b=U();try{return Fr(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function sc(n,i){var o=U();try{return qr(n,i)}catch(s){if(N(o),s!==s+0)throw s;W(1,0)}}function uc(n,i){var o=U();try{return Kr(n,i)}catch(s){if(N(o),s!==s+0)throw s;W(1,0)}}function lc(n,i,o,s,d,f,h,g,b){var w=U();try{return bt(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function dc(n,i,o,s,d,f,h){var g=U();try{Yr(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function cc(n,i,o,s,d,f,h,g){var b=U();try{Zr(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function fc(n,i,o,s,d,f,h,g,b,w){var $=U();try{return Xr(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function pc(n,i,o,s,d,f,h,g,b){var w=U();try{Dn(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function mc(n,i,o,s,d,f,h,g,b,w){var $=U();try{Un(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function hc(n,i,o,s){var d=U();try{Nn(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function gc(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{return Gn(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function yc(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{Kt(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function bc(n,i,o,s,d,f,h){var g=U();try{Jr(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function vc(n,i,o,s,d,f,h){var g=U();try{vr(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function wc(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{wr(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function $c(n,i,o,s,d){var f=U();try{$r(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Cc(n,i,o,s,d){var f=U();try{return Ea(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Sc(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{B(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function xc(n,i,o,s,d){var f=U();try{v(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function _c(n,i,o,s,d,f,h){var g=U();try{x(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function Ic(n,i,o,s,d){var f=U();try{dn(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Ac(n,i,o,s,d,f,h,g){var b=U();try{c(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function Tc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q){var ie=U();try{return K(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)}catch(le){if(N(ie),le!==le+0)throw le;W(1,0)}}function Ec(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{ee(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function Oc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve){var $e=U();try{return de(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)}catch(Ce){if(N($e),Ce!==Ce+0)throw Ce;W(1,0)}}function kc(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{_e(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function Pc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q){var ie=U();try{cn(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)}catch(le){if(N(ie),le!==le+0)throw le;W(1,0)}}function Rc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{io(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function Bc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{oo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function Mc(n,i,o,s,d,f,h){var g=U();try{return F(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function Dc(n,i,o,s,d){var f=U();try{go(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function jc(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{Po(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function zc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{ka(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function Vc(n,i,o){var s=U();try{Do(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Wc(n,i,o,s,d,f,h,g,b,w){var $=U();try{zo(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function Uc(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{Yt(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Nc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e){var Ce=U();try{Ho(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e)}catch(Oe){if(N(Ce),Oe!==Oe+0)throw Oe;W(1,0)}}function Hc(n,i,o){var s=U();try{return Go(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Gc(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{Lo(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function Lc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q){var ie=U();try{Zo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)}catch(le){if(N(ie),le!==le+0)throw le;W(1,0)}}function Fc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve){var $e=U();try{Xo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)}catch(Ce){if(N($e),Ce!==Ce+0)throw Ce;W(1,0)}}function qc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le){var ve=U();try{Yo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le)}catch($e){if(N(ve),$e!==$e+0)throw $e;W(1,0)}}function Kc(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{return ea(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function Yc(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve){var $e=U();try{return ta(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve)}catch(Ce){if(N($e),Ce!==Ce+0)throw Ce;W(1,0)}}function Zc(n,i,o,s,d){var f=U();try{ra(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Xc(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{tn(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Qc(n,i,o,s){var d=U();try{jo(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function Jc(n,i,o,s,d,f){var h=U();try{return ca(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function ef(n,i,o){var s=U();try{return Ca(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function tf(n,i,o,s){var d=U();try{return Sa(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function rf(n,i,o,s){var d=U();try{xa(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function nf(n,i,o,s){var d=U();try{return Ra(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function of(n,i,o,s,d,f){var h=U();try{return qo(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function af(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{Qo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function sf(n,i,o){var s=U();try{return Rn(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function uf(n,i,o){var s=U();try{return Mn(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function lf(n,i,o,s,d){var f=U();try{return hr(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function df(n,i,o,s){var d=U();try{return Nr(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function cf(n,i,o,s){var d=U();try{Gr(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function ff(n,i){var o=U();try{return Bn(n,i)}catch(s){if(N(o),s!==s+0)throw s;W(1,0)}}function pf(n,i,o,s,d){var f=U();try{pt(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function mf(n,i,o,s,d,f){var h=U();try{qt(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function hf(n,i,o,s,d,f,h,g){var b=U();try{Aa(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function gf(n,i,o,s,d,f,h){var g=U();try{Te(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function yf(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{return yr(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function bf(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{jn(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function vf(n,i,o,s,d,f,h,g){var b=U();try{Vn(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function wf(n,i,o,s,d,f,h,g){var b=U();try{Wn(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function $f(n,i,o){var s=U();try{return Ft(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Cf(n,i,o,s,d,f,h,g,b,w){var $=U();try{return Hn(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function Sf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{br(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function xf(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{Qr(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function _f(n,i,o,s,d,f){var h=U();try{zn(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function If(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{en(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Af(n,i,o,s,d,f,h,g,b){var w=U();try{rn(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function Tf(n,i,o,s){var d=U();try{return nn(n,i,o,s)}catch(f){if(N(d),f!==f+0)throw f;W(1,0)}}function Ef(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht){var Xt=U();try{Cr(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht)}catch(Qt){if(N(Xt),Qt!==Qt+0)throw Qt;W(1,0)}}function Of(n,i,o,s,d,f,h){var g=U();try{on(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function kf(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{an(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function Pf(n,i,o,s,d,f){var h=U();try{return sn(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function Rf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{return un(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function Bf(n,i,o){var s=U();try{ln(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Mf(n,i,o,s,d){var f=U();try{return Ln(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Df(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{return Zt(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function jf(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{H(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function zf(n,i,o){var s=U();try{return pe(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function Vf(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{ce(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Wf(n,i,o,s,d,f,h,g,b,w){var $=U();try{return ge(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function Uf(n,i,o,s,d,f,h,g,b){var w=U();try{return Ee(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function Nf(n,i,o,s,d,f,h){var g=U();try{ye(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function Hf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue){var Ne=U();try{At(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue)}catch(Ke){if(N(Ne),Ke!==Ke+0)throw Ke;W(1,0)}}function Gf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht){var Xt=U();try{ao(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt,ht)}catch(Qt){if(N(Xt),Qt!==Qt+0)throw Qt;W(1,0)}}function Lf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne){var Ke=U();try{so(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne)}catch(Xe){if(N(Ke),Xe!==Xe+0)throw Xe;W(1,0)}}function Ff(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe){var Ue=U();try{uo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe)}catch(Ne){if(N(Ue),Ne!==Ne+0)throw Ne;W(1,0)}}function qf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt){var ht=U();try{lo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe,mt)}catch(Xt){if(N(ht),Xt!==Xt+0)throw Xt;W(1,0)}}function Kf(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{co(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Yf(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{fo(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function Zf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e){var Ce=U();try{po(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e)}catch(Oe){if(N(Ce),Oe!==Oe+0)throw Oe;W(1,0)}}function Xf(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{mo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function Qf(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{ho(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function Jf(n,i,o){var s=U();try{return Oa(n,i,o)}catch(d){if(N(s),d!==d+0)throw d;W(1,0)}}function ep(n,i,o,s,d,f,h,g){var b=U();try{return yo(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function tp(n,i,o,s,d,f,h,g){var b=U();try{bo(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function rp(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{vo(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function np(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D){var V=U();try{wo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D)}catch(Q){if(N(V),Q!==Q+0)throw Q;W(1,0)}}function ip(n,i,o,s,d,f,h){var g=U();try{return $o(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function op(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{Co(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function ap(n,i,o,s,d,f,h,g,b){var w=U();try{So(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function sp(n,i,o,s,d,f,h,g,b,w){var $=U();try{xo(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function up(n,i,o,s,d){var f=U();try{return _o(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function lp(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{return Ao(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function dp(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{return Io(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function cp(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{To(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function fp(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{Eo(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function pp(n,i,o,s,d,f,h,g,b,w,$,I){var E=U();try{Oo(n,i,o,s,d,f,h,g,b,w,$,I)}catch(C){if(N(E),C!==C+0)throw C;W(1,0)}}function mp(n,i,o,s,d,f,h){var g=U();try{ko(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function hp(n,i,o,s,d,f,h,g,b){var w=U();try{return Ro(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function gp(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{Bo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function yp(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{Mo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function bp(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe){var mt=U();try{Vo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q,ie,le,ve,$e,Ce,Oe,Ue,Ne,Ke,Xe)}catch(ht){if(N(mt),ht!==ht+0)throw ht;W(1,0)}}function vp(n,i,o,s,d,f,h,g){var b=U();try{Wo(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function wp(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{return Uo(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function $p(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{No(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function Cp(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q){var ie=U();try{Fo(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V,Q)}catch(le){if(N(ie),le!==le+0)throw le;W(1,0)}}function Sp(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{Ko(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function xp(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{Jo(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function _p(n,i,o,s,d,f,h,g){var b=U();try{return na(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function Ip(n,i,o,s,d){var f=U();try{return Pa(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Ap(n,i,o,s,d,f,h,g){var b=U();try{ia(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function Tp(n,i,o,s,d,f,h,g,b){var w=U();try{return oa(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function Ep(n,i,o,s,d,f,h,g,b){var w=U();try{return aa(n,i,o,s,d,f,h,g,b)}catch($){if(N(w),$!==$+0)throw $;W(1,0)}}function Op(n,i,o,s,d,f){var h=U();try{sa(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function kp(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{ua(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function Pp(n,i,o,s,d,f,h,g,b,w){var $=U();try{return la(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function Rp(n,i,o,s,d){var f=U();try{da(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Bp(n,i,o,s,d,f,h){var g=U();try{return fa(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function Mp(n,i,o,s,d,f,h,g,b,w,$,I,E){var C=U();try{return pa(n,i,o,s,d,f,h,g,b,w,$,I,E)}catch(D){if(N(C),D!==D+0)throw D;W(1,0)}}function Dp(n,i,o,s,d,f,h,g,b,w){var $=U();try{return ma(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function jp(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{return ha(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function zp(n,i,o,s,d,f,h,g){var b=U();try{return ga(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function Vp(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V){var Q=U();try{return ya(n,i,o,s,d,f,h,g,b,w,$,I,E,C,D,V)}catch(ie){if(N(Q),ie!==ie+0)throw ie;W(1,0)}}function Wp(n,i,o,s,d,f,h,g){var b=U();try{return ba(n,i,o,s,d,f,h,g)}catch(w){if(N(b),w!==w+0)throw w;W(1,0)}}function Up(n,i,o,s,d,f,h,g,b,w){var $=U();try{return va(n,i,o,s,d,f,h,g,b,w)}catch(I){if(N($),I!==I+0)throw I;W(1,0)}}function Np(n,i,o,s,d){var f=U();try{return wa(n,i,o,s,d)}catch(h){if(N(f),h!==h+0)throw h;W(1,0)}}function Hp(n,i,o,s,d,f,h,g,b,w,$){var I=U();try{$a(n,i,o,s,d,f,h,g,b,w,$)}catch(E){if(N(I),E!==E+0)throw E;W(1,0)}}function Gp(n,i,o,s,d,f,h,g,b,w,$,I,E,C){var D=U();try{Ta(n,i,o,s,d,f,h,g,b,w,$,I,E,C)}catch(V){if(N(D),V!==V+0)throw V;W(1,0)}}function Lp(n,i,o,s,d,f){var h=U();try{_a(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function Fp(n,i,o,s,d,f){var h=U();try{return Ia(n,i,o,s,d,f)}catch(g){if(N(h),g!==g+0)throw g;W(1,0)}}function qp(n){var i=U();try{return Wr(n)}catch(o){if(N(i),o!==o+0)throw o;W(1,0)}}function Kp(n,i,o,s,d,f,h){var g=U();try{return Hr(n,i,o,s,d,f,h)}catch(b){if(N(g),b!==b+0)throw b;W(1,0)}}function Yp(n){n=Object.assign({},n);var i=s=>()=>s()>>>0,o=s=>d=>s(d)>>>0;return n.__errno_location=i(n.__errno_location),n.malloc=o(n.malloc),n.stackSave=i(n.stackSave),n.stackAlloc=o(n.stackAlloc),n}t.stackAlloc=fr,t.stackSave=U,t.stackRestore=N,t.UTF8ToString=it,t.stringToUTF8=(n,i,o)=>Ir(n,fe,i,o),t.lengthBytesUTF8=tr;var Fn;rt=function n(){Fn||za(),Fn||(rt=n)};function za(){function n(){if(!Fn&&(Fn=!0,t.calledRun=!0,!X)){if(Wt(Be),u(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;){var i=t.postRun.shift();Me.unshift(i)}Wt(Me)}}if(!(0<Ae)){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)De();Wt(ue),0<Ae||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),n()},1)):n())}}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return za(),r.ready}})();typeof Wa=="object"&&typeof _i=="object"?_i.exports=Va:typeof define=="function"&&define.amd&&define([],()=>Va)});var Na=fn(()=>{});var Ha=fn(()=>{});var Ga={};qn(Ga,{cpus:()=>rm});var rm,La=ae(()=>{rm=void 0});var Ka=fn((qa,Ii)=>{"use strict";var Fa=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(r={}){function t(){return Re.buffer!=Ae.buffer&&Ie(),Ae}function u(){return Re.buffer!=Ae.buffer&&Ie(),St}function a(){return Re.buffer!=Ae.buffer&&Ie(),rt}function p(){return Re.buffer!=Ae.buffer&&Ie(),nt}function m(){return Re.buffer!=Ae.buffer&&Ie(),ne}function y(){return Re.buffer!=Ae.buffer&&Ie(),we}var l=r,S,A;l.ready=new Promise((c,v)=>{S=c,A=v}),l.jsepInit=(c,v,x,B,H,K,ee,pe)=>{l.Qb=c,l.wb=v,l.yb=x,l.jb=B,l.xb=H,l.Ea=K,l.zb=ee,l.Ab=pe,v=(de,ce,ge)=>(..._e)=>{let Ee=pt,F=ce?.();_e=de(..._e);let ye=ce?.();return F!==ye&&(de=ye,ge(F),ce=ge=null),pt!=Ee?zn():_e},x=de=>async(...ce)=>{try{if(l.bb)throw Error("Session already started");let ge=l.bb={Fb:ce[0],errors:[]},_e=await de(...ce);if(l.bb!==ge)throw Error("Session mismatch");c.flush();let Ee=ge.errors;if(0<Ee.length){let F=await Promise.all(Ee);if(F=F.filter(ye=>ye),0<F.length)throw Error(F.join(`\n`))}return _e}finally{l.bb=null}},l._OrtRun=x(v(l._OrtRun,()=>l._OrtRun,de=>l._OrtRun=de)),l._OrtRunWithBinding=x(v(l._OrtRunWithBinding,()=>l._OrtRunWithBinding,de=>l._OrtRunWithBinding=de)),l._OrtBindInput=v(l._OrtBindInput,()=>l._OrtBindInput,de=>l._OrtBindInput=de),l.jsepRegisterBuffer=(de,ce,ge,_e)=>c.registerBuffer(de,ce,ge,_e),l.jsepUnregisterBuffers=de=>{c.unregisterBuffers(de)},l.jsepGetBuffer=de=>c.getBuffer(de),l.jsepCreateDownloader=(de,ce,ge)=>c.createDownloader(de,ce,ge)};var P=Object.assign({},l),T="./this.program",k=(c,v)=>{throw v},O=typeof window=="object",R=typeof importScripts=="function",j=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",M=l.ENVIRONMENT_IS_PTHREAD||!1,z="";function q(c){return l.locateFile?l.locateFile(c,z):z+c}var G,Y,_;if(j){var X=(Ci(),Sr($i)),J=(xi(),Sr(Si));z=R?J.dirname(z)+"/":__dirname+"/",G=(v,x)=>(v=v.startsWith("file://")?new URL(v):J.normalize(v),X.readFileSync(v,x?void 0:"utf8")),_=v=>(v=G(v,!0),v.buffer||(v=new Uint8Array(v)),v),Y=(v,x,B,H=!0)=>{v=v.startsWith("file://")?new URL(v):J.normalize(v),X.readFile(v,H?void 0:"utf8",(K,ee)=>{K?B(K):x(H?ee.buffer:ee)})},!l.thisProgram&&1<process.argv.length&&(T=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),k=(v,x)=>{throw process.exitCode=v,x},l.inspect=()=>"[Emscripten Module object]";let c;try{c=Na()}catch(v){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),v}global.Worker=c.Worker}else(O||R)&&(R?z=self.location.href:typeof document<"u"&&document.currentScript&&(z=document.currentScript.src),typeof e<"u"&&e&&(z=e),z.indexOf("blob:")!==0?z=z.substr(0,z.replace(/[?#].*/,"").lastIndexOf("/")+1):z="",j||(G=c=>{var v=new XMLHttpRequest;return v.open("GET",c,!1),v.send(null),v.responseText},R&&(_=c=>{var v=new XMLHttpRequest;return v.open("GET",c,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),Y=(c,v,x)=>{var B=new XMLHttpRequest;B.open("GET",c,!0),B.responseType="arraybuffer",B.onload=()=>{B.status==200||B.status==0&&B.response?v(B.response):x()},B.onerror=x,B.send(null)}));j&&typeof performance>"u"&&(global.performance=Ha().performance);var re=console.log.bind(console),fe=console.error.bind(console);j&&(re=(...c)=>X.writeSync(1,c.join(" ")+`\n`),fe=(...c)=>X.writeSync(2,c.join(" ")+`\n`));var L=l.print||re,oe=l.printErr||fe;Object.assign(l,P),P=null,l.thisProgram&&(T=l.thisProgram),l.quit&&(k=l.quit);var Se;l.wasmBinary&&(Se=l.wasmBinary);var me=l.noExitRuntime||!0;typeof WebAssembly!="object"&&yt("no native wasm support detected");var Re,ue,Be,Me=!1,De,Ae,St,rt,nt,ne,we;function Ie(){var c=Re.buffer;l.HEAP8=Ae=new Int8Array(c),l.HEAP16=new Int16Array(c),l.HEAP32=rt=new Int32Array(c),l.HEAPU8=St=new Uint8Array(c),l.HEAPU16=new Uint16Array(c),l.HEAPU32=nt=new Uint32Array(c),l.HEAPF32=ne=new Float32Array(c),l.HEAPF64=we=new Float64Array(c)}var tt=l.INITIAL_MEMORY||16777216;if(5242880<=tt||yt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+tt+"! (STACK_SIZE=5242880)"),M)Re=l.wasmMemory;else if(l.wasmMemory)Re=l.wasmMemory;else if(Re=new WebAssembly.Memory({initial:tt/65536,maximum:65536,shared:!0}),!(Re.buffer instanceof SharedArrayBuffer))throw oe("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),j&&oe("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ie(),tt=Re.buffer.byteLength;var st=[],Fe=[],Qe=[],at=0;function xt(){return me||0<at}var dt=0,Wt=null,_t=null;function Ut(){dt++,l.monitorRunDependencies&&l.monitorRunDependencies(dt)}function gt(){if(dt--,l.monitorRunDependencies&&l.monitorRunDependencies(dt),dt==0&&(Wt!==null&&(clearInterval(Wt),Wt=null),_t)){var c=_t;_t=null,c()}}function yt(c){throw l.onAbort&&l.onAbort(c),c="Aborted("+c+")",oe(c),Me=!0,De=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),A(c),c}function Nt(c){return c.startsWith("data:application/octet-stream;base64,")}var Mt;Mt="ort-wasm-simd-threaded.wasm",Nt(Mt)||(Mt=q(Mt));function _r(c){if(c==Mt&&Se)return new Uint8Array(Se);if(_)return _(c);throw"both async and sync fetching of the wasm failed"}function it(c){if(!Se&&(O||R)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(v=>{if(!v.ok)throw"failed to load wasm binary file at \'"+c+"\'";return v.arrayBuffer()}).catch(()=>_r(c));if(Y)return new Promise((v,x)=>{Y(c,B=>v(new Uint8Array(B)),x)})}return Promise.resolve().then(()=>_r(c))}function tr(c,v,x){return it(c).then(B=>WebAssembly.instantiate(B,v)).then(B=>B).then(x,B=>{oe("failed to asynchronously prepare wasm: "+B),yt(B)})}function Ir(c,v){var x=Mt;return Se||typeof WebAssembly.instantiateStreaming!="function"||Nt(x)||x.startsWith("file://")||j||typeof fetch!="function"?tr(x,c,v):fetch(x,{credentials:"same-origin"}).then(B=>WebAssembly.instantiateStreaming(B,c).then(v,function(H){return oe("wasm streaming compile failed: "+H),oe("falling back to ArrayBuffer instantiation"),tr(x,c,v)}))}var ct,rr={913596:c=>{l.Ea("Abs",c,void 0)},913647:c=>{l.Ea("Neg",c,void 0)},913698:c=>{l.Ea("Floor",c,void 0)},913751:c=>{l.Ea("Ceil",c,void 0)},913803:c=>{l.Ea("Reciprocal",c,void 0)},913861:c=>{l.Ea("Sqrt",c,void 0)},913913:c=>{l.Ea("Exp",c,void 0)},913964:c=>{l.Ea("Erf",c,void 0)},914015:c=>{l.Ea("Sigmoid",c,void 0)},914070:c=>{l.Ea("Log",c,void 0)},914121:c=>{l.Ea("Sin",c,void 0)},914172:c=>{l.Ea("Cos",c,void 0)},914223:c=>{l.Ea("Tan",c,void 0)},914274:c=>{l.Ea("Asin",c,void 0)},914326:c=>{l.Ea("Acos",c,void 0)},914378:c=>{l.Ea("Atan",c,void 0)},914430:c=>{l.Ea("Sinh",c,void 0)},914482:c=>{l.Ea("Cosh",c,void 0)},914534:c=>{l.Ea("Asinh",c,void 0)},914587:c=>{l.Ea("Acosh",c,void 0)},914640:c=>{l.Ea("Atanh",c,void 0)},914693:c=>{l.Ea("Tanh",c,void 0)},914745:c=>{l.Ea("Not",c,void 0)},914796:(c,v,x)=>{l.Ea("Clip",c,{min:v,max:x})},914865:c=>{l.Ea("Clip",c,void 0)},914917:(c,v)=>{l.Ea("Elu",c,{alpha:v})},914975:c=>{l.Ea("Relu",c,void 0)},915027:(c,v)=>{l.Ea("LeakyRelu",c,{alpha:v})},915091:(c,v)=>{l.Ea("ThresholdedRelu",c,{alpha:v})},915161:(c,v)=>{l.Ea("Cast",c,{to:v})},915219:c=>{l.Ea("Add",c,void 0)},915270:c=>{l.Ea("Sub",c,void 0)},915321:c=>{l.Ea("Mul",c,void 0)},915372:c=>{l.Ea("Div",c,void 0)},915423:c=>{l.Ea("Pow",c,void 0)},915474:c=>{l.Ea("Equal",c,void 0)},915527:c=>{l.Ea("Greater",c,void 0)},915582:c=>{l.Ea("GreaterOrEqual",c,void 0)},915644:c=>{l.Ea("Less",c,void 0)},915696:c=>{l.Ea("LessOrEqual",c,void 0)},915755:(c,v,x,B,H)=>{l.Ea("ReduceMean",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},915919:(c,v,x,B,H)=>{l.Ea("ReduceMax",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916082:(c,v,x,B,H)=>{l.Ea("ReduceMin",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916245:(c,v,x,B,H)=>{l.Ea("ReduceProd",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916409:(c,v,x,B,H)=>{l.Ea("ReduceSum",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916572:(c,v,x,B,H)=>{l.Ea("ReduceL1",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916734:(c,v,x,B,H)=>{l.Ea("ReduceL2",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},916896:(c,v,x,B,H)=>{l.Ea("ReduceLogSum",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917062:(c,v,x,B,H)=>{l.Ea("ReduceSumSquare",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917231:(c,v,x,B,H)=>{l.Ea("ReduceLogSumExp",c,{keepDims:!!v,noopWithEmptyAxes:!!x,axes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},917400:c=>{l.Ea("Where",c,void 0)},917453:(c,v,x)=>{l.Ea("Transpose",c,{perm:v?Array.from(a().subarray(x>>>0,x+v>>>0)):[]})},917566:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye)=>{l.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:v,dilations:[x],group:B,kernel_shape:[H],pads:[K,ee],strides:[pe],wIsConst:()=>!!t()[ce>>>0],outputPadding:ge?Array.from(a().subarray(_e>>>0,_e+ge>>>0)):[],outputShape:Ee?Array.from(a().subarray(F>>>0,F+Ee>>>0)):[],activation:Je(ye)})},917980:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F)=>{l.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(a().subarray(x>>>0,x+2>>>0)),group:B,kernelShape:Array.from(a().subarray(H>>>0,H+2>>>0)),pads:Array.from(a().subarray(K>>>0,K+4>>>0)),strides:Array.from(a().subarray(ee>>>0,ee+2>>>0)),wIsConst:()=>!!t()[de>>>0],outputPadding:0<ce?Array.from(a().subarray(ge>>>0,ge+ce>>>0)):[],outputShape:0<_e?Array.from(a().subarray(Ee>>>0,Ee+_e>>>0)):[],activation:Je(F)})},918537:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye)=>{l.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:v,dilations:[x],group:B,kernel_shape:[H],pads:[K,ee],strides:[pe],wIsConst:()=>!!t()[ce>>>0],outputPadding:ge?Array.from(a().subarray(_e>>>0,_e+ge>>>0)):[],outputShape:Ee?Array.from(a().subarray(F>>>0,F+Ee>>>0)):[],activation:Je(ye)})},918951:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F)=>{l.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(a().subarray(x>>>0,x+2>>>0)),group:B,kernelShape:Array.from(a().subarray(H>>>0,H+2>>>0)),pads:Array.from(a().subarray(K>>>0,K+4>>>0)),strides:Array.from(a().subarray(ee>>>0,ee+2>>>0)),wIsConst:()=>!!t()[de>>>0],outputPadding:0<ce?Array.from(a().subarray(ge>>>0,ge+ce>>>0)):[],outputShape:0<_e?Array.from(a().subarray(Ee>>>0,Ee+_e>>>0)):[],activation:Je(F)})},919508:(c,v)=>{l.Ea("GlobalAveragePool",c,{format:v?"NHWC":"NCHW"})},919599:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye,Te)=>{l.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:v,ceil_mode:x,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,_e,Ee],strides:[F,ye]})},919883:(c,v)=>{l.Ea("GlobalAveragePool",c,{format:v?"NHWC":"NCHW"})},919974:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye,Te)=>{l.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:v,ceil_mode:x,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,_e,Ee],strides:[F,ye]})},920258:(c,v)=>{l.Ea("GlobalMaxPool",c,{format:v?"NHWC":"NCHW"})},920345:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye,Te)=>{l.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:v,ceil_mode:x,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,_e,Ee],strides:[F,ye]})},920625:(c,v)=>{l.Ea("GlobalMaxPool",c,{format:v?"NHWC":"NCHW"})},920712:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye,Te)=>{l.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:v,ceil_mode:x,count_include_pad:B,storage_order:H,dilations:[K,ee],kernel_shape:[pe,de],pads:[ce,ge,_e,Ee],strides:[F,ye]})},920992:(c,v,x,B,H)=>{l.Ea("Gemm",c,{alpha:v,beta:x,transA:B,transB:H})},921096:c=>{l.Ea("MatMul",c,void 0)},921150:(c,v,x,B)=>{l.Ea("ArgMax",c,{keepDims:!!v,selectLastIndex:!!x,axis:B})},921258:(c,v,x,B)=>{l.Ea("ArgMin",c,{keepDims:!!v,selectLastIndex:!!x,axis:B})},921366:(c,v)=>{l.Ea("Softmax",c,{axis:v})},921429:(c,v)=>{l.Ea("Concat",c,{axis:v})},921489:(c,v,x,B,H)=>{l.Ea("Split",c,{axis:v,numOutputs:x,splitSizes:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},921634:c=>{l.Ea("Expand",c,void 0)},921688:(c,v)=>{l.Ea("Gather",c,{axis:Number(v)})},921759:(c,v)=>{l.Ea("GatherElements",c,{axis:Number(v)})},921838:(c,v,x,B,H,K,ee,pe,de,ce,ge)=>{l.Ea("Resize",c,{antialias:v,axes:x?Array.from(a().subarray(B>>>0,B+x>>>0)):[],coordinateTransformMode:Je(H),cubicCoeffA:K,excludeOutside:ee,extrapolationValue:pe,keepAspectRatioPolicy:Je(de),mode:Je(ce),nearestMode:Je(ge)})},922189:(c,v,x,B,H,K,ee)=>{l.Ea("Slice",c,{starts:v?Array.from(a().subarray(x>>>0,x+v>>>0)):[],ends:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[],axes:K?Array.from(a().subarray(ee>>>0,ee+K>>>0)):[]})},922420:c=>{l.Ea("Tile",c,void 0)},922472:(c,v,x)=>{l.Ea("LayerNormalization",c,{axis:Number(v),epsilon:Number(x)})},922579:(c,v,x)=>{l.Ea("InstanceNormalization",c,{epsilon:v,format:x?"NHWC":"NCHW"})},922693:(c,v,x)=>{l.Ea("InstanceNormalization",c,{epsilon:v,format:x?"NHWC":"NCHW"})},922807:c=>{l.Ea("Range",c,void 0)},922860:(c,v)=>{l.Ea("Einsum",c,{equation:Je(v)})},922941:(c,v,x,B,H)=>{l.Ea("Pad",c,{mode:v,value:x,pads:B?Array.from(a().subarray(H>>>0,H+B>>>0)):[]})},923073:(c,v,x,B,H,K)=>{l.Ea("BatchNormalization",c,{epsilon:v,momentum:x,spatial:!!H,trainingMode:!!B,format:K?"NHWC":"NCHW"})},923242:(c,v,x,B,H,K)=>{l.Ea("BatchNormalization",c,{epsilon:v,momentum:x,spatial:!!H,trainingMode:!!B,format:K?"NHWC":"NCHW"})},923411:(c,v,x)=>{l.Ea("CumSum",c,{exclusive:Number(v),reverse:Number(x)})},923508:(c,v,x,B,H,K,ee,pe,de)=>{l.Ea("Attention",c,{numHeads:v,isUnidirectional:x,maskFilterValue:B,scale:H,doRotary:K,qkvHiddenSizes:ee?Array.from(a().subarray(Number(pe)>>>0,Number(pe)+ee>>>0)):[],pastPresentShareBuffer:!!de})},923780:c=>{l.Ea("Gelu",c,void 0)},923832:(c,v,x,B,H,K)=>{l.Ea("MultiHeadAttention",c,{numHeads:v,isUnidirectional:x,maskFilterValue:B,scale:H,doRotary:K})},923991:c=>{l.Ea("BiasAdd",c,void 0)},924046:c=>{l.Ea("BiasSplitGelu",c,void 0)},924107:(c,v)=>{l.Ea("SkipLayerNormalization",c,{epsilon:v})},924188:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee)=>{l.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:v,dilations:[x],group:B,kernel_shape:[H],pads:K?Array.from(a().subarray(ee>>>0,ee+K>>>0)):[],strides:[pe],w_is_const:()=>!!t()[ce>>>0],activation:Je(ge),activation_params:_e?Array.from(m().subarray(Ee>>>0,Ee+_e>>>0)):[]})},924569:(c,v,x,B,H,K,ee,pe,de,ce,ge,_e,Ee,F,ye,Te)=>{l.Ea("Conv",c,{format:_e?"NHWC":"NCHW",auto_pad:v,dilations:[x,B],group:H,kernel_shape:[K,ee],pads:pe?Array.from(a().subarray(de>>>0,de+pe>>>0)):[],strides:[ce,ge],w_is_const:()=>!!t()[Ee>>>0],activation:Je(F),activation_params:ye?Array.from(m().subarray(Te>>>0,Te+ye>>>0)):[]})},924971:c=>{l.zb(c)},925005:(c,v)=>l.Ab(c,v,l.bb.Fb,l.bb.errors),925117:c=>l.wb(c),925150:c=>l.yb(c),925182:(c,v,x)=>{l.jb(c,v,x,!0)},925221:(c,v,x)=>{l.jb(c,v,x)}};function Ht(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function nr(c){c.terminate(),c.onmessage=()=>{}}function ir(c){(c=be.Qa[c])||yt(),be.Eb(c)}function Ar(c){var v=be.tb();if(!v)return 6;be.Ya.push(v),be.Qa[c.Xa]=v,v.Xa=c.Xa;var x={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return j&&v.unref(),v.postMessage(x,c.Mb),0}var or=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Tr=(c,v,x)=>{v>>>=0;var B=v+x;for(x=v;c[x]&&!(x>=B);)++x;if(16<x-v&&c.buffer&&or)return or.decode(c.buffer instanceof SharedArrayBuffer?c.slice(v,x):c.subarray(v,x));for(B="";v<x;){var H=c[v++];if(H&128){var K=c[v++]&63;if((H&224)==192)B+=String.fromCharCode((H&31)<<6|K);else{var ee=c[v++]&63;H=(H&240)==224?(H&15)<<12|K<<6|ee:(H&7)<<18|K<<12|ee<<6|c[v++]&63,65536>H?B+=String.fromCharCode(H):(H-=65536,B+=String.fromCharCode(55296|H>>10,56320|H&1023))}}else B+=String.fromCharCode(H)}return B},Je=(c,v)=>(c>>>=0)?Tr(u(),c,v):"";function Cn(c){if(M)return Ve(1,1,c);De=c,xt()||(be.Hb(),l.onExit&&l.onExit(c),Me=!0),k(c,new Ht(c))}var ar=c=>{if(De=c,M)throw Er(c),"unwind";Cn(c)},be={ab:[],Ya:[],mb:[],Qa:{},gb:function(){M?be.vb():be.ub()},ub:function(){st.unshift(()=>{Ut(),be.Bb(()=>gt())})},vb:function(){be.receiveObjectTransfer=be.Db,be.threadInitTLS=be.lb,be.setExitStatus=be.kb,me=!1},kb:function(c){De=c},Sb:["$terminateWorker"],Hb:function(){for(var c of be.Ya)nr(c);for(c of be.ab)nr(c);be.ab=[],be.Ya=[],be.Qa=[]},Eb:function(c){var v=c.Xa;delete be.Qa[v],be.ab.push(c),be.Ya.splice(be.Ya.indexOf(c),1),c.Xa=0,vr(v)},Db:function(){},lb:function(){be.mb.forEach(c=>c())},Cb:c=>new Promise(v=>{c.onmessage=K=>{K=K.data;var ee=K.cmd;if(K.targetThread&&K.targetThread!=Kt()){var pe=be.Qa[K.Rb];pe?pe.postMessage(K,K.transferList):oe(\'Internal error! Worker sent a message "\'+ee+\'" to target pthread \'+K.targetThread+", but that thread no longer exists!")}else ee==="checkMailbox"?Lt():ee==="spawnThread"?Ar(K):ee==="cleanupThread"?ir(K.thread):ee==="killThread"?(K=K.thread,ee=be.Qa[K],delete be.Qa[K],nr(ee),vr(K),be.Ya.splice(be.Ya.indexOf(ee),1),ee.Xa=0):ee==="cancelThread"?be.Qa[K.thread].postMessage({cmd:"cancel"}):ee==="loaded"?(c.loaded=!0,v(c)):ee==="alert"?alert("Thread "+K.threadId+": "+K.text):K.target==="setimmediate"?c.postMessage(K):ee==="callHandler"?l[K.handler](...K.args):ee&&oe("worker sent an unknown command "+ee)},c.onerror=K=>{throw oe("worker sent an error! "+K.filename+":"+K.lineno+": "+K.message),K},j&&(c.on("message",function(K){c.onmessage({data:K})}),c.on("error",function(K){c.onerror(K)}));var x=[],B=["onExit","onAbort","print","printErr"],H;for(H of B)l.hasOwnProperty(H)&&x.push(H);c.postMessage({cmd:"load",handlers:x,urlOrBlob:l.mainScriptUrlOrBlob||e,wasmMemory:Re,wasmModule:Be})}),Bb:function(c){c()},qb:function(){var c=q("ort-wasm-simd-threaded.worker.js");c=new Worker(c),be.ab.push(c)},tb:function(){return be.ab.length==0&&(be.qb(),be.Cb(be.ab[0])),be.ab.pop()}};l.PThread=be;var sr=c=>{for(;0<c.length;)c.shift()(l)};l.establishStackSpace=function(){var c=Kt(),v=a()[c+52>>2>>>0];c=a()[c+56>>2>>>0],nn(v,v-c),Yt(v)};function Er(c){if(M)return Ve(2,0,c);ar(c)}l.invokeEntryPoint=function(c,v){c=on.apply(null,[c,v]),xt()?be.kb(c):wr(c)};function ur(c){this.fb=c-24,this.pb=function(v){p()[this.fb+4>>2>>>0]=v},this.ob=function(v){p()[this.fb+8>>2>>>0]=v},this.gb=function(v,x){this.nb(),this.pb(v),this.ob(x)},this.nb=function(){p()[this.fb+16>>2>>>0]=0}}var Sn=0,It=0;function ft(c,v,x,B){return M?Ve(3,1,c,v,x,B):Or(c,v,x,B)}function Or(c,v,x,B){if(c>>>=0,v>>>=0,x>>>=0,B>>>=0,typeof SharedArrayBuffer>"u")return oe("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var H=[];return M&&H.length===0?ft(c,v,x,B):(c={Gb:x,Xa:c,rb:B,Mb:H},M?(c.Ob="spawnThread",postMessage(c,H),0):Ar(c))}function Gt(c,v,x){return M?Ve(4,1,c,v,x):0}function kr(c,v){if(M)return Ve(5,1,c,v)}var lr=c=>{for(var v=0,x=0;x<c.length;++x){var B=c.charCodeAt(x);127>=B?v++:2047>=B?v+=2:55296<=B&&57343>=B?(v+=4,++x):v+=3}return v},xn=(c,v,x,B)=>{if(x>>>=0,!(0<B))return 0;var H=x;B=x+B-1;for(var K=0;K<c.length;++K){var ee=c.charCodeAt(K);if(55296<=ee&&57343>=ee){var pe=c.charCodeAt(++K);ee=65536+((ee&1023)<<10)|pe&1023}if(127>=ee){if(x>=B)break;v[x++>>>0]=ee}else{if(2047>=ee){if(x+1>=B)break;v[x++>>>0]=192|ee>>6}else{if(65535>=ee){if(x+2>=B)break;v[x++>>>0]=224|ee>>12}else{if(x+3>=B)break;v[x++>>>0]=240|ee>>18,v[x++>>>0]=128|ee>>12&63}v[x++>>>0]=128|ee>>6&63}v[x++>>>0]=128|ee&63}}return v[x>>>0]=0,x-H},dr=(c,v,x)=>xn(c,u(),v,x);function _n(c,v){if(M)return Ve(6,1,c,v)}function In(c,v,x){if(M)return Ve(7,1,c,v,x)}function An(c,v,x){return M?Ve(8,1,c,v,x):0}function Tn(c,v){if(M)return Ve(9,1,c,v)}function En(c,v,x){if(M)return Ve(10,1,c,v,x)}function On(c,v,x,B){if(M)return Ve(11,1,c,v,x,B)}function cr(c,v,x,B){if(M)return Ve(12,1,c,v,x,B)}function Pr(c,v,x,B){if(M)return Ve(13,1,c,v,x,B)}function W(c){if(M)return Ve(14,1,c)}function Dt(c,v){if(M)return Ve(15,1,c,v)}function U(c,v,x){if(M)return Ve(16,1,c,v,x)}var N=c=>{if(!Me)try{if(c(),!xt())try{M?wr(De):ar(De)}catch(v){v instanceof Ht||v=="unwind"||k(1,v)}}catch(v){v instanceof Ht||v=="unwind"||k(1,v)}};function fr(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(a(),c>>2,c).value.then(Lt),c+=128,Atomics.store(a(),c>>2,1))}l.__emscripten_thread_mailbox_await=fr;function Lt(){var c=Kt();c&&(fr(c),N(()=>tn()))}l.checkMailbox=Lt;var jt=c=>c%4===0&&(c%100!==0||c%400===0),Rr=[0,31,60,91,121,152,182,213,244,274,305,335],Br=[0,31,59,90,120,151,181,212,243,273,304,334];function Mr(c,v,x,B,H,K,ee,pe){return M?Ve(17,1,c,v,x,B,H,K,ee,pe):-52}function Dr(c,v,x,B,H,K,ee){if(M)return Ve(18,1,c,v,x,B,H,K,ee)}var jr=c=>{var v=lr(c)+1,x=br(v);return x&&dr(c,x,v),x},pr=[],zr=(c,v)=>{pr.length=0;var x;for(v>>=2;x=u()[c++>>>0];)v+=x!=105&v,pr.push(x==105?a()[v>>>0]:y()[v++>>>1]),++v;return pr},kn=c=>{var v=$r();return c=c(),Yt(v),c};function Ve(c,v){var x=arguments.length-2,B=arguments;return kn(()=>{for(var H=Cr(8*x),K=H>>3,ee=0;ee<x;ee++){var pe=B[2+ee];y()[K+ee>>>0]=pe}return en(c,x,H,v)})}var mr=[],hr={},Vr=()=>{if(!gr){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:T||"./this.program"},v;for(v in hr)hr[v]===void 0?delete c[v]:c[v]=hr[v];var x=[];for(v in c)x.push(`${v}=${c[v]}`);gr=x}return gr},gr;function Wr(c,v){if(M)return Ve(19,1,c,v);c>>>=0,v>>>=0;var x=0;return Vr().forEach(function(B,H){var K=v+x;for(H=p()[c+4*H>>2>>>0]=K,K=0;K<B.length;++K)t()[H++>>0>>>0]=B.charCodeAt(K);t()[H>>0>>>0]=0,x+=B.length+1}),0}function Ur(c,v){if(M)return Ve(20,1,c,v);c>>>=0,v>>>=0;var x=Vr();p()[c>>2>>>0]=x.length;var B=0;return x.forEach(function(H){B+=H.length+1}),p()[v>>2>>>0]=B,0}function Nr(c){return M?Ve(21,1,c):52}function Hr(c,v,x,B){return M?Ve(22,1,c,v,x,B):52}function Gr(c,v,x,B,H){return M?Ve(23,1,c,v,x,B,H):70}var Pn=[null,[],[]];function Lr(c,v,x,B){if(M)return Ve(24,1,c,v,x,B);v>>>=0,x>>>=0,B>>>=0;for(var H=0,K=0;K<x;K++){var ee=p()[v>>2>>>0],pe=p()[v+4>>2>>>0];v+=8;for(var de=0;de<pe;de++){var ce=u()[ee+de>>>0],ge=Pn[c];ce===0||ce===10?((c===1?L:oe)(Tr(ge,0)),ge.length=0):ge.push(ce)}H+=pe}return p()[B>>2>>>0]=H,0}var Fr=[31,29,31,30,31,30,31,31,30,31,30,31],qr=[31,28,31,30,31,30,31,31,30,31,30,31];function Rn(c){var v=Array(lr(c)+1);return xn(c,v,0,v.length),v}var Bn=(c,v)=>{t().set(c,v>>>0)};function Kr(c,v,x,B){function H(F,ye,Te){for(F=typeof F=="number"?F.toString():F||"";F.length<ye;)F=Te[0]+F;return F}function K(F,ye){return H(F,ye,"0")}function ee(F,ye){function Te(cn){return 0>cn?-1:0<cn?1:0}var At;return(At=Te(F.getFullYear()-ye.getFullYear()))===0&&(At=Te(F.getMonth()-ye.getMonth()))===0&&(At=Te(F.getDate()-ye.getDate())),At}function pe(F){switch(F.getDay()){case 0:return new Date(F.getFullYear()-1,11,29);case 1:return F;case 2:return new Date(F.getFullYear(),0,3);case 3:return new Date(F.getFullYear(),0,2);case 4:return new Date(F.getFullYear(),0,1);case 5:return new Date(F.getFullYear()-1,11,31);case 6:return new Date(F.getFullYear()-1,11,30)}}function de(F){var ye=F.Za;for(F=new Date(new Date(F.$a+1900,0,1).getTime());0<ye;){var Te=F.getMonth(),At=(jt(F.getFullYear())?Fr:qr)[Te];if(ye>At-F.getDate())ye-=At-F.getDate()+1,F.setDate(1),11>Te?F.setMonth(Te+1):(F.setMonth(0),F.setFullYear(F.getFullYear()+1));else{F.setDate(F.getDate()+ye);break}}return Te=new Date(F.getFullYear()+1,0,4),ye=pe(new Date(F.getFullYear(),0,4)),Te=pe(Te),0>=ee(ye,F)?0>=ee(Te,F)?F.getFullYear()+1:F.getFullYear():F.getFullYear()-1}c>>>=0,v>>>=0,x>>>=0,B>>>=0;var ce=a()[B+40>>2>>>0];B={Kb:a()[B>>2>>>0],Jb:a()[B+4>>2>>>0],cb:a()[B+8>>2>>>0],ib:a()[B+12>>2>>>0],eb:a()[B+16>>2>>>0],$a:a()[B+20>>2>>>0],Wa:a()[B+24>>2>>>0],Za:a()[B+28>>2>>>0],Tb:a()[B+32>>2>>>0],Ib:a()[B+36>>2>>>0],Lb:ce?Je(ce):""},x=Je(x),ce={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ge in ce)x=x.replace(new RegExp(ge,"g"),ce[ge]);var _e="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ee="January February March April May June July August September October November December".split(" ");ce={"%a":F=>_e[F.Wa].substring(0,3),"%A":F=>_e[F.Wa],"%b":F=>Ee[F.eb].substring(0,3),"%B":F=>Ee[F.eb],"%C":F=>K((F.$a+1900)/100|0,2),"%d":F=>K(F.ib,2),"%e":F=>H(F.ib,2," "),"%g":F=>de(F).toString().substring(2),"%G":F=>de(F),"%H":F=>K(F.cb,2),"%I":F=>(F=F.cb,F==0?F=12:12<F&&(F-=12),K(F,2)),"%j":F=>{for(var ye=0,Te=0;Te<=F.eb-1;ye+=(jt(F.$a+1900)?Fr:qr)[Te++]);return K(F.ib+ye,3)},"%m":F=>K(F.eb+1,2),"%M":F=>K(F.Jb,2),"%n":()=>`\n`,"%p":F=>0<=F.cb&&12>F.cb?"AM":"PM","%S":F=>K(F.Kb,2),"%t":()=>"	","%u":F=>F.Wa||7,"%U":F=>K(Math.floor((F.Za+7-F.Wa)/7),2),"%V":F=>{var ye=Math.floor((F.Za+7-(F.Wa+6)%7)/7);if(2>=(F.Wa+371-F.Za-2)%7&&ye++,ye)ye==53&&(Te=(F.Wa+371-F.Za)%7,Te==4||Te==3&&jt(F.$a)||(ye=1));else{ye=52;var Te=(F.Wa+7-F.Za-1)%7;(Te==4||Te==5&&jt(F.$a%400-1))&&ye++}return K(ye,2)},"%w":F=>F.Wa,"%W":F=>K(Math.floor((F.Za+7-(F.Wa+6)%7)/7),2),"%y":F=>(F.$a+1900).toString().substring(2),"%Y":F=>F.$a+1900,"%z":F=>{F=F.Ib;var ye=0<=F;return F=Math.abs(F)/60,(ye?"+":"-")+("0000"+(F/60*100+F%60)).slice(-4)},"%Z":F=>F.Lb,"%%":()=>"%"},x=x.replace(/%%/g,"\\0\\0");for(ge in ce)x.includes(ge)&&(x=x.replace(new RegExp(ge,"g"),ce[ge](B)));return x=x.replace(/\\0\\0/g,"%"),ge=Rn(x),ge.length>v?0:(Bn(ge,c),ge.length-1)}function Ft(c){try{c()}catch(v){yt(v)}}function Mn(c){var v={},x;for(x in c)(function(B){var H=c[B];v[B]=typeof H=="function"?function(){qt.push(B);try{return H.apply(null,arguments)}finally{Me||(qt.pop()===B||yt(),pt&&bt===1&&qt.length===0&&(bt=0,at+=1,Ft(sn),typeof Fibers<"u"&&Fibers.Ub()))}}:H})(x);return v}var bt=0,pt=null,Yr=0,qt=[],Zr={},Xr={},Dn=0,yr=null,jn=[];function zn(){return new Promise((c,v)=>{yr={resolve:c,reject:v}})}function Vn(){var c=br(65548),v=c+12;p()[c>>2>>>0]=v,p()[c+4>>2>>>0]=v+65536,v=qt[0];var x=Zr[v];return x===void 0&&(x=Dn++,Zr[v]=x,Xr[x]=v),v=x,a()[c+8>>2>>>0]=v,c}function Wn(){var c=a()[pt+8>>2>>>0];return c=ue[Xr[c]],--at,c()}function Un(c){if(!Me){if(bt===0){var v=!1,x=!1;c((B=0)=>{if(!Me&&(Yr=B,v=!0,x)){bt=2,Ft(()=>un(pt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),B=!1;try{var H=Wn()}catch(pe){H=pe,B=!0}var K=!1;if(!pt){var ee=yr;ee&&(yr=null,(B?ee.reject:ee.resolve)(H),K=!0)}if(B&&!K)throw H}}),x=!0,v||(bt=1,pt=Vn(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Ft(()=>an(pt)))}else bt===2?(bt=0,Ft(ln),Qr(pt),pt=null,jn.forEach(B=>N(B))):yt(`invalid state: ${bt}`);return Yr}}function Nn(c){return Un(v=>{c().then(v)})}be.gb();var Hn=[null,Cn,Er,ft,Gt,kr,_n,In,An,Tn,En,On,cr,Pr,W,Dt,U,Mr,Dr,Wr,Ur,Nr,Hr,Gr,Lr],Gn={r:function(c,v,x){return Nn(async()=>{await l.xb(c,v,x)})},b:function(c,v,x){throw c>>>=0,new ur(c).gb(v>>>0,x>>>0),Sn=c,It++,Sn},O:function(c){Jr(c>>>0,!R,1,!O,131072,!1),be.lb()},l:function(c){c>>>=0,M?postMessage({cmd:"cleanupThread",thread:c}):ir(c)},I:Or,i:Gt,U:kr,E:_n,G:In,V:An,S:Tn,K:En,R:On,p:cr,F:Pr,C:W,T:Dt,D:U,q:()=>!0,A:function(c,v){c>>>=0,c==v>>>0?setTimeout(()=>Lt()):M?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=be.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:fr,X:function(c){j&&be.Qa[c>>>0].ref()},u:function(c,v,x){c=v+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*v:NaN,x>>>=0,c=new Date(1e3*c),a()[x>>2>>>0]=c.getUTCSeconds(),a()[x+4>>2>>>0]=c.getUTCMinutes(),a()[x+8>>2>>>0]=c.getUTCHours(),a()[x+12>>2>>>0]=c.getUTCDate(),a()[x+16>>2>>>0]=c.getUTCMonth(),a()[x+20>>2>>>0]=c.getUTCFullYear()-1900,a()[x+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[x+28>>2>>>0]=c},v:function(c,v,x){c=v+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*v:NaN,x>>>=0,c=new Date(1e3*c),a()[x>>2>>>0]=c.getSeconds(),a()[x+4>>2>>>0]=c.getMinutes(),a()[x+8>>2>>>0]=c.getHours(),a()[x+12>>2>>>0]=c.getDate(),a()[x+16>>2>>>0]=c.getMonth(),a()[x+20>>2>>>0]=c.getFullYear()-1900,a()[x+24>>2>>>0]=c.getDay(),v=(jt(c.getFullYear())?Rr:Br)[c.getMonth()]+c.getDate()-1|0,a()[x+28>>2>>>0]=v,a()[x+36>>2>>>0]=-(60*c.getTimezoneOffset()),v=new Date(c.getFullYear(),6,1).getTimezoneOffset();var B=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(v!=B&&c.getTimezoneOffset()==Math.min(B,v))|0,a()[x+32>>2>>>0]=c},w:function(c){c>>>=0;var v=new Date(a()[c+20>>2>>>0]+1900,a()[c+16>>2>>>0],a()[c+12>>2>>>0],a()[c+8>>2>>>0],a()[c+4>>2>>>0],a()[c>>2>>>0],0),x=a()[c+32>>2>>>0],B=v.getTimezoneOffset(),H=new Date(v.getFullYear(),6,1).getTimezoneOffset(),K=new Date(v.getFullYear(),0,1).getTimezoneOffset(),ee=Math.min(K,H);return 0>x?a()[c+32>>2>>>0]=+(H!=K&&ee==B):0<x!=(ee==B)&&(H=Math.max(K,H),v.setTime(v.getTime()+6e4*((0<x?ee:H)-B))),a()[c+24>>2>>>0]=v.getDay(),x=(jt(v.getFullYear())?Rr:Br)[v.getMonth()]+v.getDate()-1|0,a()[c+28>>2>>>0]=x,a()[c>>2>>>0]=v.getSeconds(),a()[c+4>>2>>>0]=v.getMinutes(),a()[c+8>>2>>>0]=v.getHours(),a()[c+12>>2>>>0]=v.getDate(),a()[c+16>>2>>>0]=v.getMonth(),a()[c+20>>2>>>0]=v.getYear(),c=v.getTime()/1e3,rn((ct=c,1<=+Math.abs(ct)?0<ct?+Math.floor(ct/4294967296)>>>0:~~+Math.ceil((ct-+(~~ct>>>0))/4294967296)>>>0:0)),c>>>0},s:Mr,t:Dr,z:function(c,v,x){function B(ce){return(ce=ce.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ce[1]:"GMT"}c>>>=0,v>>>=0,x>>>=0;var H=new Date().getFullYear(),K=new Date(H,0,1),ee=new Date(H,6,1);H=K.getTimezoneOffset();var pe=ee.getTimezoneOffset(),de=Math.max(H,pe);p()[c>>2>>>0]=60*de,a()[v>>2>>>0]=+(H!=pe),c=B(K),v=B(ee),c=jr(c),v=jr(v),pe<H?(p()[x>>2>>>0]=c,p()[x+4>>2>>>0]=v):(p()[x>>2>>>0]=v,p()[x+4>>2>>>0]=c)},d:()=>{yt("")},c:function(c,v,x){return c>>>=0,v=zr(v>>>0,x>>>0),rr[c].apply(null,v)},k:function(c,v,x){return c>>>=0,v=zr(v>>>0,x>>>0),rr[c].apply(null,v)},m:function(){},j:function(){return Date.now()},W:()=>{throw at+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return j?(La(),Sr(Ga)).cpus().length:navigator.hardwareConcurrency},L:function(c,v,x,B){for(be.Pb=v>>>0,mr.length=x,v=B>>>0>>3,B=0;B<x;B++)mr[B]=y()[v+B>>>0];return(0>c?rr[-c-1]:Hn[c]).apply(null,mr)},y:function(c){c>>>=0;var v=u().length;if(c<=v||4294901760<c)return!1;for(var x=1;4>=x;x*=2){var B=v*(1+.2/x);B=Math.min(B,c+100663296);var H=Math;B=Math.max(c,B);e:{H=H.min.call(H,4294901760,B+(65536-B%65536)%65536)-Re.buffer.byteLength+65535>>>16;try{Re.grow(H),Ie();var K=1;break e}catch{}K=void 0}if(K)return!0}return!1},P:Wr,Q:Ur,H:ar,h:Nr,o:Hr,x:Gr,n:Lr,a:Re||l.wasmMemory,J:Kr,e:function(c,v,x,B){return Kr(c>>>0,v>>>0,x>>>0,B>>>0)}};(function(){function c(x,B){return x=x.exports,x=Mn(x),ue=x=Ln(x),be.mb.push(ue.Da),Fe.unshift(ue.Y),Be=B,gt(),x}var v={a:Gn};if(Ut(),l.instantiateWasm)try{return l.instantiateWasm(v,c)}catch(x){oe("Module.instantiateWasm callback failed with error: "+x),A(x)}return Ir(v,function(x){c(x.instance,x.module)}).catch(A),{}})(),l._OrtInit=(c,v)=>(l._OrtInit=ue.Z)(c,v),l._OrtGetLastError=(c,v)=>(l._OrtGetLastError=ue._)(c,v),l._OrtCreateSessionOptions=(c,v,x,B,H,K,ee,pe,de,ce)=>(l._OrtCreateSessionOptions=ue.$)(c,v,x,B,H,K,ee,pe,de,ce),l._OrtAppendExecutionProvider=(c,v)=>(l._OrtAppendExecutionProvider=ue.aa)(c,v),l._OrtAddFreeDimensionOverride=(c,v,x)=>(l._OrtAddFreeDimensionOverride=ue.ba)(c,v,x),l._OrtAddSessionConfigEntry=(c,v,x)=>(l._OrtAddSessionConfigEntry=ue.ca)(c,v,x),l._OrtReleaseSessionOptions=c=>(l._OrtReleaseSessionOptions=ue.da)(c),l._OrtCreateSession=(c,v,x)=>(l._OrtCreateSession=ue.ea)(c,v,x),l._OrtReleaseSession=c=>(l._OrtReleaseSession=ue.fa)(c),l._OrtGetInputOutputCount=(c,v,x)=>(l._OrtGetInputOutputCount=ue.ga)(c,v,x),l._OrtGetInputName=(c,v)=>(l._OrtGetInputName=ue.ha)(c,v),l._OrtGetOutputName=(c,v)=>(l._OrtGetOutputName=ue.ia)(c,v),l._OrtFree=c=>(l._OrtFree=ue.ja)(c),l._OrtCreateTensor=(c,v,x,B,H,K)=>(l._OrtCreateTensor=ue.ka)(c,v,x,B,H,K),l._OrtGetTensorData=(c,v,x,B,H)=>(l._OrtGetTensorData=ue.la)(c,v,x,B,H),l._OrtReleaseTensor=c=>(l._OrtReleaseTensor=ue.ma)(c),l._OrtCreateRunOptions=(c,v,x,B)=>(l._OrtCreateRunOptions=ue.na)(c,v,x,B),l._OrtAddRunConfigEntry=(c,v,x)=>(l._OrtAddRunConfigEntry=ue.oa)(c,v,x),l._OrtReleaseRunOptions=c=>(l._OrtReleaseRunOptions=ue.pa)(c),l._OrtCreateBinding=c=>(l._OrtCreateBinding=ue.qa)(c),l._OrtBindInput=(c,v,x)=>(l._OrtBindInput=ue.ra)(c,v,x),l._OrtBindOutput=(c,v,x,B)=>(l._OrtBindOutput=ue.sa)(c,v,x,B),l._OrtClearBoundOutputs=c=>(l._OrtClearBoundOutputs=ue.ta)(c),l._OrtReleaseBinding=c=>(l._OrtReleaseBinding=ue.ua)(c),l._OrtRunWithBinding=(c,v,x,B,H)=>(l._OrtRunWithBinding=ue.va)(c,v,x,B,H),l._OrtRun=(c,v,x,B,H,K,ee,pe)=>(l._OrtRun=ue.wa)(c,v,x,B,H,K,ee,pe),l._OrtEndProfiling=c=>(l._OrtEndProfiling=ue.xa)(c),l._JsepOutput=(c,v,x)=>(l._JsepOutput=ue.ya)(c,v,x),l._JsepGetNodeName=c=>(l._JsepGetNodeName=ue.za)(c);var Kt=l._pthread_self=()=>(Kt=l._pthread_self=ue.Aa)(),br=l._malloc=c=>(br=l._malloc=ue.Ba)(c),Qr=l._free=c=>(Qr=l._free=ue.Ca)(c);l.__emscripten_tls_init=()=>(l.__emscripten_tls_init=ue.Da)();var Jr=l.__emscripten_thread_init=(c,v,x,B,H,K)=>(Jr=l.__emscripten_thread_init=ue.Fa)(c,v,x,B,H,K);l.__emscripten_thread_crashed=()=>(l.__emscripten_thread_crashed=ue.Ga)();var en=(c,v,x,B)=>(en=ue.Ha)(c,v,x,B),vr=c=>(vr=ue.Ia)(c),wr=l.__emscripten_thread_exit=c=>(wr=l.__emscripten_thread_exit=ue.Ja)(c),tn=l.__emscripten_check_mailbox=()=>(tn=l.__emscripten_check_mailbox=ue.Ka)(),rn=c=>(rn=ue.La)(c),nn=(c,v)=>(nn=ue.Ma)(c,v),$r=()=>($r=ue.Na)(),Yt=c=>(Yt=ue.Oa)(c),Cr=c=>(Cr=ue.Pa)(c),on=l.dynCall_ii=(c,v)=>(on=l.dynCall_ii=ue.Ra)(c,v),an=c=>(an=ue.Sa)(c),sn=()=>(sn=ue.Ta)(),un=c=>(un=ue.Ua)(c),ln=()=>(ln=ue.Va)();l.___start_em_js=925254,l.___stop_em_js=925415;function Ln(c){c=Object.assign({},c);var v=B=>()=>B()>>>0,x=B=>H=>B(H)>>>0;return c.__errno_location=v(c.__errno_location),c.pthread_self=v(c.pthread_self),c.malloc=x(c.malloc),c.stackSave=v(c.stackSave),c.stackAlloc=x(c.stackAlloc),c}l.keepRuntimeAlive=xt,l.wasmMemory=Re,l.stackAlloc=Cr,l.stackSave=$r,l.stackRestore=Yt,l.UTF8ToString=Je,l.stringToUTF8=dr,l.lengthBytesUTF8=lr,l.ExitStatus=Ht,l.PThread=be;var Zt;_t=function c(){Zt||dn(),Zt||(_t=c)};function dn(){function c(){if(!Zt&&(Zt=!0,l.calledRun=!0,!Me)&&(M||sr(Fe),S(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),!M)){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;){var v=l.postRun.shift();Qe.unshift(v)}sr(Qe)}}if(!(0<dt))if(M)S(l),M||sr(Fe),startWorker(l);else{if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)st.unshift(l.preRun.shift());sr(st),0<dt||(l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),c()},1)):c())}}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return dn(),r.ready}})();typeof qa=="object"&&typeof Ii=="object"?Ii.exports=Fa:typeof define=="function"&&define.amd&&define([],()=>Fa)});var Ya=fn((Xg,nm)=>{nm.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var Ei,mn,hn,Yn,gn,ts,Oi,Ze=ae(()=>{"use strict";Ei=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},mn=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},hn=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Yn=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},gn=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ts=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Oi=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var fm,pm,rs,ns,is,mm,Ge,zt=ae(()=>{"use strict";Ze();fm=["V","I","W","E","F"],pm=(e,r)=>{console.log(`[${fm[e]},${new Date().toISOString()}]${r}`)},is=(e,r)=>{rs=e,ns=r},mm=(e,r)=>{let t=gn(e),u=gn(rs);t>=u&&pm(t,typeof r=="function"?r():r)},Ge=(...e)=>{ns&&mm(...e)}});var os,as=ae(()=>{"use strict";Ze();os=(e,r)=>new(Yn(r))(e)});var Zn=ae(()=>{"use strict"});var Xn,hm,ss,Pi,ki,ls,ds=ae(()=>{"use strict";zt();Zn();Xn=e=>Math.ceil(e/16)*16,hm=1,ss=()=>hm++,Pi=async(e,r,t,u)=>{let a=Xn(t),p=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let m=e.getCommandEncoder();e.endComputePass(),m.copyBufferToBuffer(r,0,p,0,a),e.flush(),await p.mapAsync(GPUMapMode.READ);let y=p.getMappedRange();if(u){let l=u();return l.set(new Uint8Array(y,0,t)),l}else return new Uint8Array(y.slice(0,t))}finally{p.destroy()}},ki=class{constructor(r){this.backend=r;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(r,t){let u=t.buffer,a=t.byteOffset,p=t.byteLength,m=Xn(p),y=this.storageCache.get(r);if(!y)throw new Error("gpu data for uploading does not exist");if(y.originalSize!==p)throw new Error(`inconsistent data size. gpu data size=${y.originalSize}, data size=${p}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:m,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),S=l.getMappedRange();new Uint8Array(S).set(new Uint8Array(u,a,p)),l.unmap();let A=this.backend.getCommandEncoder();this.backend.endComputePass(),A.copyBufferToBuffer(l,0,y.gpuData.buffer,0,m),Ge("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(l)}memcpy(r,t){let u=this.storageCache.get(r);if(!u)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(t);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(u.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let p=Xn(u.originalSize),m=this.backend.getCommandEncoder();this.backend.endComputePass(),m.copyBufferToBuffer(u.gpuData.buffer,0,a.gpuData.buffer,0,p)}registerExternalBuffer(r,t,u){let a;if(u){if(a=this.externalBuffers.get(u),a===void 0)throw new Error("previous buffer is not registered");if(r===u)return Ge("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${a}, buffer is the same, skip.`),a;this.externalBuffers.delete(u)}else a=ss();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:r},originalSize:t}),this.externalBuffers.set(r,a),Ge("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${a}, registered.`),a}unregisterExternalBuffer(r){let t=this.externalBuffers.get(r);t!==void 0&&(this.storageCache.delete(t),this.externalBuffers.delete(r),Ge("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(r,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let u=Xn(r),a,p=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,m=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(p||m){let l=p?this.freeBuffers:this.freeUniformBuffers,S=l.get(u);S||(S=[],l.set(u,S)),S.length>0?a=S.pop():a=this.backend.device.createBuffer({size:u,usage:t})}else a=this.backend.device.createBuffer({size:u,usage:t});let y={id:ss(),type:0,buffer:a};return this.storageCache.set(y.id,{gpuData:y,originalSize:r}),Ge("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${y.id}`),y}get(r){return this.storageCache.get(r)?.gpuData}release(r){let t=this.storageCache.get(r);if(!t)throw new Error("releasing data does not exist");return Ge("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(r,t){let u=this.storageCache.get(r);if(!u)throw new Error("data does not exist");await Pi(this.backend,u.gpuData.buffer,u.originalSize,t)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();this.buffersForUploadingPending=[];for(let r of this.buffersPending)(r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(r.size).push(r):(r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(r.size).push(r):r.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(r=>{r.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(t=>{t.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ls=(...e)=>new ki(...e)});var Ri,he,Le=ae(()=>{"use strict";Ri=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this.key}},he=e=>new Ri(e)});var Bi,Tt,Z,Jt,Qn,Jn,ei,ke=ae(()=>{"use strict";Bi=class{static calcMatMulShape(r,t){return r[1]!==t[0]?void 0:[r[0],t[1]]}},Tt=class{static calcShape(r,t,u=!1){let a=r.length,p=t.length;if(a===0)return t;if(p===0)return r;let m=Math.max(r.length,t.length),y=new Array(m);if(u){if(a<2||p<2)return;let l=Bi.calcMatMulShape([r[a-2],r[a-1]],[t[p-2],t[p-1]]);if(l===void 0)return;[y[m-2],y[m-1]]=l}for(let l=u?3:1;l<=m;l++){let S=a-l<0?1:r[a-l],A=p-l<0?1:t[p-l];if(S!==A&&S>1&&A>1)return;y[m-l]=Math.max(S,A)}return y}static isValidBroadcast(r,t){let u=r.length,a=t.length;if(u>a)return!1;for(let p=1;p<=u;p++)if(r[u-p]!==1&&r[u-p]!==t[a-p])return!1;return!0}},Z=class e{static size(r){return e.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,t){if(t<0||t>r.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return e.getSizeFromDimensionRange(r,t,r.length)}static sizeToDimension(r,t){if(t<0||t>r.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${r.length} dimensions.`);return e.getSizeFromDimensionRange(r,0,t)}static getSizeFromDimensionRange(r,t,u){let a=1;for(let p=t;p<u;p++){if(r[p]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=r[p]}return a}static computeStrides(r){let t=r.length;if(t===0)return[];if(t===1)return[1];let u=new Array(t);u[t-1]=1,u[t-2]=r[t-1];for(let a=t-3;a>=0;--a)u[a]=u[a+1]*r[a+1];return u}static normalizeAxis(r,t){if(r<-t&&r>=t)throw new Error("unsupported axis for this operation.");return r<0?r+t:r}static normalizeAxes(r,t){return r.map(u=>this.normalizeAxis(u,t??r.length))}static sortBasedOnPerm(r,t){return t?t.map(u=>r[u]):r.slice().reverse()}static padShape(r,t){let u=r.length;return r.map((a,p)=>a+t[p]+t[p+u])}static areEqual(r,t){return r.length!==t.length?!1:r.every((u,a)=>u===t[a])}},Jt=class e{static adjustPoolAttributes(r,t,u,a,p,m){if(!r&&u.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let y=0;y<t.length-2;y++)y>=u.length?u.push(t[y+2]):u[y]=t[y+2];for(let y=0;y<u.length;y++)if(y<a.length){if(a[y]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let y=0;y<u.length;y++)if(y<p.length){if(p[y]<0)throw new Error("dilations should be greater than or equal to 1")}else p.push(1);for(let y=0;y<u.length*2;y++)if(y<m.length){if(m[y]<0)throw new Error("pad should be greater than or equal to 1")}else m.push(0);for(let y=0;y<u.length;y++){if(u[y]<=0)throw new Error("kernel shapes need to be greater than 0");if(m[y]>=u[y]||m[y+u.length]>=u[y])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,t,u,a,p,m,y){if(y){if(p.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<r.length-2;l++)e.adjustPadAndReturnShape(r[l+(m?1:2)],t[l],u[l],a[l],p,l,l+r.length-2,y)}}static computePoolOutputShape(r,t,u,a,p,m,y){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let l=[t[0],t[1]];return e.computeShapeHelper(r,t,l,u,a,p,m,y),l}static computeConvOutputShape(r,t,u,a,p,m,y){if(r.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[r[0],t[0]];return e.computeShapeHelper(!1,r,l,u,a,p,m,y),l}static computeShapeHelper(r,t,u,a,p,m,y,l){if(r)for(let S=0;S<t.length-2;S++)u.push(1);else for(let S=0;S<t.length-2;S++)u.push(e.adjustPadAndReturnShape(t[S+2],a[S],p[S],m[S],y,S,S+t.length-2,l))}static adjustPadAndReturnShape(r,t,u,a,p,m,y,l){let S=u*(a-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return p[m]=0,p[y]=0,Math.floor((r-S)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(u!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let P=((r+t-1)/t-1)*t+a-r;return p[m]=Math.floor(l==="SAME_LOWER"?(P+1)/2:P/2),p[y]=P-p[m],Math.floor((r+P-a)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+p[m]+p[y]-S)/t+1)}},Qn=class{static getShapeOfGemmResult(r,t,u,a,p){if(r.length!==2||u.length!==2)throw new Error("shape need to be of size 2");let m,y,l;t?(m=r[1],y=r[0]):(m=r[0],y=r[1]);let S=-1;if(a?(l=u[0],S=1):(l=u[1],S=0),u[S]!==y)throw new Error("dimension mismatch");if(m<=0||l<=0||y<=0)throw new Error("invalid shape specified");if(p&&!Tt.isValidBroadcast(p,[m,l]))throw new Error("gemm: invalid bias shape for broadcast");return[m,l,y]}},Jn=-34028234663852886e22,ei=34028234663852886e22});var gm,cs,je,xe,lt,ot,vt,wt,Et,Di,te,se,fs,Mi,ps,ji,He,Pe=ae(()=>{"use strict";Ze();ke();gm=64,cs=(e,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},je=(e,r=1)=>{let t=cs(e,r);return typeof t=="string"?t:t[0]},xe=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:Z.computeStrides(e)}],lt=e=>e%4===0?4:e%2===0?2:1,ot=(e="f32",r,t="0")=>!r||r===1?`${e}(${t})`:`vec${r}<${e}>(${t})`,vt=(e,r,t)=>e==="f32"?t:r===1?`f32(${t})`:`vec${r}f(${t})`,wt=(e,r)=>r===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:r===2?`(${e}.x + ${e}.y)`:r===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Et=(e,r,t)=>e.startsWith("uniforms.")&&t>4?typeof r=="string"?`${e}[(${r}) / 4][(${r}) % 4]`:`${e}[${Math.floor(r/4)}][${r%4}]`:t>1?`${e}[${r}]`:e,Di=(e,r,t,u,a)=>{let p=typeof t=="number",m=p?t:t.length,y=[...new Array(m).keys()],l=m<2?"u32":m<=4?`vec${m}<u32>`:`array<u32, ${m}>`,S=cs(r,a),A=typeof S=="string"?S:S[1],P=typeof S=="string"?S:S[0],T={indices:l,value:A,storage:P,tensor:r},k=ne=>typeof ne=="string"?ne:`${ne}u`,O={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},R=p?"uniforms.":"",j=`${R}${e}_shape`,M=`${R}${e}_strides`,z="";for(let ne=0;ne<m-1;ne++)z+=`\n    let dim${ne} = current / ${Et(M,ne,m)};\n    let rest${ne} = current % ${Et(M,ne,m)};\n    indices[${ne}] = dim${ne};\n    current = rest${ne};\n    `;z+=`indices[${m-1}] = current;`;let q=m<2?"":`\n  fn o2i_${e}(offset: u32) -> ${T.indices} {\n    var indices: ${T.indices};\n    var current = offset;\n    ${z}\n    return indices;\n  }`,G=ne=>(O.offsetToIndices=!0,m<2?ne:`o2i_${e}(${ne})`),Y=[];if(m>=2)for(let ne=m-1;ne>=0;ne--)Y.push(`${Et(M,ne,m)} * (indices[${ne}])`);let _=m<2?"":`\n  fn i2o_${e}(indices: ${T.indices}) -> u32 {\n    return ${Y.join("+")};\n  }`,X=ne=>(O.indicesToOffset=!0,m<2?ne:`i2o_${e}(${ne})`),J=(...ne)=>m===0?"0u":`${T.indices}(${ne.map(k).join(",")})`,re=(ne,we)=>m<2?`${ne}`:`${Et(ne,we,m)}`,fe=(ne,we,Ie)=>m<2?`${ne}=${Ie};`:`${Et(ne,we,m)}=${Ie};`,L={},oe=(ne,we)=>{O.broadcastedIndicesToOffset=!0;let Ie=`${we.name}broadcastedIndicesTo${e}Offset`;if(Ie in L)return`${Ie}(${ne})`;let tt=[];for(let st=m-1;st>=0;st--){let Fe=we.indicesGet("outputIndices",st+we.rank-m);tt.push(`${re(M,st)} * (${Fe} % ${re(j,st)})`)}return L[Ie]=`fn ${Ie}(outputIndices: ${we.type.indices}) -> u32 {\n             return ${tt.length>0?tt.join("+"):"0u"};\n           }`,`${Ie}(${ne})`},Se=(ne,we)=>(()=>{if(T.storage===T.value)return`${e}[${ne}]=${we};`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`${e}[${ne}]=vec2<u32>(u32(${we}), select(0u, 0xFFFFFFFFu, ${we} < 0));`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`${e}[${ne}]=vec2<u32>(u32(${we}), 0u);`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`${e}[${ne}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${we}));`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),me=ne=>(()=>{if(T.storage===T.value)return`${e}[${ne}]`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`i32(${e}[${ne}].x)`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`u32(${e}[${ne}].x)`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${ne}] & 0xFFu), bool(${e}[${ne}] & 0xFF00u), bool(${e}[${ne}] & 0xFF0000u), bool(${e}[${ne}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),Re=m<2?"":`\n  fn get_${e}ByIndices(indices: ${T.indices}) -> ${A} {\n    return ${me(`i2o_${e}(indices)`)};\n  }`,ue=m<2?"":(()=>{let ne=y.map(Ie=>`d${Ie}: u32`).join(", "),we=y.map(Ie=>`d${Ie}`).join(", ");return`\n  fn get_${e}(${ne}) -> ${A} {\n    return get_${e}ByIndices(${J(we)});\n  }`})(),Be=(...ne)=>{if(ne.length!==m)throw new Error(`indices length must be ${m}`);let we=ne.map(k).join(",");return m===0?me("0u"):m===1?me(we[0]):(O.get=!0,O.getByIndices=!0,O.indicesToOffset=!0,`get_${e}(${we})`)},Me=ne=>m<2?me(ne):(O.getByIndices=!0,O.indicesToOffset=!0,`get_${e}ByIndices(${ne})`),De=m<2?"":`\n  fn set_${e}ByIndices(indices: ${T.indices}, value: ${A}) {\n    ${Se(`i2o_${e}(indices)`,"value")}\n  }`,Ae=m<2?"":(()=>{let ne=y.map(Ie=>`d${Ie}: u32`).join(", "),we=y.map(Ie=>`d${Ie}`).join(", ");return`\n  fn set_${e}(${ne}, value: ${A}) {\n    set_${e}ByIndices(${J(we)}, value);\n  }`})();return{impl:()=>{let ne=[];return p||(ne.push(`const ${j} = ${T.indices}(${t.join(",")});`),ne.push(`const ${M} = ${T.indices}(${Z.computeStrides(t).join(",")});`)),O.offsetToIndices&&ne.push(q),O.indicesToOffset&&ne.push(_),O.broadcastedIndicesToOffset&&Object.values(L).forEach(we=>ne.push(we)),O.set&&ne.push(Ae),O.setByIndices&&ne.push(De),O.get&&ne.push(ue),O.getByIndices&&ne.push(Re),ne.join(`\n`)},type:T,offsetToIndices:G,indicesToOffset:X,broadcastedIndicesToOffset:oe,indices:J,indicesGet:re,indicesSet:fe,set:(...ne)=>{if(ne.length!==m+1)throw new Error(`indices length must be ${m}`);let we=ne[m];if(typeof we!="string")throw new Error("value must be string");let Ie=ne.slice(0,m).map(k).join(",");return m===0?Se("0u",we):m===1?Se(Ie[0],we):(O.set=!0,O.setByIndices=!0,O.indicesToOffset=!0,`set_${e}(${Ie}, ${we})`)},setByOffset:Se,setByIndices:(ne,we)=>m<2?Se(ne,we):(O.setByIndices=!0,O.indicesToOffset=!0,`set_${e}ByIndices(${ne}, ${we});`),get:Be,getByOffset:me,getByIndices:Me,usage:u,name:e,strides:M,shape:j,rank:m}},te=(e,r,t,u=1)=>Di(e,r,t,"input",u),se=(e,r,t,u=1)=>Di(e,r,t,"output",u),fs=(e,r,t,u=1)=>Di(e,r,t,"internal",u),Mi=class{constructor(r){this.normalizedDispatchGroup=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=gm){let t=typeof r=="number"?r:r[0],u=typeof r=="number"?1:r[1],a=typeof r=="number"?1:r[2],p=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,m=p?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,y=p?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${t*u*a}u + local_index;`;return`@compute @workgroup_size(${t}, ${u}, ${a})\n  fn main(${m}) {\n    ${y}\n  `}appendVariableUniforms(r){r.rank!==0&&(r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:"u32",length:r.rank}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:"u32",length:r.rank}))}declareVariable(r,t){if(r.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(r),this.appendVariableUniforms(r);let u=r.usage==="input"?"read":"read_write",a=r.type.storage;return`@group(0) @binding(${t}) var<storage, ${u}> ${r.name}: array<${a}>;`}declareVariables(...r){return r.map(t=>this.declareVariable(t,this.variableIndex++)).join(`\n`)}registerInternalVariable(r){if(r.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(r),this.appendVariableUniforms(r)}registerInternalVariables(...r){return r.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(r,t,u=1){return this.uniforms.push({name:r,type:t,length:u}),this}registerUniforms(r){return this.uniforms=this.uniforms.concat(r),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:t,type:u,length:a}of this.uniforms)if(a&&a>4)r.push(`${t}:array<vec4<${u}>, ${Math.ceil(a/4)}>`);else{let p=a==null||a===1?u:`vec${a}<${u}>`;r.push(`${t}:${p}`)}return`\n      struct Uniforms { ${r.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(r=>r.impl()).join(`\n`)+this.internalVariables.map(r=>r.impl()).join(`\n`)}},ps=e=>new Mi(e),ji=(e,r)=>{let t=e.length,u=[];for(let a=0;a<t;a++){let p=t-1-a,m=e[p]||1;(r[r.length-1-a]||1)>1&&m===1&&u.unshift(p)}return u},He=e=>!0});var ym,ms,bm,vm,$t,hs,gs,xr=ae(()=>{"use strict";ke();Le();Pe();ym=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ms=(e,r)=>r&&r.length!==e?[...new Array(e).keys()].reverse():r,bm=(e,r)=>Z.sortBasedOnPerm(e,ms(e.length,r)),vm=(e,r,t,u)=>{let a=[];a.push(`fn perm(i: ${u.type.indices}) -> ${t.type.indices} {\n    var a: ${t.type.indices};`);for(let p=0;p<r;++p)a.push(t.indicesSet("a",e[p],`i[${p}]`));return a.push("return a;}"),a.join(`\n`)},$t=(e,r)=>{let t=e.dataType,u=e.dims.length,a=ms(u,r),p=He(u),m=bm(e.dims,a),y=p?m.length:m,l=p?u:e.dims,S=se("output",t,y),A=te("a",t,l),P=T=>`\n  ${T.registerUniform("output_size","u32").declareVariables(A,S)}\n\n  ${vm(a,u,A,S)}\n\n  ${T.mainStart()}\n    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${S.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${S.setByOffset("global_idx",A.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:p?["rank"]:["dims"]},getRunData:T=>{let k=Z.size(m);return{outputs:[{dims:m,dataType:T[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:p?[{type:"uint32",data:k},...xe(T[0].dims),...xe(m)]:[{type:"uint32",data:k}]}},getShaderSource:P}},hs=(e,r)=>{ym(e.inputs),e.compute($t(e.inputs[0],r.perm))},gs=e=>he({perm:e.perm})});var wm,$m,Cm,Sm,xm,_m,Im,Am,Tm,Em,Ot,ys,bs,vs,ws,$s,Cs,Ss,xs,_s,Is,As=ae(()=>{"use strict";ke();Pe();ti();xr();wm={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},$m={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Cm={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Sm={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},xm=(e,r)=>{let t=[];for(let u=r-e;u<r;++u)t.push(u);return t},_m=(e,r)=>{let t=[],u=e.length;for(let p=0;p<u;p++)r.indexOf(p)===-1&&t.push(e[p]);let a=r.map(p=>e[p]);return[t,a]},Im=(e,r)=>{let t=e.length+r.length,u=[],a=0;for(let p=0;p<t;p++)r.indexOf(p)===-1?u.push(e[a++]):u.push(1);return u},Am=(e,r)=>{for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==r-1-t)return!1;return!0},Tm=(e,r)=>{let t=[];if(!Am(e,r)){for(let u=0;u<r;++u)e.indexOf(u)===-1&&t.push(u);e.forEach(u=>t.push(u))}return t},Em=(e,r,t,u,a,p,m)=>{let y=t[0].dims,l=Z.size(p),S=Z.size(m),A=te("_A",t[0].dataType,y),P=se("output",a,p),T=32,k=`\n          var<workgroup> aBestValues : array<${P.type.storage}, ${T}>;\n       `;return{name:e,shaderCache:r,getShaderSource:R=>`\n        ${R.registerUniform("reduceSize","u32").declareVariables(A,P)}\n        ${k}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${R.mainStart(T)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${T};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${P.type.storage}(${Cm[u]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${T}) {\n           let candidate = ${P.type.storage}(${A.getByOffset("offset + k")});\n           bestValue = ${wm[u]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${T}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${$m[u]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${P.setByOffset("outputIndex",`${u==="mean"?`bestValue / ${P.type.storage}(uniforms.reduceSize)`:`${Sm[u]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:p,dataType:a}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:S}]})}},Ot=(e,r,t,u)=>{let a=e.inputs.length===1?t:zi(e.inputs,t),p=a.axes;p.length===0&&!a.noopWithEmptyAxes&&(p=e.inputs[0].dims.map((k,O)=>O));let m=Z.normalizeAxes(p,e.inputs[0].dims.length),y=m,l=e.inputs[0],S=Tm(y,e.inputs[0].dims.length);S.length>0&&(l=e.compute($t(e.inputs[0],S),{inputs:[0],outputs:[-1]})[0],y=xm(y.length,l.dims.length));let[A,P]=_m(l.dims,y),T=A;a.keepDims&&(T=Im(A,m)),e.compute(Em(r,{hint:a.cacheKey,inputDependencies:["type"]},[l],u,e.inputs[0].dataType,T,P),{inputs:[l]})},ys=(e,r)=>{Ot(e,"ReduceMeanShared",r,"mean")},bs=(e,r)=>{Ot(e,"ReduceL1Shared",r,"l1")},vs=(e,r)=>{Ot(e,"ReduceL2Shared",r,"l2")},ws=(e,r)=>{Ot(e,"ReduceLogSumExpShared",r,"logSumExp")},$s=(e,r)=>{Ot(e,"ReduceMaxShared",r,"max")},Cs=(e,r)=>{Ot(e,"ReduceMinShared",r,"min")},Ss=(e,r)=>{Ot(e,"ReduceProdShared",r,"prod")},xs=(e,r)=>{Ot(e,"ReduceSumShared",r,"sum")},_s=(e,r)=>{Ot(e,"ReduceSumSquareShared",r,"sumSquare")},Is=(e,r)=>{Ot(e,"ReduceLogSumShared",r,"logSum")}});var kt,Om,ri,zi,Pt,km,Pm,Rm,Bm,Mm,Dm,jm,zm,Vm,Wm,Rt,Ts,Es,Os,ks,Ps,Rs,Bs,Ms,Ds,js,Ct,ti=ae(()=>{"use strict";ke();Le();Pe();As();kt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Om=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],ri=(e,r,t,u,a,p,m=!1,y=!1)=>{let l=[],S=t[0].dims,A=Z.normalizeAxes(a,t[0].dims.length),P=!y&&A.length===0;S.forEach((X,J)=>{P||A.indexOf(J)>=0?m&&l.push(1):l.push(X)});let T=[],k=te("_A",t[0].dataType,S),O=se("output",p,l),R=u(k,O,A),j=`inputOffset = ${k.indicesToOffset("inputIndices")};`,M=`let ${j};`,z=`var ${j};`,q=R[1]===""?"":z,G=(R[1]===""?M:j)+`\n`+R[2];for(let X=0,J=0;X<t[0].dims.length;X++)P||A.indexOf(X)>=0?(m&&J++,G=`for(var j${X}: u32 = 0; j${X} < ${t[0].dims[X]}; j${X}++) {\n                ${R[2].includes("lastIndex")?`let lastIndex = j${X};`:""}\n                ${k.indicesSet("inputIndices",X,`j${X}`)}\n                ${G}\n              }`):(T.push(`${k.indicesSet("inputIndices",X,O.indicesGet("outputIndices",J))};`),J++);let Y=Z.size(l);return{name:e,shaderCache:r,getShaderSource:X=>`\n        ${X.declareVariables(k,O)}\n\n        ${X.mainStart()}\n          ${X.guardAgainstOutOfBoundsWorkgroupSizes(Y)}\n          var inputIndices: ${k.type.indices};\n          let outputIndices = ${O.offsetToIndices("global_idx")};\n\n          ${T.join(`\n`)}\n          ${R[0]}       // init ops for reduce max/min\n          ${q}\n          ${R[1]}\n          ${G}\n          ${R[3]}\n          ${R.length===4?O.setByOffset("global_idx","value"):R.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:l,dataType:p}],dispatchGroup:{x:Math.ceil(Y/64)}})}},zi=(e,r)=>{let t=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(u=>t.push(Number(u))),he({axes:t,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},Pt=(e,r,t,u)=>{let a=e.inputs,p=a.length===1?t:zi(a,t);e.compute(ri(r,{hint:p.cacheKey},[a[0]],p.noopWithEmptyAxes&&p.axes.length===0?Om:u,p.axes,a[0].dataType,p.keepDims,p.noopWithEmptyAxes),{inputs:[0]})},km=(e,r)=>{kt(e.inputs),Pt(e,"ReduceLogSum",r,(u,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${u.getByOffset("inputOffset")};`,"value = log(value);"])},Pm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceL1",r,(u,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${u.getByOffset("inputOffset")});`,""])},Rm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceL2",r,(u,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${u.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Bm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceLogSumExp",r,(u,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${u.getByOffset("inputOffset")});`,"value = log(value);"])},Mm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceMax",r,(u,a,p)=>{let m=[];for(let y=0;y<u.rank;y++)(p.indexOf(y)>=0||p.length===0)&&m.push(u.indicesSet("inputIndices",y,0));return[`${m.join(`\n`)}`,`var value = ${u.getByOffset("inputOffset")};`,`value = max(value, ${u.getByOffset("inputOffset")});`,""]})},Dm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceMean",r,(u,a,p)=>{let m=1;for(let y=0;y<u.rank;y++)(p.indexOf(y)>=0||p.length===0)&&(m*=e.inputs[0].dims[y]);return["var sum = f32(0);","",`sum += f32(${u.getByOffset("inputOffset")});`,`let value = ${a.type.value}(sum / ${m});`]})},jm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceMin",r,(u,a,p)=>{let m=[];for(let y=0;y<u.rank;y++)(p.indexOf(y)>=0||p.length===0)&&m.push(`inputIndices[${y}] = 0;`);return[`${m.join(`\n`)}`,`var value = ${u.getByOffset("inputOffset")};`,`value = min(value, ${u.getByOffset("inputOffset")});`,""]})},zm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceProd",r,(u,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${u.getByOffset("inputOffset")};`,""])},Vm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceSum",r,(u,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${u.getByOffset("inputOffset")};`,""])},Wm=(e,r)=>{kt(e.inputs),Pt(e,"ReduceSumSquare",r,(u,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${u.getByOffset("inputOffset")}; value += t * t;`,""])},Rt=(e,r,t)=>{if(r.length===0)return!!t;let u=1,a=1;for(let p=0;p<r.length;p++)r.indexOf(p)===-1?u*=e[p]:a*=e[p];return a<32&&u>1024},Ts=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Dm(e,r):ys(e,r)},Es=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Pm(e,r):bs(e,r)},Os=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Rm(e,r):vs(e,r)},ks=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Bm(e,r):ws(e,r)},Ps=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Mm(e,r):$s(e,r)},Rs=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?jm(e,r):Cs(e,r)},Bs=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?zm(e,r):Ss(e,r)},Ms=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Vm(e,r):xs(e,r)},Ds=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Wm(e,r):_s(e,r)},js=(e,r)=>{Rt(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?km(e,r):Is(e,r)},Ct=e=>he(e)});var zs,Vs,Ws,Vi,Us=ae(()=>{"use strict";Ze();Le();ti();zs=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Vs=(e,r)=>{zs(e.inputs);let t=(u,a,p)=>{let m=[];for(let y=0;y<u.rank;y++)(p.indexOf(y)>=0||p.length===0)&&m.push(`inputIndices[${y}] = 0;`);return[`${m.join(`\n`)}`,`var value = ${u.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${u.getByOffset("inputOffset")} ${r.selectLastIndex>0?"<=":"<"} value) {\n         value = ${u.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",a.setByOffset("global_idx","bestIndex")]};e.compute(ri("ArgMin",{hint:r.cacheKey},[e.inputs[0]],t,[r.axis],7,r.keepDims),{inputs:[0]})},Ws=(e,r)=>{zs(e.inputs);let t=(u,a,p)=>{let m=[];for(let y=0;y<u.rank;y++)(p.indexOf(y)>=0||p.length===0)&&m.push(`inputIndices[${y}] = 0;`);return[`${m.join(`\n`)}`,`var value = ${u.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${u.getByOffset("inputOffset")} ${r.selectLastIndex>0?">=":">"} value) {\n         value = ${u.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",a.setByOffset("global_idx","bestIndex")]};e.compute(ri("argMax",{hint:r.cacheKey},[e.inputs[0]],t,[r.axis],7,r.keepDims),{inputs:[0]})},Vi=e=>he(e)});var Um,Ns,Nm,Hm,Gm,ni,Lm,Hs,Wi=ae(()=>{"use strict";Le();Zn();Pe();Um=(e,r)=>{let t=e[0],u=e[1],a=e[2],p=e[3],m=e[4],y=e[5];if(m&&y)throw new Error("Attention cannot have both past and relative_position_bias");if(t.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let l=t.dims[0],S=t.dims[1],A=t.dims[2];if(a.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(u.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(u.dims[0]!==A)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==u.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let P=a.dims[0]/3,T=P,k=T;if(r.qkvHiddenSizes.length>0){if(r.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let q of r.qkvHiddenSizes)if(q%r.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");P=r.qkvHiddenSizes[0],T=r.qkvHiddenSizes[1],k=r.qkvHiddenSizes[2]}let O=S;if(P!==T)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==P+T+k)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let R=0;if(m){if(T!==k)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(m.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(m.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(m.dims[1]!==l)throw new Error(\'Input "past" second dimension must be batch_size\');if(m.dims[2]!==r.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(m.dims[4]!==T/r.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');r.pastPresentShareBuffer||(R=m.dims[3])}let j=O+R,M=-1,z=0;if(p)throw new Error("Mask not supported");if(m)throw new Error("past is not supported");if(y)throw new Error("relativePositionBias is not supported");return{batchSize:l,sequenceLength:S,pastSequenceLength:R,kvSequenceLength:O,totalSequenceLength:j,maxSequenceLength:M,inputHiddenSize:A,hiddenSize:P,vHiddenSize:k,headSize:Math.floor(P/r.numHeads),vHeadSize:Math.floor(k/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:z,scale:r.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Ns=e=>he({...e}),Nm=(e,r,t,u)=>{let a=lt(u),p=se("x",r.dataType,r.dims,a),m="threadMaxVector";a===2?m="max(threadMaxVector.x, threadMaxVector.y)":a===4&&(m="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let y=je(r.dataType),l=64,S=u/a;S<l?l=1:S/8<64&&(l=Math.ceil(S/8));let A=Math.ceil(u/a/l),P=T=>`\n  const dInv: ${y} = 1 / ${u};\n  const dComp = ${u/a};\n  var<workgroup> wgMax: array<f32, ${l}>;\n  var<workgroup> wgSum: array<f32, ${l}>;\n\n  ${T.declareVariables(p)}\n  @compute @workgroup_size(${l}, 1, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_index : u32) {\n    let localOffset = local_index * ${A};\n    let offset: u32 = workgroup_id.x * dComp + localOffset;\n\n    var threadMaxVector = ${ot("f32",a,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < ${A} && i + localOffset < dComp; i++) {\n      threadMaxVector = max(${vt(y,a,"x[offset + i]")}, threadMaxVector);\n    }\n    wgMax[local_index] = ${m};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${l}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${ot("f32",a,"0")};\n    for (var i: u32 = 0; i < ${A} && i + localOffset < dComp; i++) {\n      sumVector += exp(${vt(y,a,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_index] = ${wt("sumVector",a)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${l}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < ${A} && i + localOffset < dComp; i++) {\n        x[offset + i] = ${ot(y,a,"dInv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < ${A} && i + localOffset < dComp; i++) {\n        let f32input = ${vt(y,a,"x[offset + i]")};\n        x[offset + i] = ${p.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${u}`},getShaderSource:P,getRunData:()=>({outputs:[],dispatchGroup:{x:t}})},{inputs:[r],outputs:[]})},Hm=(e,r,t,u,a,p)=>{let m=[a.batchSize,a.numHeads,a.sequenceLength,a.kvSequenceLength+a.pastSequenceLength],y=p.scale===0?1/Math.sqrt(a.headSize):p.scale,l=je(r.dataType),S=lt(a.headSize),A=te("q",r.dataType,r.dims,S),P=te("key",t.dataType,t.dims,S),T=se("output",r.dataType,m),k=a.headSize/S,O=a.sequenceLength,R=a.totalSequenceLength,j=k,M=12,z={x:Math.ceil(a.totalSequenceLength/M),y:Math.ceil(a.sequenceLength/M),z:a.batchSize*a.numHeads},q=[r,t],G=_=>`\n  const M: u32 = ${O}u;\n  const N: u32 = ${R}u;\n  const K: u32 = ${j}u;\n  const alpha: ${l} = ${y};\n  const beta: ${l} = 1.0;\n  const TILE_SIZE = ${M}u;\n\n  var<workgroup> tileQ: array<${A.type.storage}, ${M*M}>;\n  var<workgroup> tileK: array<${A.type.storage}, ${M*M}>;\n\n  ${_.declareVariables(A,P,T)}\n\n  @compute @workgroup_size(${M}, ${M}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${z.x*z.y}u +\n          workgroup_id.y * ${z.x}u + workgroup_id.x) * ${M*M}u + local_index;\n\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = ${a.sequenceLength*k} * headIdx + m * K;\n    let kOffset = ${a.kvSequenceLength*k} * headIdx + n * K;\n\n    var value = ${ot(l,S)};\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m + local_id.y < M && w + local_id.x < K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];\n      }\n      if (n + local_id.y < N && w + local_id.x < K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * M * N;\n    if (lm < M && ln < N) {\n      let outputIdx = headOffset + lm * N + ln;\n      output[outputIdx] = ${wt("value",S)} * alpha;\n    }\n  }`,Y=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(a)},getRunData:()=>({outputs:[{dims:m,dataType:r.dataType,gpuDataType:0}],dispatchGroup:z}),getShaderSource:G},{inputs:q,outputs:[-1]})[0];return Nm(e,Y,a.batchSize*a.numHeads*a.sequenceLength,a.totalSequenceLength),Y},Gm=(e,r,t,u)=>{let a=[u.batchSize,u.sequenceLength,u.vHiddenSize],p=te("probs",r.dataType,r.dims),m=te("v",t.dataType,t.dims),y=se("output",r.dataType,a),l=je(r.dataType),S=12,A={x:Math.ceil(u.vHeadSize/S),y:Math.ceil(u.sequenceLength/S),z:u.batchSize*u.numHeads},P=T=>`\n  const M: u32 = ${u.sequenceLength}u;\n  const N: u32 = ${u.vHeadSize}u;\n  const K: u32 = ${u.totalSequenceLength}u;\n  const numHeads: u32 = ${u.numHeads}u;\n  const TILE_SIZE = ${S}u;\n\n  var<workgroup> tileQ: array<${p.type.storage}, ${S*S}>;\n  var<workgroup> tileK: array<${p.type.storage}, ${S*S}>;\n\n  ${T.declareVariables(p,m,y)}\n\n  @compute @workgroup_size(${S}, ${S}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${A.x*A.y}u +\n          workgroup_id.y * ${A.x}u + workgroup_id.x) * ${S*S}u + local_index;\n\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (M * K) + m * K;\n   let offsetB = headIdx * (N * K) + n;\n\n   var value = ${l}(0);\n   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n     if (m < M && w + local_id.x < K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < N && w + local_id.y < K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / ${u.numHeads};\n   let currentBatchHeadNumber = workgroup_id.z % ${u.numHeads};\n   let headOffset = (batchIdx * M * ${u.numHeads} + currentBatchHeadNumber) * ${u.vHeadSize};\n   if (m < M && n < N) {\n     let outputIdx = batchIdx * ${u.sequenceLength*u.vHiddenSize} + m * ${u.vHiddenSize}\n       + currentBatchHeadNumber * ${u.vHeadSize} + n;\n     output[outputIdx] = value;\n   }\n  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(u)},getRunData:()=>({outputs:[{dims:a,dataType:r.dataType,gpuDataType:0}],dispatchGroup:A}),getShaderSource:P},{inputs:[r,t],outputs:[0]})[0]},ni=(e,r,t,u,a,p,m,y,l,S,A)=>{let P=Hm(e,r,t,l,S,A);Gm(e,P,u,S)},Lm=(e,r)=>{let t=[r.batchSize,r.numHeads,r.sequenceLength,r.headSize],u=je(e.inputs[0].dataType),a=r.sequenceLength,p=r.inputHiddenSize,m=r.headSize,y=12,l={x:Math.ceil(r.headSize/y),y:Math.ceil(r.sequenceLength/y),z:r.batchSize*r.numHeads},S=()=>`\n  const M: u32 = ${a}u;\n  const K: u32 = ${p}u;\n  const N: u32 = ${m}u;\n  const numHeads: u32 = ${r.numHeads};\n  const ldb = ${r.hiddenSize+r.hiddenSize+r.vHiddenSize}u;\n  const TILE_SIZE = ${y}u;\n\n  var<workgroup> tileInput: array<${u}, ${y*y}>;\n  var<workgroup> tileWeightQ: array<${u}, ${y*y}>;\n  var<workgroup> tileWeightK: array<${u}, ${y*y}>;\n  var<workgroup> tileWeightV: array<${u}, ${y*y}>;\n\n  @group(0) @binding(0) var<storage, read> input: array<${u}>;\n  @group(0) @binding(1) var<storage, read> weight: array<${u}>;\n  @group(0) @binding(2) var<storage, read> bias: array<${u}>;\n  @group(0) @binding(3) var<storage, read_write> outputQ: array<${u}>;\n  @group(0) @binding(4) var<storage, read_write> outputK: array<${u}>;\n  @group(0) @binding(5) var<storage, read_write> outputV: array<${u}>;\n\n  @compute @workgroup_size(${y}, ${y}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${l.x*l.y}u +\n          workgroup_id.y * ${l.x}u + workgroup_id.x) * ${y*y}u + local_index;\n\n    let batchIndex = workgroup_id.z / ${r.numHeads};\n    let headNumber = workgroup_id.z % ${r.numHeads};\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (M * K) + m * K;\n    let biasOffsetQ = headNumber * ${r.headSize};\n    let biasOffsetK = ${r.hiddenSize} + biasOffsetQ;\n    let biasOffsetV = ${r.hiddenSize} + biasOffsetK;\n\n    var valueQ = ${u}(0);\n    var valueK = ${u}(0);\n    var valueV = ${u}(0);\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m < M && w + local_id.x < K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < N && w + local_id.y < K) {\n        let offset = n + (w + local_id.y) * ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * N + n) % ${r.headSize};\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * M * N;\n    if (m < M && n < N) {\n      let outputIdx = offset + m * N + n;\n      outputQ[outputIdx] = valueQ;\n      outputK[outputIdx] = valueK;\n      outputV[outputIdx] = valueV;\n    }\n  }`,A=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(r)},getRunData:()=>({outputs:[{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:l}),getShaderSource:S},{inputs:A,outputs:[-1,-1,-1]})},Hs=(e,r)=>{let t=Um(e.inputs,r),[u,a,p]=Lm(e,t);return ni(e,u,a,p,e.inputs[4],void 0,void 0,void 0,e.inputs[5],t,r)}});var ii=ae(()=>{"use strict"});var Gs=ae(()=>{"use strict";ii()});var Ls,Fs=ae(()=>{"use strict";Ls="1.17.0"});var qs,Ui,Ks=ae(()=>{"use strict";Fs();qs="warning",Ui={wasm:{},webgl:{},webgpu:{},versions:{common:Ls},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);qs=e}},get logLevel(){return qs}};Object.defineProperty(Ui,"logLevel",{enumerable:!0})});var oi,Ys=ae(()=>{"use strict";Ks();oi=Ui});var Zs=ae(()=>{"use strict"});var Xs=ae(()=>{"use strict";ai()});var Js=ae(()=>{"use strict"});var eu=ae(()=>{"use strict";ai()});var ai=ae(()=>{"use strict";Zs();Xs();Js();eu()});var si=ae(()=>{"use strict";ai()});var tu=ae(()=>{"use strict";ii();si()});var ru=ae(()=>{"use strict";tu()});var nu=ae(()=>{"use strict"});var iu=ae(()=>{"use strict";ii();si()});var ou=ae(()=>{"use strict";iu()});var Ni=ae(()=>{"use strict";Gs();Ys();ru();si();nu();ou()});var Km,Ym,Zm,au,su=ae(()=>{"use strict";Ni();ke();Le();Pe();Km=(e,r)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(u,a,p)=>{let m=a.length;if(m!==u.length)throw new Error(`${p}: num dimensions != ${m}`);a.forEach((y,l)=>{if(y!==u[l])throw new Error(`${p}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let u=r.format==="NHWC"?r.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,r.spatial?2:void 0);t(e[1].dims,u,"Invalid input scale"),t(e[2].dims,u,"Invalid input B"),t(e[3].dims,u,"Invalid input mean"),t(e[4].dims,u,"Invalid input var")}else t(e[1].dims,[1],"Invalid input scale"),t(e[2].dims,[1],"Invalid input B"),t(e[3].dims,[1],"Invalid input mean"),t(e[4].dims,[1],"Invalid input var")},Ym=(e,r)=>{let{epsilon:t,spatial:u,format:a}=r,p=e[0].dims,m=u?lt(p[p.length-1]):1,y=a==="NHWC"&&p.length>1?m:1,l=Z.size(p)/m,S=He(p.length)&&u,A=S?p.length:p,P=te("x",e[0].dataType,e[0].dims,m),T=te("scale",e[1].dataType,e[1].dims,y),k=te("bias",e[2].dataType,e[2].dims,y),O=te("inputMean",e[3].dataType,e[3].dims,y),R=te("inputVar",e[4].dataType,e[4].dims,y),j=se("y",e[0].dataType,A,m),M=()=>{let q="";if(u)q=`let cOffset = ${p.length===1?"0u":a==="NHWC"?`outputIndices[${p.length-1}] / ${m}`:"outputIndices[1]"};`;else if(a==="NCHW")q=`\n            ${j.indicesSet("outputIndices","0","0")}\n            let cOffset = ${j.indicesToOffset("outputIndices")};`;else{q=`var cIndices = ${T.type.indices}(0);\n                       cIndices[0] = outputIndices[${p.length-1}];`;for(let G=1;G<T.rank;G++)q+=`cIndices[${G}] = outputIndices[${G}];`;q+=`let cOffset = ${T.indicesToOffset("cIndices")};`}return q},z=q=>`\n  const epsilon = ${t};\n  ${q.registerUniform("outputSize","u32").declareVariables(P,T,k,O,R,j)}\n  ${q.mainStart()}\n  ${q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${j.offsetToIndices(`global_idx * ${m}`)};\n    ${M()}\n    let scale = ${T.getByOffset("cOffset")};\n    let bias = ${k.getByOffset("cOffset")};\n    let inputMean = ${O.getByOffset("cOffset")};\n    let inputVar = ${R.getByOffset("cOffset")};\n    let x = ${P.getByOffset("global_idx")};\n    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;\n    ${j.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${r.epsilon}_${r.format}_${u}_${m}`,inputDependencies:S?["rank","type","type","type","type"]:void 0},getShaderSource:z,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:S?[{type:"uint32",data:l},...xe(p)]:[{type:"uint32",data:l}]})}},Zm=e=>he(e),au=(e,r)=>{let{inputs:t,outputCount:u}=e,a=Zm({...r,outputCount:u});if(oi.webgpu.validateInputContent&&Km(t,a),r.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Ym(t,a))}});var Xm,Qm,uu,lu=ae(()=>{"use strict";ke();Pe();Xm=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Qm=e=>{let r=e[0].dims,t=e[0].dims[2],u=Z.size(r)/4,a=e[0].dataType,p=te("input",a,r,4),m=te("bias",a,[t],4),y=te("residual",a,r,4),l=se("output",a,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:A=>`\n  const channels = ${t}u / 4;\n  ${A.declareVariables(p,m,y,l)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let value = ${p.getByOffset("global_idx")}\n      + ${m.getByOffset("global_idx % channels")} + ${y.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx","value")}\n  }`}},uu=e=>{Xm(e.inputs),e.compute(Qm(e.inputs))}});var Jm,ze,du,cu,fu,pu,mu,hu,gu,yu,bu,eh,vu,wu,$u,Cu,ui,Su,li,xu,_u,Iu,Au,Tu,Eu,Ou,ku,Pu,Ru,Bu,Mu,Du,ju,zu,Vu,Wu,Hi=ae(()=>{"use strict";Ze();ke();Le();Pe();Jm=(e,r,t,u,a,p)=>{let m=Math.ceil(r/4),y="";typeof a=="string"?y=`${a}(a)`:y=a("a");let l=te("inputData",t,[m],4),S=se("outputData",u,[m],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(l,S)}\n\n  ${p??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${l.getByOffset("global_idx")};\n    ${S.setByOffset("global_idx",y)}\n  }`},ze=(e,r,t,u,a,p=e.dataType)=>({name:r,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:m=>Jm(m,Z.size(e.dims),e.dataType,p,t,u),getRunData:m=>({outputs:[{dims:e.dims,dataType:p}],dispatchGroup:{x:Math.ceil(Z.size(m[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(Z.size(e.dims)/4)}]})}),du=e=>{e.compute(ze(e.inputs[0],"Abs","abs"))},cu=e=>{e.compute(ze(e.inputs[0],"Acos","acos"))},fu=e=>{e.compute(ze(e.inputs[0],"Acosh","acosh"))},pu=e=>{e.compute(ze(e.inputs[0],"Asin","asin"))},mu=e=>{e.compute(ze(e.inputs[0],"Asinh","asinh"))},hu=e=>{e.compute(ze(e.inputs[0],"Atan","atan"))},gu=e=>{e.compute(ze(e.inputs[0],"Atanh","atanh"))},yu=e=>he(e),bu=(e,r)=>{let t;switch(r.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${r.to}`)}e.compute(ze(e.inputs[0],"Cast",t,void 0,r.cacheKey,r.to))},eh=e=>{let r=e.length>=2?e[1].getFloat32Array()[0]:Jn,t=e.length>=3?e[2].getFloat32Array()[0]:ei;return he({min:r,max:t})},vu=(e,r)=>{let t=e.inputs.length===1?r:eh(e.inputs),u=je(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${u}> = vec4(${u}(${t.min}));\n    const clip_max_: vec4<${u}> = vec4(${u}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},wu=e=>{e.compute(ze(e.inputs[0],"Ceil","ceil"))},$u=e=>{e.compute(ze(e.inputs[0],"Cos","cos"))},Cu=e=>{e.compute(ze(e.inputs[0],"Cosh","cosh"))},ui=e=>he(e),Su=(e,r)=>{e.compute(ze(e.inputs[0],"Elu",t=>`elu_vf32(${t})`,`\n  const elu_alpha_: f32 = f32(${r.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,r.cacheKey))},li=(e,r="f32")=>`\nconst r0: ${r} = 0.3275911;\nconst r1: ${r} = 0.254829592;\nconst r2: ${r} = -0.284496736;\nconst r3: ${r} = 1.421413741;\nconst r4: ${r} = -1.453152027;\nconst r5: ${r} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,xu=e=>{let r=je(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Erf",t=>`erf_vf32(${t})`,li(`vec4<${r}>`,r)))},_u=e=>{e.compute(ze(e.inputs[0],"Exp","exp"))},Iu=e=>{e.compute(ze(e.inputs[0],"Floor","floor"))},Au=e=>{let r=je(e.inputs[0].dataType);e.compute(ze(e.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,li(`vec4<${r}>`,r)))},Tu=(e,r)=>{e.compute(ze(e.inputs[0],"LeakyRelu",t=>`select(leaky_relu_alpha_ * ${t}, ${t}, ${t} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${r.alpha});`,r.cacheKey))},Eu=e=>{e.compute(ze(e.inputs[0],"Not",r=>`!${r}`))},Ou=e=>{e.compute(ze(e.inputs[0],"Neg",r=>`-${r}`))},ku=e=>{e.compute(ze(e.inputs[0],"Reciprocal",r=>`1.0/${r}`))},Pu=e=>{e.compute(ze(e.inputs[0],"Relu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > vec4<f32>(0.0))`))},Ru=e=>{e.compute(ze(e.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Bu=e=>{e.compute(ze(e.inputs[0],"Sin","sin"))},Mu=e=>{e.compute(ze(e.inputs[0],"Sinh","sinh"))},Du=e=>{e.compute(ze(e.inputs[0],"Sqrt","sqrt"))},ju=e=>{e.compute(ze(e.inputs[0],"Tan","tan"))},zu=e=>{e.compute(ze(e.inputs[0],"Tanh","tanh"))},Vu=(e,r)=>(e.compute(ze(e.inputs[0],"ThresholdedRelu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${r.alpha});`,r.cacheKey)),0),Wu=e=>{e.compute(ze(e.inputs[0],"Log","log"))}});var rh,nh,Uu,Nu=ae(()=>{"use strict";ke();Pe();Hi();rh=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},nh=e=>{let r=e[0].dims.slice();r[2]=r[2]/2;let t=te("input",e[0].dataType,e[0].dims,4),u=te("bias",e[0].dataType,[e[0].dims[2]],4),a=se("output",e[0].dataType,r,4),p=Z.size(r)/4,m=je(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(t,u,a)}\n\n  ${li(`vec4<${m}>`,m)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Uu=e=>{rh(e.inputs),e.compute(nh(e.inputs))}});var ih,oh,Bt,Hu,Gu,Lu,Fu,qu,Ku,Yu,Zu,Xu,Qu,Ju=ae(()=>{"use strict";Ze();ke();Pe();ih=(e,r,t,u,a,p,m,y,l,S,A,P,T)=>{let k,O;typeof y=="string"?k=O=(_,X)=>`${y}((${_}),(${X}))`:typeof y=="function"?k=O=y:(k=y.scalar,O=y.vector);let R=P?r.length:r,j=P?t.length:t,M=P?u.length:u,z=se("outputData",A,M,4),q=te("aData",l,R,4),G=te("bData",S,j,4),Y;if(a)if(p){let _=Z.size(r)===1,X=Z.size(t)===1,J=r.length>0&&r[r.length-1]%4===0,re=t.length>0&&t[t.length-1]%4===0;_||X?Y=z.setByOffset("global_idx",O(_?`${q.type.value}(${q.getByOffset("0")}.x)`:q.getByOffset("global_idx"),X?`${G.type.value}(${G.getByOffset("0")}.x)`:G.getByOffset("global_idx"))):Y=`\n            let outputIndices = ${z.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${q.broadcastedIndicesToOffset("outputIndices",z)};\n            let offsetB = ${G.broadcastedIndicesToOffset("outputIndices",z)};\n            ${z.setByOffset("global_idx",O(m||J?q.getByOffset("offsetA / 4u"):`${q.type.value}(${q.getByOffset("offsetA / 4u")}[offsetA % 4u])`,m||re?G.getByOffset("offsetB / 4u"):`${G.type.value}(${G.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else Y=z.setByOffset("global_idx",O(q.getByOffset("global_idx"),G.getByOffset("global_idx")));else{if(!p)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let _=(X,J,re="")=>{let fe=`aData[indexA${J}][componentA${J}]`,L=`bData[indexB${J}][componentB${J}]`;return`\n            let outputIndices${J} = ${z.offsetToIndices(`global_idx * 4u + ${J}u`)};\n            let offsetA${J} = ${q.broadcastedIndicesToOffset(`outputIndices${J}`,z)};\n            let offsetB${J} = ${G.broadcastedIndicesToOffset(`outputIndices${J}`,z)};\n            let indexA${J} = offsetA${J} / 4u;\n            let indexB${J} = offsetB${J} / 4u;\n            let componentA${J} = offsetA${J} % 4u;\n            let componentB${J} = offsetB${J} % 4u;\n            ${X}[${J}] = ${re}(${k(fe,L)});\n          `};A===9?Y=`\n            var data = vec4<u32>(0);\n            ${_("data",0,"u32")}\n            ${_("data",1,"u32")}\n            ${_("data",2,"u32")}\n            ${_("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Y=`\n            ${_("outputData[global_idx]",0)}\n            ${_("outputData[global_idx]",1)}\n            ${_("outputData[global_idx]",2)}\n            ${_("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(q,G,z)}\n\n        ${T??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${Y}\n      }`},oh=(e,r,t,u,a,p,m=t.dataType)=>{let y=!Z.areEqual(t.dims,u.dims),l=t.dims,S=Z.size(t.dims),A=!1,P=!1,T=[y];if(y){let O=Tt.calcShape(t.dims,u.dims,!1);if(!O)throw new Error("Can\'t perform binary op on the given tensors");l=O,S=Z.size(l);let R=Z.size(t.dims)===1,j=Z.size(u.dims)===1,M=t.dims.length>0&&t.dims[t.dims.length-1]%4===0,z=u.dims.length>0&&u.dims[u.dims.length-1]%4===0;T.push(R),T.push(j),T.push(M),T.push(z);let q=1;for(let G=1;G<l.length;G++){let Y=t.dims[t.dims.length-G]??1,_=u.dims[u.dims.length-G]??1;if(Y===_)q*=Y;else break}q%4===0?(P=!0,A=!0):(R||j||M||z)&&(A=!0)}else A=!0;T.push(A);let k=He(t.dims.length)&&He(u.dims.length)&&He(l.length);return{name:e,shaderCache:{hint:r+T.map(O=>O.toString()).join("_"),inputDependencies:k?["rank","rank"]:["dims","dims"]},getShaderSource:O=>ih(O,t.dims,u.dims,l,A,y,P,a,t.dataType,u.dataType,m,k,p),getRunData:()=>({outputs:[{dims:l,dataType:m}],dispatchGroup:{x:Math.ceil(S/64/4)},programUniforms:k?[{type:"uint32",data:Math.ceil(Z.size(l)/4)},...xe(t.dims),...xe(u.dims),...xe(l)]:[{type:"uint32",data:Math.ceil(Z.size(l)/4)}]})}},Bt=(e,r,t,u,a,p)=>{e.compute(oh(r,a??"",e.inputs[0],e.inputs[1],t,u,p))},Hu=e=>{Bt(e,"Add",(r,t)=>`${r}+${t}`)},Gu=e=>{Bt(e,"Div",(r,t)=>`${r}/${t}`)},Lu=e=>{Bt(e,"Equal",{scalar:(r,t)=>`u32(${r}==${t})`,vector:(r,t)=>`vec4<u32>(${r}==${t})`},void 0,void 0,9)},Fu=e=>{Bt(e,"Mul",(r,t)=>`${r}*${t}`)},qu=e=>{let r=te("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Bt(e,"Pow",{scalar:(u,a)=>`pow_custom(${u},${a})`,vector:(u,a)=>`pow_vector_custom(${u},${a})`},`\n    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {\n      if (b == ${r}(0.0)) {\n        return ${r}(1.0);\n      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {\n        return ${r}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {\n      // TODO: implement vectorized pow\n      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ku=e=>{Bt(e,"Sub",(r,t)=>`${r}-${t}`)},Yu=e=>{Bt(e,"Greater",{scalar:(r,t)=>`u32(${r}>${t})`,vector:(r,t)=>`vec4<u32>(${r}>${t})`},void 0,void 0,9)},Zu=e=>{Bt(e,"Less",{scalar:(r,t)=>`u32(${r}<${t})`,vector:(r,t)=>`vec4<u32>(${r}<${t})`},void 0,void 0,9)},Xu=e=>{Bt(e,"GreaterOrEqual",{scalar:(r,t)=>`u32(${r}>=${t})`,vector:(r,t)=>`vec4<u32>(${r}>=${t})`},void 0,void 0,9)},Qu=e=>{Bt(e,"LessOrEqual",{scalar:(r,t)=>`u32(${r}<=${t})`,vector:(r,t)=>`vec4<u32>(${r}<=${t})`},void 0,void 0,9)}});var sh,uh,lh,dh,el,tl,rl=ae(()=>{"use strict";ke();Le();Pe();sh=e=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0].dataType,t=e[0].dims.length;for(let u of e){if(u.dataType!==r)throw new Error("input tensors should be one type");if(u.dims.length!==t)throw new Error("input tensors should have the same shape")}},uh=(e,r)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${r});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,lh=(e,r)=>{let t=e.length,u=[];for(let a=0;a<t;++a){let p=r.setByOffset("global_idx",e[a].getByIndices("indices"));t===1?u.push(p):a===0?u.push(`if (inputIndex == ${a}u) { ${p} }`):a===t-1?u.push(`else { ${p} }`):u.push(`else if (inputIndex == ${a}) { ${p} }`)}return u.join(`\n`)},dh=(e,r)=>{let t=e[0].dims.slice();if(r>=t.length||r<-1*t.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let u=r<0?t.length+r:r,a=t.slice(0);for(let G=1;G<e.length;G++){let Y=e[G].dims.slice();for(let _=0;_<t.length;_++)if(_===u)a[u]+=Y[_];else if(t[_]!==Y[_])throw new Error("non concat dimensions must match")}let p=Z.size(a),m=new Array(e.length),y=new Array(e.length),l=e[0].dataType,S=0,A=[],P=[],T=[],k=[{type:"uint32",data:p}];for(let G=0;G<e.length;++G)S+=e[G].dims[u],m[G]=S,T.push(He(e[G].dims.length)),P.push(T[G]?e[G].dims.length:e[G].dims),y[G]=te(`input${G}`,l,P[G]),A.push(T[G]?"rank":"dims"),k.push({type:"uint32",data:m[G]});for(let G=0;G<e.length;++G)T[G]&&k.push(...xe(e[G].dims));let O=He(a.length);O&&k.push(...xe(a));let R=O?a.length:a,j=se("output",l,R),M=j.indicesGet("indices",u),z=Array.from(Array(m.length).keys()).map(G=>`uniforms.sizeInConcatAxis${G}`).join(","),q=G=>`\n\n  ${(()=>{G.registerUniform("outputSize","u32");for(let Y=0;Y<e.length;Y++)G.registerUniform(`sizeInConcatAxis${Y}`,"u32");return G.declareVariables(...y,j)})()}\n\n  ${uh(m.length,z)}\n\n  ${G.mainStart()}\n    ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${j.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${M});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${m.length}u>(${z});\n      ${M} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${lh(y,j)}\n  }`;return{name:"Concat",shaderCache:{hint:`${r}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:k}),getShaderSource:q}},el=(e,r)=>{sh(e.inputs),e.compute(dh(e.inputs,r.axis))},tl=e=>he({axis:e.axis})});var Vt,di,er=ae(()=>{"use strict";ke();Vt=(e,r)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${r}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${r}(1.0) / (${r}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${r}(${e.clipMin});const clip_max_=${r}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},di=e=>{let r=e?.activation||"";if(r==="Clip"){let[t,u]=e?.activation_params||[Jn,ei];return{activation:r,clipMax:u,clipMin:t,activationCacheKey:`${r}:${t},${u}`}}return{activation:r,activationCacheKey:r}}});var et,ci,fi=ae(()=>{"use strict";et=(e,r)=>{switch(e){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${e}-component is not supported.`)}},ci=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var pi,Gi=ae(()=>{"use strict";pi=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var ch,fh,yn,nl,ph,bn,mh,mi,vn=ae(()=>{"use strict";ke();Pe();er();fi();ch=(e,r)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `,fh=(e,r)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,yn=(e,r,t="f32",u,a=!1,p=32,m=!1,y=32)=>{let l=r[1]*e[1],S=r[0]*e[0],A=a?l:p,P=a?p:l,T=A/r[0],k=p/r[1];if(!((a&&T===4&&e[1]===4||!a&&(T===3||T===4))&&A%r[0]===0&&p%r[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${T} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${T} must be 3 or 4.\n  tileAWidth ${A} must be divisible by workgroupSize[0]${r[0]}. tileInner ${p} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${T}<${t}>, ${A/T}>, ${P}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${t}>, ${S/e[0]}>, ${p}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${T};\nconst tileInner = ${p};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${m?"0":"i32(globalId.z)"};\n  ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let numTiles = ${m?`${Math.ceil(y/p)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${m?`i32(globalId.z) * ${y}`:"0"};\n\n  var acc: array<vec4<${t}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${k};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${ch(a,u)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${k}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${u?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${T===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${fh(a,T)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},nl=(e,r)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${r?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${r?", batchIndices":""});\n            `,ph=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",bn=(e,r,t="f32",u,a=!1,p=32,m=!1,y=32,l=!1)=>{let S=e[1]*r[1],A=e[0]*r[0],P=a?S:p,T=a?p:S;if(!(T%r[1]===0&&P%r[0]===0&&p%r[1]===0))throw new Error(`tileAHight ${T} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${P} must be divisible by workgroupSize[0]${r[0]}, tileInner ${p} must be divisible by workgroupSize[1]${r[1]}`);let k=T/r[1],O=P/r[0],R=p/r[1],j=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${S};\n    let globalColStart = i32(workgroupId.x) * ${A};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${T}; inputRow = inputRow + ${r[1]}) {\n        for (var inputCol = localCol; inputCol < ${P}; inputCol = inputCol + ${r[0]}) {\n          ${nl(a,u)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${r[1]}) {\n            for (var inputCol = localCol; inputCol < ${A}; inputCol = inputCol + ${r[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${u?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${t}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${r[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${r[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${S};\n\nlet tileRowA = i32(localId.y) * ${k};\nlet tileColA = i32(localId.x) * ${O};\nlet tileRowB = i32(localId.y) * ${R};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${k}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${O}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${nl(a,u)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${R}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${u?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${t}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${ph(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${t}, ${P}>, ${T}>;\n  var<workgroup> mm_Bsub : array<array<${t}, ${A}>, ${p}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${p};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${m?"0":"i32(globalId.z)"};\n    ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${m?`${Math.ceil(y/p)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${m?`i32(globalId.z) * ${y}`:"0"};\n\n    var acc : array<array<${t}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${j}\n  }\n`},mh=(e,r,t,u,a,p=!1)=>{let[m,y,l]=a,[S,A,P,T]=u,k=ji(m,l),O=ji(y,l),R=je(u[0].type.tensor),j=()=>{let q=A.rank,G=S.rank,Y=`var aIndices: ${A.type.indices};`;for(let _=q-2-1,X=G-1;_>=0;_--,X--)Y+=`\naIndices[${_}] = ${G>1?`batchIndices[${X}]`:"batchIndices"};`;return k.forEach(_=>{Y+=`\naIndices[${_}] = 0;`}),Y+=`\naIndices[${q-2}] = u32(row);\n                   aIndices[${q-1}] = u32(colIn);`,Y},M=()=>{let q=P.rank,G=S.rank,Y=`var bIndices: ${P.type.indices};`;for(let _=q-2-1,X=G-1;_>=0;_--,X--)Y+=`\nbIndices[${_}] = ${G>1?`batchIndices[${X}]`:"batchIndices"};`;return O.forEach(_=>{Y+=`\nbIndices[${_}] = 0;`}),Y+=`\nbIndices[${q-2}] = u32(row);\n                   bIndices[${q-1}] = u32(colIn);`,Y};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${S.type.indices}) -> ${et(e,R)} {\n      var value = ${et(e,R)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${j()}\n        value = ${A.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${S.type.indices}) -> ${et(e,R)} {\n      var value = ${et(e,R)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${M()}\n        value = ${P.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${et(e,R)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${r?`value = value + ${p?"bias[colIn]":`${et(e,R)}(bias[row])`};`:""}\n        ${t}\n        ${T.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},mi=(e,r,t,u,a=!1)=>{let p=e[0].dims,m=e[1].dims,y=p.slice(0,-2),l=m.slice(0,-2),S=u?u.slice(0,-2):t.slice(0,-2),A=He(S.length),P=A?S.length:S,T=fs("batchDims",e[0].dataType,P,1),k=Z.size(S),O=p[p.length-2],R=p[p.length-1],j=m[m.length-1],M=R%4===0&&j%4===0,z=O<=8?[4,1,1]:[4,4,1],q=[8,8,1],G=[Math.ceil(j/q[0]/z[0]),Math.ceil(O/q[1]/z[1]),Math.ceil(k/q[2]/z[2])],Y=je(e[0].dataType),_=M?4:1,X=[...y,O,R/_],J=He(X.length),re=J?X.length:X,fe=[...l,R,j/_],L=He(fe.length),oe=L?fe.length:fe,Se=[k,O,j/_],me=te("a",e[0].dataType,re,_),Re=te("b",e[1].dataType,oe,_),ue=se("result",e[0].dataType,Se.length,_),Be=[me,Re],Me=[{type:"int32",data:O},{type:"int32",data:j},{type:"int32",data:R}];A&&Me.push(...xe(S)),J&&Me.push(...xe(X)),L&&Me.push(...xe(fe));let De=[];De.push(J?"rank":"dims"),De.push(L?"rank":"dims");let Ae=e.length>2,{activationFunction:St,applyActivation:rt}=Vt(r,ue.type.value),nt=mh(_,Ae,rt,[T,me,Re,ue],[y,l,S],a);if(Ae){let we=a?_:1;Be.push(te("bias",e[2].dataType,e[2].dims.length,we)),Me.push(...xe(e[2].dims)),De.push("rank")}Me.push(...xe(Se));let ne=we=>`\n  ${we.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(T).declareVariables(...Be,ue)}\n  ${St}\n  ${nt}\n  ${M?yn(z,q,Y,T):bn(z,q,Y,T)}\n                   `;return{name:"MatMul",shaderCache:{hint:r.activationCacheKey+`${z}${r.activation}${r.clipMax}${r.clipMin}${M}${Ae}${a}`,inputDependencies:De},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:G[0],y:G[1],z:G[2]},programUniforms:Me}),getShaderSource:ne}}});var hh,il,ol=ae(()=>{"use strict";zt();Pe();er();fi();Gi();vn();hh=(e,r,t,u,a=!1,p,m=4,y=4,l=4,S="f32")=>{let A=L=>{switch(L){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${S}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${L} is not supported.`)}},P=L=>{switch(L){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${L} is not supported.`)}},T=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,k=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,O=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",R=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",j=e?"row":"col",M=e?"col":"row",z=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${j} / outWidth;\n    let outCol = ${j} % outWidth;\n\n    let WRow = ${M} / (filterDims[1] * inChannels);\n    let WCol = ${M} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${M} % inChannels;\n    var resData = ${et(m,S)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${O} && xCol >= 0 && xCol < ${R}) {\n      ${T}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${A(m)}\n    }\n    return resData;`,q=e?r&&u?`\n    let col = colIn * ${m};\n    ${z}`:`\n    let col = colIn * ${m};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${z}\n    }\n    return ${et(m,S)}(0.0);`:u&&t?`\n    let col = colIn * ${m};\n    ${z}`:`\n    let col = colIn * ${m};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${z}\n    }\n    return ${et(m,S)}(0.0);`,G=`${P(y)}`,Y=et(l,S),_=e?et(m,S):et(y,S),X=e?et(y,S):et(m,S),{activationFunction:J,applyActivation:re}=Vt(p,Y);return`\n    ${J}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${_} {\n      ${e?q:G}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${X} {\n      ${e?G:q}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Y}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${k}\n      ${ci(a)}\n      ${re}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},il=(e,r,t,u,a,p,m,y)=>{let l=r.format==="NHWC",S=l?e[0].dims[3]:e[0].dims[1],A=t[0],P=l?t[2]:t[3],T=l?t[1]:t[2],k=l?t[3]:t[1],O=l&&(S%4===0||S%3===0)&&k%4===0,R=l?k:P*T,j=l?P*T:k,M=[8,8,1],z=u<=8?[4,1,1]:[4,4,1],q=[Math.ceil(R/M[0]/z[0]),Math.ceil(j/M[1]/z[1]),Math.ceil(A/M[2]/z[2])];Ge("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${q}`);let G=O?l&&S%4!==0?3:4:1,Y=M[1]*z[1],_=M[0]*z[0],X=Math.max(M[0]*G,M[1]),J=u%Y===0,re=a%_===0,fe=p%X===0,L=O?[G,4,4]:[1,1,1],oe=je(e[0].dataType),Se=O?4:1,me=[{type:"int32",data:u},{type:"int32",data:a},{type:"int32",data:p}],Re=te("x",e[0].dataType,e[0].dims.length,G===3?1:G),ue=te("w",e[1].dataType,e[1].dims.length,Se),Be=[Re,ue];me.push(...xe(e[0].dims)),me.push(...xe(e[1].dims));let Me=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${O?`vec4<${oe}>`:oe}) {\n        result[flatIndex] = ${O?`vec4<${oe}>`:oe}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${O?`vec4<${oe}>`:oe}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${O?"/ 4":""}, value);\n      }`;if(m){let Ae=te("bias",e[2].dataType,e[2].dims.length,Se);Be.push(Ae),me.push(...xe(e[2].dims)),Me+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?`vec4<${oe}>`:oe} {\n          return bias[coords.${l?"w":"y"}${O?"/ 4":""}];\n        }`}let De=se("result",e[0].dataType,t.length,Se);return me.push(...xe(t)),{name:"Conv2DMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:q[0],y:q[1],z:q[2]},programUniforms:me}),getShaderSource:Ae=>`\n        ${pi("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Ae.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...Be,De)}\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[0]}, ${r.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${r.pads[0]}, ${r.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        ${Me}\n        ${hh(l,J,re,fe,m,r,L[0],L[1],L[2],oe)}\n            ${O?yn(z,M,oe,void 0,!l,X):bn(z,M,oe,void 0,!l,X,!1,void 0,y)}`}}});var Li,al=ae(()=>{"use strict";ke();Pe();qi();er();Li=(e,r,t)=>{let u=e.length>2,a=u?"value += b[output_channel];":"",p=e[0].dims,m=e[1].dims,y=m[0]/r.group,l=r.format==="NHWC",S=Fi(p,m,r.dilations,r.pads,r.strides,l),A=Z.size(S),P=se("output",e[0].dataType,S),{activationFunction:T,applyActivation:k}=Vt(r,P.type.value),O=te("x",e[0].dataType,p),R=te("w",e[1].dataType,m),j=[O,R];u&&j.push(te("b",e[2].dataType,e[2].dims));let M=z=>`\n  const strides: vec2<u32> = vec2(${r.strides[0]}u, ${r.strides[1]}u);\n  const pads: vec2<u32> = vec2(${r.pads[0]}u, ${r.pads[1]}u);\n\n  ${z.declareVariables(...j,P)}\n\n  ${T}\n\n  ${z.mainStart()}\n    ${z.guardAgainstOutOfBoundsWorkgroupSizes(A)}\n\n    let outputIndices = ${P.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${y}u;\n\n    var value: ${P.type.value} = ${P.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${m[1]}u; wInChannel++) {\n      let input_channel = group_id * ${m[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${m[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${r.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${p[l?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${m[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${r.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${p[l?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${l?O.get("batch","xHeight","xWidth","input_channel"):O.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${R.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${k}\n    ${P.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t?t(S):S,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(A/64)}}),getShaderSource:M}}});var Fi,sl,gh,ul,Ki,yh,bh,Yi,qi=ae(()=>{"use strict";ke();Le();ol();vn();al();er();xr();Fi=(e,r,t,u,a,p)=>{let m=e[0],y=e.slice(p?1:2,p?3:4),l=y.length,S=r[0],P=r.slice(2).map((O,R)=>O+(O-1)*(t[R]-1)),k=y.map((O,R)=>O+u[R]+u[R+l]).map((O,R)=>Math.floor((O-P[R]+a[R])/a[R]));return k.splice(0,0,m),k.splice(p?3:1,0,S),k},sl=[2,3,1,0],gh=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],u=e[1].dims[1]*r.group;if(t!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(r.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(r.strides.length!==a)throw new Error(`strides should be ${a}D`);if(r.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ul=(e,r)=>{let t=e.kernelShape.slice();for(let p=2;p<r[1].dims.length;++p)t[p-2]===0&&(t[p-2]=r[1].dims[p]);let u=e.pads.slice();Jt.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,t,u,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:t,pads:u,cacheKey:e.cacheKey}),a},Ki=e=>{let r=di(e),t=e.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,p=e.group,m=e.kernel_shape,y=e.pads,l=e.strides,S=e.w_is_const();return he({autoPad:u,format:t,dilations:a,group:p,kernelShape:m,pads:y,strides:l,wIsConst:S,...r})},yh=(e,r,t)=>{let u=ul(t,r);if(t.group!==1){e.compute(Li(r,u));return}let a=t.format==="NHWC",p=r.length===3,m=r[0].dims[a?1:2],y=r[0].dims[a?2:3],l=r[0].dims[a?3:1],S=r[1].dims[2],A=r[1].dims[3],P=Fi(r[0].dims,r[1].dims,t.dilations,u.pads,t.strides,a),T=P[a?1:2],k=P[a?2:3],O=P[a?3:1],R=a&&S===m&&A===y&&t.pads[0]===0&&t.pads[1]===0;if(R||S===1&&A===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let _=P[0],X,J,re,fe=[];if(a){let L=e.kernelCustomData.wT??e.compute($t(r[1],sl),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=L),R){let oe=m*y*l;X=r[0].reshape([1,_,oe]),J=L.reshape([1,oe,O]),re=[1,_,O]}else X=r[0].reshape([_,m*y,l]),J=L.reshape([1,l,O]),re=[_,T*k,O];fe.push(X),fe.push(J)}else X=r[0].reshape([_,l,m*y]),J=r[1].reshape([1,O,l]),re=[_,O,T*k],fe.push(J),fe.push(X);p&&fe.push(r[2]),e.compute(mi(fe,u,P,re,a),{inputs:fe});return}let j=!0,M=e.kernelCustomData.wT??e.compute($t(r[1],sl),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M);let z=[r[0],M];p&&z.push(r[2]);let q=a?T*k:O,G=a?O:T*k,Y=S*A*l;e.compute(il(z,u,P,q,G,Y,p,j),{inputs:z})},bh=(e,r)=>{let t=r.format==="NHWC",u=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&u.push(e.inputs[2]);let a=[0,r.pads[0],0,r.pads[1]],p=[1].concat(r.strides),m=[1].concat(r.dilations),y=[1].concat(r.kernelShape),l=ul({...r,pads:a,strides:p,dilations:m,kernelShape:y},u);e.compute(Li(u,l,S=>t?[S[0],S[2],S[3]]:[]))},Yi=(e,r)=>{gh(e.inputs,r),e.inputs[0].dims.length===3?bh(e,r):yh(e,e.inputs,r)}});var vh,ll,dl=ae(()=>{"use strict";zt();Pe();er();fi();Gi();vn();vh=(e,r=!1,t,u=4)=>{let a=et(u,"f32"),p=z=>{switch(z){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${z} is not supported.`)}},m=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,y=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,l=e?"outBackprop[1]":"outBackprop[2]",S=e?"outBackprop[2]":"outBackprop[3]",A=e?"row":"col",P=e?"col":"row",T=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${A} / outWidth;\n      let outCol = ${A} % outWidth;\n\n      let WRow = ${P} / (filterDims[1] * inChannels);\n      let WCol = ${P} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${l}) || fract(xR) > 0.0) {\n        return ${a}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${S}) || fract(xC) > 0.0) {\n        return ${a}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${P} % inChannels;\n      ${m}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${u}];`,k=e?`\n      let col = colIn * ${u};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${T}\n      }\n      return ${a}(0.0);`:`\n      let col = colIn * ${u};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${T}\n      }\n      return ${a}(0.0);`,O=`\n      let col = colIn * ${u};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${p(u)}\n      }\n      return ${a}(0.0);\n      `,{activationFunction:R,applyActivation:j}=Vt(t,a);return`\n      ${R}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?k:O}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?O:k}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {\n    let col = colIn * ${u};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${y}\n      ${ci(r)}\n      ${j}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${u}] = value;\n    }\n  }`},ll=(e,r,t,u,a,p,m,y)=>{let l=r.format==="NHWC",S=l?e[0].dims[3]:e[0].dims[1],A=t[0],P=l?t[2]:t[3],T=l?t[1]:t[2],k=l?t[3]:t[1],O=l?S%4===0&&k%4===0:P%4===0&&k%4===0,R=l?k:P*T,j=l?P*T:k,M=O?[8,8,1]:[R<=4||j<=4?4:16,R>4&&j<=4?4:16,1],z=O?[4,4,1]:[R<=4?1:4,R>4&&j<=4?1:4,1],q=[Math.ceil(R/M[0]/z[0]),Math.ceil(j/M[1]/z[1]),Math.ceil(A/M[2]/z[2])];Ge("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${q}`);let G=O?4:1,Y=Math.max(M[0]*G,M[1]),_=O?4:1,X=[{type:"int32",data:u},{type:"int32",data:a},{type:"int32",data:p}],J=te("x",e[0].dataType,e[0].dims.length,_),re=te("w",e[1].dataType,e[1].dims.length,1),fe=se("result",e[0].dataType,t.length,_),L=[J,re];X.push(...xe(e[0].dims)),X.push(...xe(e[1].dims));let oe="";if(m){let Se=te("bias",e[2].dataType,e[2].dims.length,_);L.push(Se),X.push(...xe(e[2].dims)),oe+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?"vec4<f32>":"f32"} {\n          return bias[coords.${l?"w":"y"}${O?"/ 4":""}];\n        }`}return X.push(...xe(t)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:q[0],y:q[1],z:q[2]},programUniforms:X}),getShaderSource:Se=>`\n        ${pi("uniforms.result_strides")}\n        ${Se.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...L,fe)};\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[l?1:2]}, ${r.kernelShape[l?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${r.dilations[0]<=1?0:(r.kernelShape[l?1:2]-1)*(r.dilations[0]-1)},\n              ${r.dilations[1]<=1?0:(r.kernelShape[l?2:3]-1)*(r.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        const dimAOuter : i32 = ${u};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${p};\n        ${oe}\n        ${vh(l,m,r,G)}\n        ${O?yn(z,M,"f32",void 0,!l,Y):bn(z,M,"f32",void 0,!l,Y,!1,void 0,y)}`}}});var wh,Zi,cl=ae(()=>{"use strict";zt();ke();Pe();wh=(e,r,t,u,a,p,m=!1,y)=>{let l=t.format==="NHWC",S=l?1:2,A=l?2:3,P=l?3:1,T=Z.size(u),k=m?2:1,O=t.group,R=r[1].dims,j=R[0]/O,M=R[1],z=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${m?`vec4<${y}>`:y}) {\n    result[flatIndex] = ${m?`vec4<${y}>`:y}(value);\n  }`;a&&(z+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${m?`vec4<${y}>`:y} {\n      return bias[coords.${l?"w":"y"}${m?"/ 4":""}];\n    }`);let q=m?4:1,G=te("W",r[1].dataType,r[1].dims,q),Y=te("Dy",r[0].dataType,r[0].dims,q),_=[Y,G];a&&_.push(te("bias",r[2].dataType,[u[P]],q));let X=se("result",r[0].dataType,u,q),J=`{\n        let batch: u32 = ${p?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${p?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${p?"global_id.y":"workgroup_id.y"} * ${k};\n        let d1: u32 = ${p?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${y}>, ${k}>;\n        for (var i = 0; i < ${k}; i++) {\n          dotProd[i] = vec4<${y}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${y}(dyCorner.x) + ${y}(wR)) / ${y}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${y}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${y}(dyCorner.y) + ${y}(wC)) / ${y}(strides.y);\n            let dyC2 = (${y}(dyCorner.y) + 1.0 + ${y}(wC)) / ${y}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${y}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${y}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${Y.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${y}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${Y.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${y}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${P}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${Y.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${y}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${G.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${Y.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${y}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${k}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${X.set("batch","r","c + i","d1","value")};\n        }\n      }`,re=`\n          let outputIndices = ${X.offsetToIndices("global_idx")};\n          let batch = ${X.indicesGet("outputIndices",0)};\n          let d1 = ${X.indicesGet("outputIndices",P)};\n          let r = ${X.indicesGet("outputIndices",S)};\n          let c = ${X.indicesGet("outputIndices",A)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${M};\n          let wOutChannel = d1 - groupId * ${M};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${y}(dyRCorner) + ${y}(wR)) / ${y}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${y}(outBackprop[${S}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${y}(dyCCorner) + ${y}(wC)) / ${y}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${y}(outBackprop[${A}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${j};\n              for (var d2: u32 = 0; d2 < ${j}; d2 = d2 + 1) {\n                let xValue = ${l?Y.get("batch","idyR","idyC","inputChannel"):Y.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${G.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${X.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,X)}\n  ${z}\n  const outShape : vec4<u32> = vec4<u32>(${u.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${r[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${t.strides[0]}, ${t.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${t.kernelShape[l?1:2]}, ${t.kernelShape[l?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${t.dilations[0]}, ${t.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${t.dilations[0]<=1?0:(t.kernelShape[l?1:2]-1)*(t.dilations[0]-1)},\n          ${t.dilations[1]<=1?0:(t.kernelShape[l?2:3]-1)*(t.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(T)};\n  ${m?J:re}}`},Zi=(e,r,t)=>{let u=e.length>2,a=r.outputShape,p=Z.size(a),m=[Math.ceil(p/64),1,1];Ge("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${m}`);let y=je(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:r.cacheKey},getRunData:()=>({dispatchGroup:{x:m[0],y:m[1],z:m[2]},outputs:[{dims:t?t(a):a,dataType:e[0].dataType}]}),getShaderSource:l=>wh(l,e,r,a,u,m[1]===1&&m[2]===1,!1,y)}}});var $h,Ch,Sh,fl,pl,xh,_h,Ih,Ah,ml,hl=ae(()=>{"use strict";Le();dl();cl();er();xr();$h=(e,r,t,u,a,p)=>(e-1)*r+t+(u-1)*a+1-p,Ch=(e,r,t,u,a)=>{let p=Math.floor(e/2);r==="SAME_UPPER"?(t[u]=p,t[a]=e-p):r==="SAME_LOWER"&&(t[u]=e-p,t[a]=p)},Sh=(e,r,t,u,a,p,m,y,l,S)=>{let A=e.length-2,P=S.length===0;if(l.length===0)for(let O=0;O<A;++O)l.push(0);let T=e[0],k=r[y?3:1]*a;for(let O=0,R=e.length-A-(y?1:0);O<A;++O,++R){let j=e[R],M=P?j*m[O]:S[O],z=$h(j,m[O],p[O],r[R],t[O],M);Ch(z,u,p,O,O+A),P&&S.push(m[O]*(j-1)+l[O]+(r[R]-1)*t[O]+1-p[O]-p[O+A])}S.splice(0,0,T),S.splice(y?3:1,0,k)},fl=(e,r)=>{let t=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((T,k)=>T*k,1)===0){t.length=0;for(let T=2;T<r[1].dims.length;++T)t.push(r[1].dims[T])}let u=e.format==="NHWC";t.splice(0,0,r[1].dims[0]),t.splice(u?3:1,0,r[1].dims[1]);let a=e.pads.slice(),p=e.outputShape.slice(),m=e.outputPadding.slice(),y=r[0].dims,l=e.dilations.slice();if(l.reduce((T,k)=>T+k,0)===0){let T=r[0].dims.length-2;l=new Array(T).fill(1)}let S=e.strides.slice();if(S.reduce((T,k)=>T+k,0)===0){let T=r[0].dims.length-2;S=new Array(T).fill(1)}Sh(y,t,l,e.autoPad,e.group,a,S,u,m,p);let A=Object.assign({},e),P=e.cacheKey+[t.join("n,"),a.join(","),S.join(","),m.join(","),p.join(","),l.join(",")].join("_");return Object.assign(A,{kernelShape:t,pads:a,outputPadding:m,outputShape:p,dilations:l,strides:S,cacheKey:P}),A},pl=e=>{let r=di(e),t=e.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,p=e.group,m=e.kernelShape,y=e.pads,l=e.strides,S=e.wIsConst(),A=e.outputPadding,P=e.outputShape;return he({autoPad:u,format:t,dilations:a,group:p,kernelShape:m,outputPadding:A,outputShape:P,pads:y,strides:l,wIsConst:S,...r})},xh=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],u=e[1].dims[0];if(t!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let p=e[0].dims.length-2;if(r.dilations.reduce((A,P)=>A+P,0)>0&&r.dilations.length!==p)throw new Error(`dilations should be ${p}D`);if(r.strides.reduce((A,P)=>A+P,0)>0&&r.strides.length!==p)throw new Error(`strides should be ${p}D`);if(r.pads.reduce((A,P)=>A+P,0)>0&&r.pads.length!==p*2)throw new Error(`pads should be ${p*2}D`);if(r.outputPadding.length!==p&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${p}D`);if(r.kernelShape.reduce((A,P)=>A+P,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},_h=[2,3,1,0],Ih=(e,r,t)=>{let u=fl(t,r),a=t.format==="NHWC",p=r.length===3;if(u.group!==1){e.compute(Zi(r,u));return}let m=u.outputShape,y=m[a?1:2],l=m[a?2:3],S=m[a?3:1],A=r[1].dims[2],P=r[1].dims[3],T=r[0].dims[a?3:1],k=a?y*l:S,O=a?S:y*l,R=A*P*T,j=!0,M=e.kernelCustomData.wT??e.compute($t(r[1],_h),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M);let z=[r[0],M];p&&(!a&&r[2].dims.length===1?z.push(r[2].reshape([r[2].dims[0],1,1])):z.push(r[2])),e.compute(ll(z,u,m,k,O,R,p,j),{inputs:z})},Ah=(e,r)=>{let t=r.format==="NHWC",u=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];u.length===3&&u.push(e.inputs[2]);let a=r.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let p=r.dilations;(p.length===0||p[0]===0)&&(p=[1]);let m=r.strides;(m.length===0||m[0]===0)&&(m=[1]);let y=r.pads;y.length===0&&(y=[0,0]),y=[0,y[0],0,y[1]],m=[1].concat(m),p=[1].concat(p),a=[1].concat(a);let l=fl({...r,pads:y,strides:m,dilations:p,kernelShape:a},u);e.compute(Zi(u,l,S=>t?[S[0],S[2],S[3]]:[S[0],S[1],S[3]]))},ml=(e,r)=>{xh(e.inputs,r),e.inputs[0].dims.length===3?Ah(e,r):Ih(e,e.inputs,r)}});var Xi,hi,gl,Th,Eh,Qi,Ji,yl,Oh,bl,vl,wl=ae(()=>{"use strict";ke();Le();Pe();Xi="[a-zA-Z]|\\\\.\\\\.\\\\.",hi="("+Xi+")+",gl="^"+hi+"$",Th="("+hi+",)*"+hi,Eh="^"+Th+"$",Qi=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,t){let u=this.symbolToIndices.get(r);u===void 0?u=[t]:u.push(t),this.symbolToIndices.set(r,u)}},Ji=class{constructor(r,t){this.equation=t;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[u,a]=t.includes("->")?t.split("->",2):[t,""];if(!u.match(RegExp(Eh)))throw new Error("Invalid LHS term");if(u.split(",").forEach((y,l)=>{let S=r[l].dims.slice();if(!y.match(RegExp(gl)))throw new Error("Invalid LHS term");let A=this.processTerm(y,!0,S,l);this.lhs.push(A)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([y,l])=>l.count===1||y==="...").map(([y])=>y).join("");else if(!a.match(RegExp(hi)))throw new Error("Invalid RHS");a.match(RegExp(Xi,"g"))?.forEach(y=>{if(y==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(y);if(l===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(a,!1,this.outputDims)}addSymbol(r,t,u){let a=this.symbolToInfo.get(r);if(a!==void 0){if(a.dimValue!==t&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(u)}else a={count:1,dimValue:t,inputIndices:[u]};this.symbolToInfo.set(r,a)}processTerm(r,t,u,a=-1){let p=u.length,m=!1,y=[],l=0;if(!r.match(RegExp(gl))&&!t&&r!=="")throw new Error("Invalid LHS term");let S=r.match(RegExp(Xi,"g")),A=new Qi(a);return S?.forEach((P,T)=>{if(P==="..."){if(m)throw new Error("Only one ellipsis is allowed per input term");m=!0;let k=p-S.length+1;if(k<0)throw new Error("Ellipsis out of bounds");if(y=u.slice(l,l+k),this.hasEllipsis){if(this.ellipsisDims.length!==y.length||this.ellipsisDims.toString()!==y.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=y;else throw new Error("Ellipsis must be specified in the LHS");for(let O=0;O<y.length;O++){let R=String.fromCharCode("0".charCodeAt(0)+O);A.addSymbol(R,T+O),this.addSymbol(R,u[l++],a)}}else A.addSymbol(P,T+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(P,u[l++],a)}),A}},yl=e=>e+"_max",Oh=(e,r,t,u,a)=>{let m=r.map((k,O)=>e[O]?k.length:k).map((k,O)=>te(`input${O}`,t,k)),y=Z.size(a),l=He(a.length),S=l?a.length:a,A=se("output",t,S),P=[...u.symbolToInfo.keys()].filter(k=>!u.rhs.symbolToIndices.has(k)),T=k=>{let O=[],R="var prod = 1.0;",j="var sum = 0.0;",M="sum += prod;",z=[],q=[],G=[],Y=[],_=u.symbolToInfo.size===u.rhs.symbolToIndices.size;u.symbolToInfo.forEach((J,re)=>{if(u.rhs.symbolToIndices.has(re)){let fe=u.rhs.symbolToIndices.get(re)?.[0];fe!==void 0&&u.lhs.forEach((L,oe)=>{if(J.inputIndices.includes(oe)){let Se=L.symbolToIndices.get(re);if(Se===void 0)throw new Error("Invalid symbol error");Se.forEach(me=>{O.push(`${m[oe].indicesSet(`input${oe}Indices`,me,A.indicesGet("outputIndices",fe))}`)})}})}else u.lhs.forEach((fe,L)=>{if(J.inputIndices.includes(L)){let oe=fe.symbolToIndices.get(re);if(oe===void 0)throw new Error("Invalid symbol error");oe.forEach(Se=>{z.push(`${m[L].indicesSet(`input${L}Indices`,Se,`${re}`)}`)}),Y.push(`prod *= ${m[L].getByIndices(`input${L}Indices`)};`)}}),q.push(`for(var ${re}: u32 = 0; ${re} < uniforms.${yl(re)}; ${re}++) {`),G.push("}")});let X=_?[...O,`let sum = ${m.map((J,re)=>J.getByIndices(`input${re}Indices`)).join(" * ")};`]:[...O,j,...q,...z,R,...Y,M,...G];return`\n            ${k.registerUniforms(P.map(J=>({name:`${yl(J)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...m,A)}\n\n            ${k.mainStart()}\n            ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${A.offsetToIndices("global_idx")};\n            ${m.map((J,re)=>`var input${re}Indices: ${m[re].type.indices};`).join(`\n`)}\n            ${X.join(`\n`)};\n            ${A.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:u.equation,inputDependencies:e.map(k=>k?"rank":"dims")},getRunData:()=>{let k=P.filter(R=>u.symbolToInfo.has(R)).map(R=>({type:"uint32",data:u.symbolToInfo.get(R)?.dimValue||0}));k.push({type:"uint32",data:y});let O=r.filter((R,j)=>e[j]).map((R,j)=>[...xe(R)]).reduce((R,j)=>R.concat(j),k);return l&&O.push(...xe(a)),{outputs:[{dims:a,dataType:t}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:O}},getShaderSource:T}},bl=(e,r)=>{let t=new Ji(e.inputs,r.equation),u=e.inputs.map((m,y)=>He(m.dims.length)),a=t.outputDims,p=e.inputs.map((m,y)=>m.dims);e.compute(Oh(u,p,e.inputs[0].dataType,t,a))},vl=e=>{let r=e.equation.replace(/\\s+/g,"");return he({equation:r})}});var kh,$l,Ph,Rh,Cl,Sl=ae(()=>{"use strict";Ze();ke();Pe();kh=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let r=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),u=t.length<r.length?0:t.length-r.length,a=r.length<t.length?0:r.length-t.length;for(;u<t.length&&a<r.length;++u,++a)if(t[u]!==r[a]&&t[u]!==1&&r[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},$l=(e,r)=>{let t=e.length-r.length,u=[];for(let a=0;a<t;++a)u.push(e[a]);for(let a=0;a<r.length;++a)u.push(r[a]===1?e[a+t]:r[a]);return u},Ph=(e,r)=>e.length>r.length?$l(e,r):$l(r,e),Rh=e=>{let r=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),u=Ph(r,t),a=e[0].dataType,p=a===9?4:1,m=Z.size(u)/p,y=He(r.length),l=He(u.length),S=P=>{let T=y?r.length:r,k=l?u.length:u,O=te("input",a,T,p),R=se("output",a,k,p),j;if(a===9){let M=(z,q,G="")=>`\n          let outputIndices${q} = ${R.offsetToIndices(`outputOffset + ${q}u`)};\n          let offset${q} = ${O.broadcastedIndicesToOffset(`outputIndices${q}`,R)};\n          let index${q} = offset${q} / 4u;\n          let component${q} = offset${q} % 4u;\n          ${z}[${q}] = ${G}(${O.getByOffset(`index${q}`)}[component${q}]);\n        `;j=`\n        let outputOffset = global_idx * ${p};\n        var data = vec4<u32>(0);\n        ${M("data",0,"u32")}\n        ${M("data",1,"u32")}\n        ${M("data",2,"u32")}\n        ${M("data",3,"u32")}\n        ${R.setByOffset("global_idx","data")}\n      }`}else j=`\n        let outputIndices = ${R.offsetToIndices("global_idx")};\n        let inputOffset = ${O.broadcastedIndicesToOffset("outputIndices",R)};\n        ${R.setByOffset("global_idx",O.getByOffset("inputOffset"))}\n      }`;return`\n    ${P.registerUniform("vec_size","u32").declareVariables(O,R)}\n    ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${j}`},A=[{type:"uint32",data:m}];return y&&A.push(...xe(r)),l&&A.push(...xe(u)),{name:"Expand",shaderCache:{hint:`${u.length}`,inputDependencies:[y?"rank":"dims"]},getShaderSource:S,getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:A})}},Cl=e=>{kh(e.inputs),e.compute(Rh(e.inputs),{inputs:[0]})}});var Bh,Mh,xl,_l,Il=ae(()=>{"use strict";Ze();ke();Le();Pe();Bh=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Mh=(e,r)=>{let t=e[0].dims,u=e[1].dims,a=t.length,p=Z.normalizeAxis(r.axis,a),m=t.slice(0);m.splice(p,1,...u);let y=t[p],l=e[0].dataType===9?4:1,S=Z.size(m)/l,A=He(e[0].dims.length),P=A?e[0].dims.length:e[0].dims,T=He(e[1].dims.length),k=T?e[1].dims.length:e[1].dims,O=He(m.length),R=O?m.length:m,j=[{type:"uint32",data:S},{type:"int32",data:y},{type:"uint32",data:p}];A&&j.push(...xe(e[0].dims)),T&&j.push(...xe(e[1].dims)),O&&j.push(...xe(m));let M=[];M.push(A?"rank":"dims"),M.push(T?"rank":"dims");let z=q=>{let G=te("data",e[0].dataType,P,l),Y=te("inputIndices",e[1].dataType,k),_=se("output",e[0].dataType,R,l),X=re=>{let fe=u.length,L=`var indicesIndices${re}  = ${Y.type.indices}(0);`;for(let oe=0;oe<fe;oe++)L+=`${fe>1?`indicesIndices${re}[${oe}]`:`indicesIndices${re}`} = ${m.length>1?`outputIndices${re}[uniforms.axis + ${oe}]`:`outputIndices${re}`};`;L+=`\n          var idx${re} = ${Y.getByIndices(`indicesIndices${re}`)};\n          if (idx${re} < 0) {\n            idx${re} = idx${re} + uniforms.axisDimLimit;\n          }\n          var dataIndices${re} = ${G.type.indices}(0);\n        `;for(let oe=0,Se=0;oe<a;oe++)oe===p?(L+=`${a>1?`dataIndices${re}[${oe}]`:`dataIndices${re}`} = u32(idx${re});`,Se+=fe):(L+=`${a>1?`dataIndices${re}[${oe}]`:`dataIndices${re}`} = ${m.length>1?`outputIndices${re}[${Se}]`:`outputIndices${re}`};`,Se++);return L},J;if(e[0].dataType===9){let re=(fe,L,oe="")=>`\n          let outputIndices${L} = ${_.offsetToIndices(`outputOffset + ${L}u`)};\n          ${X(L)};\n          let offset${L} = ${G.indicesToOffset(`dataIndices${L}`)};\n          let index${L} = offset${L} / 4u;\n          let component${L} = offset${L} % 4u;\n          ${fe}[${L}] = ${oe}(${G.getByOffset(`index${L}`)}[component${L}]);\n        `;J=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${re("value",0,"u32")}\n        ${re("value",1,"u32")}\n        ${re("value",2,"u32")}\n        ${re("value",3,"u32")}\n        ${_.setByOffset("global_idx","value")}\n      `}else J=`\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n      ${X("")};\n      let value = ${G.getByIndices("dataIndices")};\n      ${_.setByOffset("global_idx","value")};\n      `;return`\n      ${q.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(G,Y,_)}\n      ${q.mainStart()}\n        ${q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${J}\n      }`};return{name:"Gather",shaderCache:{hint:r.cacheKey,inputDependencies:M},getRunData:()=>({outputs:[{dims:m,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:j}),getShaderSource:z}},xl=e=>he({axis:e.axis}),_l=(e,r)=>{let t=e.inputs;Bh(t),e.compute(Mh(e.inputs,r))}});var Dh,jh,Al,Tl,El=ae(()=>{"use strict";ke();Le();Pe();Dh=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},jh=(e,r)=>{let t=e[0].dims,u=e[0].dataType,a=t.length,p=Z.computeStrides(t),m=Z.size(t),y=e[1].dims,l=e[1].dataType,S=Z.size(y),A=Z.normalizeAxis(r.axis,a),P=t[A],T=y.slice(0),k=Z.size(T),O=te("input",u,t),R=te("indices",l,[S]),j=se("output",u,T),M=z=>`\n      const inputStrides = array<u32, ${p.length}>(${p.map(q=>`${q}u`).join(",")});\n      ${z.declareVariables(O,R,j)}\n      ${z.mainStart()}\n      ${z.guardAgainstOutOfBoundsWorkgroupSizes(k)}\n\n      let outputIndices = ${j.offsetToIndices("global_idx")};\n\n      var idx = ${R.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${P};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${t.length}; i++) {\n        if (i == ${A}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${j.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${m}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:T,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)}}),getShaderSource:M}},Al=e=>he({axis:e.axis}),Tl=(e,r)=>{let t=e.inputs;Dh(t),e.compute(jh(e.inputs,r))}});var zh,Vh,Wh,Ol,kl,Pl=ae(()=>{"use strict";ke();Le();Pe();zh=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Vh=(e,r,t)=>{if(t.length===0)return"0u";let u=t.length===1&&e!==1||t.length===2&&t[0]!==e,a=t[t.length-1]!==r,p="0u";return u||(p+=`+ m * ${t[t.length-1]}u`),a||(p+="+n"),p},Wh=(e,r)=>{let t=e[0].dims.slice(),u=e[1].dims.slice(),[a,p,m]=Qn.getShapeOfGemmResult(t,r.transA,u,r.transB,e.length===3?e[2].dims:void 0),y=[a,p];if(!y)throw new Error("Can\'t use gemm on the given tensors");let l=Z.size(y),S="";r.transA&&r.transB?S="value += a[k * M + m] * b[n * K + k];":r.transA&&!r.transB?S="value += a[k * M + m] * b[k * N + n];":!r.transA&&r.transB?S="value += a[m * K + k] * b[n * K + k];":!r.transA&&!r.transB&&(S="value += a[m * K + k] * b[k * N + n];");let A=je(e[0].dataType),P=r.alpha===1?"":"value *= alpha;",T=e.length===3?`value += beta * c[${Vh(a,p,e[2].dims)}];`:"",k=[`@group(0) @binding(0) var<storage, read> a : array<${A}>;`,`@group(0) @binding(1) var<storage, read> b : array<${A}>;`];e.length===3&&k.push(`@group(0) @binding(2) var<storage, read> c : array<${A}>;`);let O=R=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${p}u;\n  const K: u32 = ${m}u;\n  const alpha = ${A}(${r.alpha});\n  const beta = ${A}(${r.beta});\n\n  ${k.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${A}>;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${A}(0);\n    for (var k: u32 = 0u; k<${m}u; k++) {\n      ${S}\n    }\n\n    ${P}\n    ${T}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:y,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:O}},Ol=(e,r)=>{zh(e.inputs),e.compute(Wh(e.inputs,r))},kl=e=>he(e)});var Uh,Nh,Hh,Gh,Rl,Bl,Ml=ae(()=>{"use strict";Ze();ke();Le();Pe();Uh={name:"InstanceNormalization"},Nh=(e,r)=>{let t=e[0].dims,u=t,a=2,p=Z.sizeToDimension(t,a),m=Z.sizeFromDimension(t,a),y=t[1],l=te("x",e[0].dataType,[t[0],t[1],m]),S=te("scale",e[1].dataType,e[1].dims),A=te("bias",e[2].dataType,e[2].dims),P=se("output",e[0].dataType,[t[0],t[1],m]),T=[l,S,A,P],k=l.type.value,O=64,R=j=>`\n\n  const C: u32 = ${y};\n  const normSize: u32 = ${m};\n  const epsilon: f32 = ${r.epsilon};\n  var<workgroup> meanShared : ${k};\n  var<workgroup> squaredNormShared : ${k};\n  var<workgroup> workgroupShared : array<${k}, ${O}>;\n  const workgroupSize = ${O}u;\n  ${j.declareVariables(...T)}\n  ${j.mainStart(O)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${k} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${l.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${k}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${l.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${k}(normSize) + epsilon);\n    let channelScale = invStdDev * ${S.getByOffset("channel")};\n    let channelShift = ${A.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${l.get("batch","channel","h")} * channelScale + channelShift;\n      ${P.set("batch","channel","h","value")};\n    }\n  }`;return{...Uh,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:p}}),getShaderSource:R}},Hh=(e,r,t,u,a,p,m,y)=>{let l=lt(m),S=te("input",r.dataType,r.dims,l),A=te("scale",t.dataType,t.dims,l),P=te("bias",u.dataType,u.dims,l),T=64,k=l===1?"vec2f":`mat2x${l}f`,O=l===1?"f32":`vec${l}f`,R=(Y,_)=>`${k}(${Y}, ${_})`,j=a*m/l,M=Math.ceil(p/T),z=Y=>`\n  const H: u32 = ${p};\n  const C: u32 = ${m/l};\n  const imageSize: u32 = ${p*m/l};\n\n  ${Y.declareVariables(S)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${k}>;\n\n  ${Y.mainStart(T)}\n    let currentImageNumber = global_idx / ${T} / C;\n    let currentChannelNumber = (global_idx / ${T}) % C;\n    let wgId = global_idx % ${T};\n    let wgOffset = wgId * ${M};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${M}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${ot("f32",l)};\n    var squaredSum = ${ot("f32",l)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${O}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${R("sum","squaredSum")};\n  }`,q=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:l,n:a,h:p,c:m})},getRunData:()=>({outputs:[{dims:[a,m,T,2],dataType:1}],dispatchGroup:{x:a*m/l}}),getShaderSource:z},{inputs:[r],outputs:[-1]})[0],G=Y=>`\n  const H: u32 = ${p};\n  const C: u32 = ${m/l};\n  const imageSize: u32 = ${T*m/l};\n  const epsilon: f32 = ${y};\n\n  @group(0) @binding(0) var<storage, read> input : array<${k}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${A.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${P.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${k}>;\n\n  ${Y.mainStart()}\n    ${Y.guardAgainstOutOfBoundsWorkgroupSizes(j)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${ot("f32",l)};\n    var squaredSum = ${ot("f32",l)};\n    for (var i: u32 = 0; i < ${T}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${T}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${O}(scale[currentChannelNumber]);\n    let channelShift = ${O}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${R("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:l,n:a,h:p,c:m,epsilon:y})},getRunData:()=>({outputs:[{dims:[a,m,2],dataType:1}],dispatchGroup:{x:Math.ceil(j/64)}}),getShaderSource:G},{inputs:[q,t,u],outputs:[-1]})[0]},Gh=(e,r,t)=>{let u=r[0].dims,a=u,p=u[0],m=u[u.length-1],y=Z.sizeFromDimension(u,1)/m,l=lt(m),S=Z.size(a)/l,A=te("input",r[0].dataType,r[0].dims,l),P=se("output",r[0].dataType,a,l),T=je(r[0].dataType),k=l===1?"vec2f":`mat2x${l}f`,O=l===1?T:`vec${l}<${T}>`,R=Hh(e,r[0],r[1],r[2],p,y,m,t.epsilon),j=M=>`\n  const H: u32 = ${y};\n  const C: u32 = ${m/l};\n\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${k}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${P.type.storage}>;\n\n  ${M.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${O}(scale[0]), ${O}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${t.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:j},{inputs:[r[0],R]})},Rl=e=>he({epsilon:e.epsilon,format:e.format}),Bl=(e,r)=>{r.format==="NHWC"?Gh(e,e.inputs,r):e.compute(Nh(e.inputs,r))}});var Lh,Fh,Dl,jl,zl=ae(()=>{"use strict";Ze();ke();Le();Pe();Lh=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Fh=(e,r,t)=>{let u=e[0].dims,a=e[1],p=e[2],m=u,y=Z.normalizeAxis(r.axis,u.length),l=Z.sizeToDimension(u,y),S=Z.sizeFromDimension(u,y),A=Z.size(a.dims),P=p?Z.size(p.dims):0;if(A!==S||p&&P!==S)throw new Error(`Size of X.shape()[axis:] == ${S}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${A} and bias size of ${P}`);let T=[];for(let G=0;G<u.length;++G)G<y?T.push(u[G]):T.push(1);let k=lt(S),O=je(e[0].dataType),R=[te("x",e[0].dataType,e[0].dims,k),te("scale",a.dataType,a.dims,k)];p&&R.push(te("bias",p.dataType,p.dims,k)),R.push(se("output",e[0].dataType,m,k));let j=t>1,M=t>2;j&&R.push(se("meanDataOutput",1,T)),M&&R.push(se("invStdOutput",1,T));let z=G=>`\n  const normSize: f32 = ${S};\n  const normSizeVectorized: u32 = ${S/k};\n  const epsilon: f32 = ${r.epsilon};\n\n  ${G.declareVariables(...R)}\n  ${G.mainStart()}\n    ${G.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${ot("f32",k)};\n    var meanSquareVector = ${ot("f32",k)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${vt(O,k,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${wt("meanVector",k)} / normSize;\n    let meanSquare = sqrt(${wt("meanSquareVector",k)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${vt(O,k,"x[j + offset]")};\n      let f32scale = ${vt(O,k,"scale[j]")};\n      output[j + offset] = ${R[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${p?`+ ${vt(O,k,"bias[j]")}`:""}\n      );\n    }\n\n    ${j?"meanDataOutput[global_idx] = mean":""};\n    ${M?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,q=[{dims:m,dataType:e[0].dataType}];return j&&q.push({dims:T,dataType:1}),M&&q.push({dims:T,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${r.cacheKey}|${t}|${e.length}`},getRunData:()=>({outputs:q,dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:z}},Dl=e=>he({axis:e.axis,epsilon:e.epsilon}),jl=(e,r)=>{Lh(e.inputs),e.compute(Fh(e.inputs,r,e.outputCount))}});var qh,Vl,Wl=ae(()=>{"use strict";ke();vn();qh=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Vl=e=>{qh(e.inputs);let r=Tt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!r)throw new Error("Can\'t use matmul on the given tensors");e.compute(mi(e.inputs,{activation:"",activationCacheKey:""},r))}});var Kh,Nl,Ul,Yh,eo,Hl,Gl=ae(()=>{"use strict";ke();Le();Zn();Wi();Pe();xr();Kh=(e,r)=>{let t=e[0],u=e[1],a=e[2],p=e[3],m=e[4],y=e[5],l=e[6],S=e[7];if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let A=!1,P=t.dims[0],T=t.dims[1],k=t.dims.length===3?A?t.dims[2]/3:t.dims[2]:r.numHeads*t.dims[4],O=T,R=0,j=0,M=Math.floor(k/r.numHeads);if(l&&S){if(l.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(S.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');R=l.dims[2],j=l.dims[2]}else if(l||S)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let z;if(u){if(t.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(u.dims.length<3||u.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(t.dims[0]!==u.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(u.dims.length===3){if(u.dims[2]!==t.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');z=2,O=u.dims[1]}else if(u.dims.length===5){if(u.dims[2]!==r.numHeads||u.dims[3]!==2||u.dims[4]!==M)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(a)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');z=5,O=u.dims[1]}else{if(u.dims[1]!==r.numHeads||u.dims[3]!==M)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');z=0,O=u.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(t.dims.length===5&&(t.dims[2]!==r.numHeads||t.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');z=3}if(p){if(p.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(a&&t.dims.length===5&&t.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let q=0;if(m){q=8;let J=m.dims;throw J.length===1?J[0]===P?q=1:J[0]===3*P+2&&(q=3):J.length===2&&J[0]===P&&J[1]===O&&(q=5),q===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let G=!1,Y=k;if(a){if(a.dims.length!==3&&a.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(t.dims[0]!==a.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(a.dims.length===3){if(O!==a.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');Y=a.dims[2]}else{if(O!==a.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');Y=a.dims[1]*a.dims[3],G=!0}}let _=R+O,X=!1;if(m)throw new Error("Key padding mask is not supported");if(y)throw new Error("extraAddQk is not supported");if(l)throw new Error("pastKey is not supported");if(S)throw new Error("pastValue is not supported");return{batchSize:P,sequenceLength:T,pastSequenceLength:R,kvSequenceLength:O,totalSequenceLength:_,maxSequenceLength:j,inputHiddenSize:0,hiddenSize:k,vHiddenSize:Y,headSize:M,vHeadSize:Math.floor(Y/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:q,scale:r.scale,broadcastResPosBias:X,passPastInKv:G,qkvFormat:z}},Nl=e=>he({...e}),Ul=he({perm:[0,2,1,3]}),Yh=(e,r,t,u,a,p,m)=>{let y=[u,a,p],l=Z.size(y),S=je(r.dataType),A=P=>`\n  const biasOffset = ${m}u;\n  const hiddenSize = ${p}u;\n\n  @group(0) @binding(0) var<storage, read> qkv: array<${S}>;\n  @group(0) @binding(1) var<storage, read> bias: array<${S}>;\n  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${S}>;\n\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];\n  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:u,sequenceLength:a,hiddenSize:p,biasOffset:m})},getRunData:()=>({outputs:[{dims:y,dataType:r.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:A},{inputs:[r,t],outputs:[-1]})[0]},eo=(e,r,t,u,a,p,m,y)=>{let l=p;if(m){if(u===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=Yh(e,p,m,r,u,t*a,y),l=l.reshape([r,u,t,a]),e.compute($t(l,Ul.perm),{inputs:[l],outputs:[-1]})[0]}else return p.dims.length===3&&(l=p.reshape([r,u,t,a])),e.compute($t(l,Ul.perm),{inputs:[l],outputs:[-1]})[0]},Hl=(e,r)=>{let t=Kh(e.inputs,r);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let u=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,a=eo(e,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,e.inputs[0],e.inputs[3],0);if(u)return ni(e,a,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],t,r);let p=eo(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,e.inputs[1],e.inputs[3],t.hiddenSize),m=eo(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,e.inputs[2],e.inputs[3],2*t.hiddenSize);ni(e,a,p,m,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],t,r)}});var Zh,Xh,Qh,Jh,eg,tg,rg,ng,ig,Ll,Fl,ql=ae(()=>{"use strict";Ze();ke();Le();Pe();Zh=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let r=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(r=e[3].dims[0]*2===e[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Xh=(e,r,t,u,a,p)=>{let m=r.length,y="";for(let l=m-1;l>=0;--l)y+=`\n            k = i32(${e.indicesGet("indices",l)}) - ${u[l]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[l]}) {\n              break;\n            }\n            offset += k * ${t[l]};\n        `;return`\n          value = ${a}(${p});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${y}\n            value = x[offset];\n          }\n      `},Qh=(e,r,t,u)=>{let a=r.length,p="";for(let m=a-1;m>=0;--m)p+=`\n                k = i32(${e.indicesGet("indices",m)}) - ${u[m]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[m]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[m]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${t[m]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${p}\n              value = x[offset];\n          `},Jh=(e,r,t,u)=>{let a=r.length,p="";for(let m=a-1;m>=0;--m)p+=`\n                k = i32(${e.indicesGet("indices",m)}) - ${u[m]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[m]}) {\n                  k = ${r[m]-1};\n                }\n                offset += k * ${t[m]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${p}\n              value = x[offset];\n          `},eg=(e,r,t,u)=>{let a=r.length,p="";for(let m=a-1;m>=0;--m)p+=`\n                k = i32(${e.indicesGet("indices",m)}) - ${u[m]};\n                if (k < 0)  {\n                  k += ${r[m]};\n                }\n                if (k >= ${r[m]}) {\n                  k -= ${r[m]};\n                }\n                offset += k * ${t[m]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${p}\n              value = x[offset];\n          `},tg=(e,r,t,u,a)=>{switch(u.mode){case 0:return Xh(e,r,t,u.pads,a,u.value);case 1:return Qh(e,r,t,u.pads);case 2:return Jh(e,r,t,u.pads);case 3:return eg(e,r,t,u.pads);default:throw new Error("Invalid mode")}},rg=(e,r,t,u)=>{let a=r[0].dims,p=Z.padShape(a.slice(),t.pads),m=Z.size(p),y=Z.computeStrides(a),l=se("output",r[0].dataType,p),S=te("x",r[0].dataType,a),A=tg(l,a,y,t,u);return`\n              ${e.declareVariables(S,l)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n\n              let indices = ${l.offsetToIndices("global_idx")};\n\n              var value = ${u}(0);\n              ${A}\n              output[global_idx] = value;\n          }`},ng=(e,r)=>{let t=Z.padShape(e[0].dims.slice(),r.pads);return{name:"Pad",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Z.size(t)/64)}}),getShaderSource:u=>rg(u,e,r,"f32")}},ig=(e,r)=>{if(e.length>1){let t=e[1].getBigInt64Array(),u=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,p=new Int32Array(2*a).fill(0);if(e.length>=4){let y=e[3].getBigInt64Array();for(let l=0;l<y.length;l++)p[Number(y[l])]=Number(t[l]),p[Number(y[l])+a]=Number(t[l+y.length])}else t.forEach((y,l)=>p[Number(l)]=Number(y));let m=[];return p.forEach(y=>m.push(y)),he({mode:r.mode,value:u,pads:m})}else return r},Ll=(e,r)=>{Zh(e.inputs);let t=ig(e.inputs,r);e.compute(ng(e.inputs,t),{inputs:[0]})},Fl=e=>{let r=e.mode,t=e.value,u=e.pads;return he({mode:r,value:t,pads:u})}});var gi,Kl,Yl,Zl,Xl,Ql,Jl,ed,td,rd,nd,id,od,ad,sd,ud=ae(()=>{"use strict";ke();Le();Pe();gi=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Kl=(e,r,t)=>{let u=r.format==="NHWC",a=e.dims.slice();u&&a.splice(1,0,a.pop());let p=Object.hasOwnProperty.call(r,"dilations"),m=r.kernelShape.slice(),y=r.strides.slice(),l=p?r.dilations.slice():[],S=r.pads.slice();Jt.adjustPoolAttributes(t,a,m,y,l,S);let A=Jt.computePoolOutputShape(t,a,y,l,m,S,r.autoPad),P=Object.assign({},r);p?Object.assign(P,{kernelShape:m,strides:y,pads:S,dilations:l,cacheKey:r.cacheKey}):Object.assign(P,{kernelShape:m,strides:y,pads:S,cacheKey:r.cacheKey});let T=A.slice();return T.push(T.splice(1,1)[0]),[P,u?T:A]},Yl=(e,r,t,u,a,p,m,y)=>{let l=a.format==="NHWC",S=t,A=r.type.value,P=S.length,T=Z.size(u),k=se("output",r.type.tensor,u);if(a.kernelShape.length<=2){let O=a.kernelShape[a.kernelShape.length-1],R=a.strides[a.strides.length-1],j=a.pads[a.pads.length/2-1],M=a.pads[a.pads.length-1],z=P-(l?2:1),q="",G="",Y="";if(j+M!==0?q=`\n                for (var i: u32 = 0u; i < ${O}u; i++) {\n                  xIndices[${z}] = indices[${z}] * ${R} - ${j} + i;\n                  if (xIndices[${z}] < 0 || xIndices[${z}] >= ${S[z]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${r.indicesToOffset("xIndices")}];\n                  ${p}\n                }`:q=`\n                for (var i: u32 = 0u; i < ${O}u; i++) {\n                  xIndices[${z}] = indices[${z}] * ${R} - ${j} + i;\n                  let x_val = x[${r.indicesToOffset("xIndices")}];\n                  ${p}\n                }`,a.kernelShape.length===2){let X=a.kernelShape[a.kernelShape.length-2],J=a.strides[a.strides.length-2],re=a.pads[a.pads.length/2-2],fe=a.pads[a.pads.length-2],L=P-(l?3:2),oe=S[L];re+fe!==0?G=`\n                for (var j: u32 = 0u; j < ${X}u; j++) {\n                  xIndices[${L}] = indices[${L}] * ${J} - ${re} + j;\n                  if (xIndices[${L}] < 0 || xIndices[${L}] >= ${oe}) {\n                    pad+= ${O};\n                    continue;\n                  }\n              `:G=`\n                for (var j: u32 = 0u; j < ${X}u; j++) {\n                  xIndices[${L}] = indices[${L}] * ${J} - ${re} + j;\n                `,Y=`\n              }\n            `}return`\n            ${e.declareVariables(r,k)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(T)}\n\n              let indices = ${k.offsetToIndices("global_idx")};\n              var xIndices = ${k.offsetToIndices("global_idx")};\n\n              var value: ${A} = ${A}(${y});\n              var pad = 0;\n              ${G}\n              ${q}\n              ${Y}\n              ${m}\n\n              output[global_idx] = value;\n            }`}else{if(l)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let O=Z.size(a.kernelShape),R=Z.computeStrides(a.kernelShape),j=R.length,M=a.pads.length,z=a.pads.reduce((Y,_)=>Y+_),q="";return z?q=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${p}\n              }`:q=`\n              }\n              let x_val = x[${r.indicesToOffset("xIndices")}];\n              ${p}\n            `,`\n            ${e.declareVariables(r,k)}\n\n            const pads = array<u32, ${M}>(${a.pads.map(Y=>`${Y}u`).join(",")});\n            const inputDims = array<u32, ${P}>(${S.map(Y=>`${Y}u`).join(",")});\n            const kernelStrides = array<u32, ${j}>(${R.map(Y=>`${Y}u`).join(",")});\n            const strides = array<u32, ${j}>(${a.strides.map(Y=>`${Y}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(T)}\n\n              let indices = ${k.offsetToIndices("global_idx")};\n              let xIndices = ${k.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${j}>;\n\n              var value = ${k.type.value}(${y});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${O}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${j-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${j-1}] = offset;\n\n                isPad = false;\n                for (var j = ${P-j}u; j < ${P}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${P-j}u]\n                    + offsets[j - ${P-j}u] - pads[j - 2u];\n                  ${q}\n              }\n              ${m}\n\n              output[global_idx] = value;\n            }`}},Zl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xl=(e,r,t,u)=>{let[a,p]=Kl(r,u,t),m=Z.size(a.kernelShape),y=te("x",r.dataType,r.dims),l=y.type.value,S="value += x_val;",A="";return a.countIncludePad?A+=`value /= ${l}(${m});`:A+=`value /= ${l}(${m} - pad);`,{name:e,shaderCache:{hint:u.cacheKey},getRunData:()=>({outputs:[{dims:p,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Z.size(p)/64)}}),getShaderSource:P=>Yl(P,y,r.dims,p,a,S,A,"0.0")}},Ql=e=>{let r=e.count_include_pad!==0,t=Zl(e);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return he({countIncludePad:r,...t})},Jl=(e,r)=>{gi(e.inputs),e.compute(Xl("AveragePool",e.inputs[0],!1,r))},ed={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},td=e=>{let r=e.format;return{format:r,...ed,cacheKey:r}},rd=(e,r)=>{gi(e.inputs),e.compute(Xl("GlobalAveragePool",e.inputs[0],!0,r))},nd=(e,r,t,u)=>{let[a,p]=Kl(r,u,t),m=`\n      value = max(x_val, value);\n    `,y="",l=te("x",r.dataType,r.dims);return{name:e,shaderCache:{hint:u.cacheKey},getRunData:()=>({outputs:[{dims:p,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Z.size(p)/64)}}),getShaderSource:S=>Yl(S,l,r.dims,p,a,m,y,"-1e5")}},id=(e,r)=>{gi(e.inputs),e.compute(nd("MaxPool",e.inputs[0],!1,r))},od=e=>{let r=e.storage_order,t=e.dilations,u=Zl(e);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(u.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return he({storageOrder:r,dilations:t,...u})},ad=e=>{let r=e.format;return{format:r,...ed,cacheKey:r}},sd=(e,r)=>{gi(e.inputs),e.compute(nd("GlobalMaxPool",e.inputs[0],!0,r))}});var ag,sg,ld,dd=ae(()=>{"use strict";Ni();Ze();Pe();ag=(e,r,t)=>{let u=e===r,a=e<r&&t<0,p=e>r&&t>0;if(u||a||p)throw new Error("Range these inputs\' contents are invalid.")},sg=(e,r,t,u)=>{let a=Math.abs(Math.ceil((r-e)/t)),p=[a],m=a,y=se("output",u,p),l=y.type.storage,S=A=>`\n        ${A.declareVariables(y)}\n        ${A.mainStart()}\n        ${A.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n        output[global_idx] = ${l}(${e}) + ${l}(global_idx) * ${l}(${t});\n      }`;return{name:"Range",shaderCache:{hint:[e,r,t].map(A=>A.toString()).join("_")},getShaderSource:S,getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(m/64)}})}},ld=e=>{let r=0,t=0,u=0;e.inputs[0].dataType===6?(r=e.inputs[0].getInt32Array()[0],t=e.inputs[1].getInt32Array()[0],u=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(r=e.inputs[0].getFloat32Array()[0],t=e.inputs[1].getFloat32Array()[0],u=e.inputs[2].getFloat32Array()[0]),oi.webgpu.validateInputContent&&ag(r,t,u),e.compute(sg(r,t,u,e.inputs[0].dataType),{inputs:[]})}});var ug,lg,dg,cg,fg,pg,mg,hg,gg,yg,bg,vg,wg,$g,Cg,cd,fd,pd=ae(()=>{"use strict";ke();Le();Pe();ug=(e,r)=>{if(e.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(r.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(r.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},lg=(e,r,t)=>{r.every(a=>a>=0&&a<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let u=new Array(t).fill(1);return r.forEach((a,p)=>u[a]=e[p]),u},dg=(e,r,t,u,a,p)=>{let[m,y,l]=t>10?[1,2,3]:[-1,e.length>1?1:-1,-1],S=e[0].dims.length;if(m>0&&e.length>m&&e[m].dims.length>0)e[m].getFloat32Array().forEach(A=>p.push(A));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(y>0&&e.length>y&&e[y].dims.length>0){if(e[y].getFloat32Array().forEach(A=>u.push(A)),u.length!==0&&u.length!==S&&t>=18&&u.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ug(u,r),r.axes.length>0&&lg(u,r.axes,S).forEach((A,P)=>u[P]=A)}if(l>0&&e.length>l&&(e[l].getBigInt64Array().forEach(A=>a.push(Number(A))),a.length!==S||t>=18&&a.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(u.length!==r.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(a.length!==r.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof u<"u"&&typeof a<"u"&&u.length>0&&a.length>S)throw new Error("Resize requires only of scales or sizes to be specified")},cg=(e,r)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${r}, xScale: ${r}, lengthResized: ${r},\n     lengthOriginal: ${r}, roiStart: ${r}, roiEnd: ${r}) -> ${r} { `+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${r}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",fg=(e,r,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",pg=(e,r,t)=>{let u=new Array(t).fill(0).concat(new Array(t).fill(1)),a=e.length===0?u:e.slice();return r.length>0?(r.forEach((p,m)=>{u[p]=a[m],u[m+t]=a[r.length+m]}),u):a},mg=(e,r,t,u)=>{let a=[];if(t.length>0)if(u.length>0){if(e.forEach(p=>a.push(p)),Math.max(...u)>e.length)throw new Error("axes is out of bound");u.forEach((p,m)=>a[p]=t[m])}else t.forEach(p=>a.push(p));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((p,m)=>Math.round(p*r[m]))}return a},hg=(e,r,t)=>{let u=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(p=>r[p]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(p=>r[p]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let a=e.slice();return t.axes.length>0?(t.axes.forEach(p=>r[p]=u),t.axes.forEach(p=>a[p]=Math.round(e[p]*r[p]))):(r.fill(u,0,r.length),a.forEach((p,m)=>a[m]=Math.round(p*r[m]))),a},gg=(e,r,t,u,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<${e.type.value}, ${t.length}> {\n      const inputShape = array<u32, ${r.length}>(${r.map(p=>`${p}u`).join(",")});\n      const outputShape = array<u32, ${t.length}>(${t.map(p=>`${p}u`).join(",")});\n      const scales = array<${e.type.value}, ${u.length}>(${u.map(p=>`${p}f`).join(",")});\n      const roi = array<${e.type.value}, ${a.length}>(${a.map(p=>`${p}f`).join(",")});\n      var originalIndices: array<${e.type.value}, ${t.length}>;\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = ${e.type.value}(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(${e.type.value}(outputIndex), scales[i],\n                ${e.type.value}(outputShape[i]), ${e.type.value}(inputShape[i]), roi[i], roi[i + ${r.length}]);\n        }\n      }\n      return originalIndices;\n    }`,yg=(e,r,t,u,a,p,m)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${t.length}>(${t.map(y=>`${y}u`).join(",")});\n        const outputShape = array<u32, ${u.length}>(${u.map(y=>`${y}u`).join(",")});\n        const scales = array<${e.type.value}, ${a.length}>(${a.map(y=>`${y}`).join(",")});\n        const roi = array<${e.type.value}, ${p.length}>(${p.map(y=>`${y}`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${u.length}; i++) {\n          var outputIndex = ${u.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(${e.type.value}(outputIndex), scales[i],\n                    ${e.type.value}(outputShape[i]), ${e.type.value}(inputShape[i]), roi[i], roi[i + ${t.length}]);\n            if (!${m} || (original_idx >= 0 && original_idx < ${e.type.value}(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (${e.type.value}(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,bg=(e,r)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${r.length}>(${r.map(t=>`${t}u`).join(",")});\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var inputIndex = ${r.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,vg=(e,r,t,u,a,p)=>{let[m,y,l,S]=t.length===2?[-1,0,1,-1]:u[1]===1?[0,2,3,1]:[0,1,2,3],A=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${A} {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${y}] = max(0, min(row, ${t[y]} - 1));\n      inputIndices[${l}] = max(0, min(col, ${t[l]} - 1));\n      if (${t.length} > 2) {\n        inputIndices[${S}] = channel;\n        inputIndices[${m}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${r.type.indices}) -> ${A} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:${A} = originalIndices[${y}];\n      var col:${A} = originalIndices[${l}];\n      if (${a} && (row < 0 || row > (${t[y]} - 1) || col < 0 || col > ${t[l]} - 1)) {\n        return ${p};\n      }\n      row = max(0, min(row, ${t[y]} - 1));\n      col = max(0, min(col, ${t[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${t.length>2}) {\n        channel = u32(originalIndices[${S}]);\n        batch = u32(originalIndices[${m}]);\n      }\n      var x11: ${A} = getInputValue(batch, channel, row1, col1);\n      var x12: ${A} = getInputValue(batch, channel, row1, col2);\n      var x21: ${A} = getInputValue(batch, channel, row2, col1);\n      var x22: ${A} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${A} = row - ${A}(row1);\n      var dx2: ${A} = ${A}(row2) - row;\n      var dy1 = col - ${A}(col1);\n      var dy2 = ${A}(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},wg=(e,r,t,u,a,p,m,y,l,S)=>{let[A,P]=t.length===2?[0,1]:a[1]===1?[2,3]:[1,2],T=e.type.value,k=O=>{let R=O===A?"row":"col";return`\n      fn ${R}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${r.type.indices}) -> ${T} {\n        var outputIndex = ${u.length===1?"outputIndices":`outputIndices[${O}]`};\n        var originalIdx: ${T} = getOriginalCoordinateFromResizedCoordinate(${T}(outputIndex), ${a[O]},\n        ${T}(${u[O]}), ${T}(${t[O]}), ${p[O]}, ${p[O]} + ${t.length});\n        var fractOriginalIdx: ${T} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${y} && (originalIdx < 0 || originalIdx > (${t[O]} - 1))) {\n          return ${l};\n        }\n        var data: array<${T}, 4> = array<${T}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${R}: ${T} = originalIdx + ${T}(i);\n          if (${R} < 0 || ${R} >= ${t[O]}) {\n            if (${S}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${y}) {\n              return ${l};\n            } else {\n              ${R} = max(0, min(${R}, ${t[O]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${O}] = u32(${R});\n          data[i + 1] = ${O===A?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${k(A)};\n    ${k(P)};\n  fn getCubicInterpolationCoefs(s: ${T}) -> array<${T}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${T}, 4> = array<${T}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${T} = 1.0 - absS;\n    var twoMinusAbsS: ${T} = 2.0 - absS;\n    var onePlusAbsS: ${T} = 1.0 + absS;\n    coeffs[0] = ((${m} * onePlusAbsS - 5 * ${m}) * onePlusAbsS + 8 * ${m}) * onePlusAbsS - 4 * ${m};\n    coeffs[1] = ((${m} + 2) * absS - (${m} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${m} + 2) * oneMinusAbsS - (${m} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${m} * twoMinusAbsS - 5 * ${m}) * twoMinusAbsS + 8 * ${m}) * twoMinusAbsS - 4 * ${m};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${T}, 4>, coefs: array<${T}, 4>) -> ${T} {\n    var coefsSum: ${T} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${r.type.indices}) -> ${T} {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},$g=(e,r,t,u,a,p)=>{let m=e.dims,y=pg(p,r.axes,m.length),l=mg(m,u,a,r.axes),S=u.slice();u.length===0&&(S=m.map((M,z)=>M===0?1:l[z]/M),r.keepAspectRatioPolicy!=="stretch"&&(l=hg(m,S,r)));let A=se("output",e.dataType,l),P=te("input",e.dataType,m),T=Z.size(l),k=m.length===l.length&&m.every((M,z)=>M===l[z]),O=r.coordinateTransformMode==="tf_crop_and_resize",R=P.type.value,j=M=>`\n      ${k?"":`\n      ${cg(r.coordinateTransformMode,R)};\n      ${(()=>{switch(r.mode){case"nearest":return`\n              ${bg(P,m)};\n              ${fg(r.nearestMode,t,R)};\n              ${yg(P,A,m,l,S,y,O)};\n              `;case"linear":return`\n              ${gg(A,m,l,S,y)};\n              ${vg(P,A,m,S,O,r.extrapolationValue)};\n              `;case"cubic":return`\n            ${wg(P,A,m,l,S,y,r.cubicCoeffA,O,r.extrapolationValue,r.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${M.declareVariables(P,A)}\n      ${M.mainStart()}\n        ${M.guardAgainstOutOfBoundsWorkgroupSizes(T)}\n        ${k?"output[global_idx] = input[global_idx];":`\n        let outputIndices = ${A.offsetToIndices("global_idx")};\n        var inputIndices: ${P.type.indices};\n        ${(()=>{switch(r.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                if (checkInputIndices(inputIndices)) {\n                  output[global_idx] = input[${P.indicesToOffset("inputIndices")}];\n                } else {\n                  output[global_idx] = ${r.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${t}|${S.length>0?S:""}|${a.length>0?a:""}|${k}`},getShaderSource:j,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(T/64)}})}},Cg=e=>{let r=e.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},cd=(e,r)=>{let t=[],u=[],a=[],p=Cg(e);dg(e.inputs,r,p,t,u,a),e.compute($g(e.inputs[0],r,p,t,u,a),{inputs:[0]})},fd=e=>{let r=e.antialias,t=e.axes,u=e.coordinateTransformMode,a=e.cubicCoeffA,p=e.excludeOutside!==0,m=e.extrapolationValue,y=e.keepAspectRatioPolicy,l=e.mode,S=e.nearestMode===""?"simple":e.nearestMode;return he({antialias:r,axes:t,coordinateTransformMode:u,cubicCoeffA:a,excludeOutside:p,extrapolationValue:m,keepAspectRatioPolicy:y,mode:l,nearestMode:S})}});var Sg,xg,md,hd,gd=ae(()=>{"use strict";Ze();ke();Le();Pe();Sg=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=e[0],t=e[1],u=e[2];if(r.dataType!==t.dataType||r.dataType!==u.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=r.dims[r.dims.length-1],p=r.dims[r.dims.length-2];if(t.dims[t.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==p)throw new Error("Skip must have the same sequence length as input");if(u.dims.length!==1)throw new Error("Gamma must be 1D");if(u.dims[u.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let m=e[3];if(m.dims.length!==1)throw new Error("Beta must be 1D");if(m.dims[m.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let m=e[4];if(m.dims.length!==1)throw new Error("Bias must be 1D");if(m.dims[m.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},xg=(e,r,t,u)=>{let a=e[0].dims,p=Z.size(a),m=a,y=p,l=a.slice(-1)[0],S=u?a.slice(0,-1).concat(1):[],A=e.length>3,P=e.length>4,T=u&&t>1,k=u&&t>2,O=t>3,R=lt(l),j=[te("x",e[0].dataType,e[0].dims,R),te("skip",e[1].dataType,e[1].dims,R),te("gamma",e[2].dataType,e[2].dims,R)];A&&j.push(te("beta",e[3].dataType,e[3].dims,R)),P&&j.push(te("bias",e[4].dataType,e[4].dims,R)),j.push(se("output",e[0].dataType,m,R)),T&&j.push(se("meanOutput",1,S)),k&&j.push(se("invStdOutput",1,S)),O&&j.push(se("inputSkipBiasSum",e[0].dataType,m,R));let M=je(e[0].dataType),z=G=>`\n      const hiddenSize: f32 = ${l};\n      const hiddenSizeVectorized: u32 = ${l/R};\n      const epsilon: f32 = ${r.epsilon};\n\n      ${G.declareVariables(...j)}\n\n      ${G.mainStart()}\n        ${G.guardAgainstOutOfBoundsWorkgroupSizes(y/l)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${ot("f32",R)};\n        var squareSum = ${ot("f32",R)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${P?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${O?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${vt(M,R,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${wt("sum",R)} / hiddenSize;\n        let variance = sqrt(${wt("squareSum",R)} / hiddenSize - mean * mean + epsilon);\n        ${T?"meanOutput[global_idx] = mean;":""}\n        ${k?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${M}(mean)) / ${M}(variance) * gamma[i]\n           + ${A?"beta[i]":"0.0"};\n        }\n      }`,q=[{dims:m,dataType:e[0].dataType}];return t>1&&q.push({dims:S,dataType:1}),t>2&&q.push({dims:S,dataType:1}),t>3&&q.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:r.cacheKey},getShaderSource:z,getRunData:()=>({outputs:q,dispatchGroup:{x:Math.ceil(y/l/64)}})}},md=(e,r)=>{Sg(e.inputs);let u=[0];e.outputCount>1&&u.push(-3),e.outputCount>2&&u.push(-3),e.outputCount>3&&u.push(3),e.compute(xg(e.inputs,r,e.outputCount,!1),{outputs:u})},hd=e=>{let r=e.epsilon;return he({epsilon:r})}});var _g,yi,Ig,yd,Ag,Tg,bd,vd,wd=ae(()=>{"use strict";Ze();ke();Le();Pe();_g=(e,r)=>{if(!e||e.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,u)=>{if(e[u+1].dataType!==6&&e[u+1].dataType!==7)throw new Error(`Input ${u} must be an array of int32 or int64`)})},yi=(e,r)=>{let t=[];if(e.length>r)if(e[r].dataType===7)e[r].getBigInt64Array().forEach(u=>t.push(Number(u)));else if(e[r].dataType===6)e[r].getInt32Array().forEach(u=>t.push(Number(u)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return t},Ig=(e,r)=>{if(e.length>1){let t=yi(e,1),u=yi(e,2),a=yi(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),he({starts:t,ends:u,axes:a})}else return r},yd=(e,r,t,u,a)=>{let p=e;return e<0&&(p+=t[u[r]]),a[r]<0?Math.max(0,Math.min(p,t[u[r]]-1)):Math.max(0,Math.min(p,t[u[r]]))},Ag=(e,r,t,u)=>`fn calculateInputIndices(outputIndices: ${r.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${t.length}; i >= 0; i--) {\n            let input_shape_i = ${Et("uniforms.input_shape","i",t.length)};\n            let steps_i = ${Et("uniforms.steps","i",t.length)};\n            let signs_i = ${Et("uniforms.signs","i",t.length)};\n            let starts_i = ${Et("uniforms.starts","i",t.length)};\n            var outputIndex = ${u.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps_i + starts_i + carry;\n            carry = inputIndex / input_shape_i;\n            inputIndex = inputIndex % input_shape_i;\n            if (signs_i < 0) {\n              inputIndex = input_shape_i - inputIndex - 1u + starts_i;\n            }\n            ${t.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Tg=(e,r)=>{let t=e[0].dims,u=Z.size(t),a=r.axes.length>0?Z.normalizeAxes(r.axes,t.length):[...Array(t.length).keys()],p=yi(e,4);p.forEach(M=>M!==0||(()=>{throw new Error("step cannot be 0")})),p.length===0&&(p=Array(a.length).fill(1));let m=r.starts.map((M,z)=>yd(M,z,t,a,p)),y=r.ends.map((M,z)=>yd(M,z,t,a,p));if(a.length!==m.length||a.length!==y.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==t.length)for(let M=0;M<t.length;++M)a.includes(M)||(m.splice(M,0,0),y.splice(M,0,t[M]),p.splice(M,0,1));let l=p.map(M=>Math.sign(M));p.forEach((M,z,q)=>{if(M<0){let G=(y[z]-m[z])/M,Y=m[z],_=Y+G*p[z];m[z]=_,y[z]=Y,q[z]=-M}});let S=t.slice(0);a.forEach((M,z)=>{S[M]=Math.ceil((y[M]-m[M])/p[M])});let A={dims:S,dataType:e[0].dataType},P=se("output",e[0].dataType,S.length),T=te("input",e[0].dataType,e[0].dims.length),k=Z.size(S),O=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:m.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:p.length}],R=[{type:"uint32",data:k},{type:"uint32",data:m},{type:"int32",data:l},{type:"uint32",data:p},...xe(e[0].dims),...xe(S)],j=M=>`\n      ${M.registerUniforms(O).declareVariables(T,P)}\n        ${Ag(T,P,t,S)}\n        ${M.mainStart()}\n          ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let outputIndices = ${P.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${P.setByOffset("global_idx",T.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${m.length}_${p.length}`,inputDependencies:["rank"]},getShaderSource:j,getRunData:()=>({outputs:[A],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:R})}},bd=(e,r)=>{_g(e.inputs,r);let t=Ig(e.inputs,r);e.compute(Tg(e.inputs,t),{inputs:[0]})},vd=e=>{let r=e.starts,t=e.ends,u=e.axes;return he({starts:r,ends:t,axes:u})}});var Eg,Og,$d,Cd,Sd=ae(()=>{"use strict";ke();Le();Pe();Eg=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Og=(e,r)=>{let t=e.dims,u=Z.size(t),a=64,p=r.axis;if(p<0&&(p=t.length+p),p<t.length-1)throw new Error("softmax only supports last axis for now.");let m=t[p],y=u/m,l=lt(m),S=m/l,A=(j,M)=>M===4?`max(max(${j}.x, ${j}.y), max(${j}.z, ${j}.w))`:M===2?`max(${j}.x, ${j}.y)`:M===3?`max(max(${j}.x, ${j}.y), ${j}.z)`:j,P=te("x",e.dataType,e.dims,l),T=se("result",e.dataType,e.dims,l),k=P.type.value,O=je(e.dataType)==="f32"?`var threadMax = ${k}(-3.402823e+38f);`:`var threadMax = ${k}(-65504.0h);`,R=j=>`\n      var<workgroup> rowMaxShared : ${k};\n      var<workgroup> rowSumShared : ${k};\n      var<workgroup> threadShared : array<${k}, ${a}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${k} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${k}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${j.registerUniform("packedCols","i32").declareVariables(P,T)}\n      ${j.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${a};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${O}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${k}(${A("threadShared[0]",l)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${k}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${k}(${wt("threadShared[0]",l)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${l}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:t,dataType:e.dataType}],dispatchGroup:{x:y},programUniforms:[{type:"uint32",data:S}]}),getShaderSource:R}},$d=(e,r)=>{Eg(e.inputs),e.compute(Og(e.inputs[0],r))},Cd=e=>he({axis:e.axis})});var kg,Pg,Rg,Bg,Mg,xd,_d,Id=ae(()=>{"use strict";ke();Le();Pe();kg=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Pg=(e,r)=>{let t=[],u=r.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>t.push(Number(a))),u=t.length),he({numOutputs:u,axis:r.axis,splitSizes:t})},Rg=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Bg=e=>{let r=e.length,t=[];for(let u=0;u<r;++u){let a=e[u].setByIndices("indices","input[global_idx]");r===1?t.push(a):u===0?t.push(`if (outputNumber == ${u}u) { ${a} }`):u===r-1?t.push(`else { ${a} }`):t.push(`else if (outputNumber == ${u}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${t.join(`\n`)}\n      }`},Mg=(e,r)=>{let t=e[0].dims,u=Z.size(t),a=e[0].dataType,p=t.length,m=r.axis,y=m<0?t.length+m:m,l=new Array(r.numOutputs),S=te("input",a,t),A=new Array(r.numOutputs),P=[],T=[],k=0;for(let j=0;j<r.numOutputs;j++){k+=r.splitSizes[j],A[j]=k;let M=t.slice();M[r.axis]=r.splitSizes[j],T.push(M),l[j]=se(`output${j}`,a,T[j]),P.push({dims:T[j],dataType:e[0].dataType})}let O=p<2?"indices":`indices[${y}]`,R=j=>`\n  ${j.declareVariables(S,...l)}\n  const sizeInConcatAxis = array<u32, ${A.length}>(${A.map(M=>`${M}u`).join(",")});\n  ${Rg(A.length)}\n  ${Bg(l)}\n\n  ${j.mainStart()}\n    ${j.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    var indices = ${S.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${O});\n    if (outputNumber != 0) {\n        ${O} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:r.cacheKey},getShaderSource:R,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(u/64)}})}},xd=(e,r)=>{kg(e.inputs);let t=e.inputs.length===1?r:Pg(e.inputs,r);e.compute(Mg(e.inputs,t),{inputs:[0]})},_d=e=>{let r=e.axis,t=e.splitSizes,u=e.numOutputs<0?t.length:e.numOutputs;if(u!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return he({axis:r,numOutputs:u,splitSizes:t})}});var Ad,Dg,jg,zg,Td,Ed=ae(()=>{"use strict";Ze();ke();Pe();Ad=e=>Array.from(e.getBigInt64Array(),Number),Dg=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Ad(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},jg=(e,r)=>{let t=[];for(let u=0;u<e.length;++u)t.push(e[u]*r[u]);return t},zg=e=>{let r=e[0].dims,t=Ad(e[1]),u=jg(r,t),a=Z.size(u),p=e[0].dataType,m=te("input",p,r),y=se("output",p,u),l=S=>`\n      const inputShape = ${m.indices(...r)};\n      ${S.declareVariables(m,y)}\n      ${S.mainStart()}\n      ${S.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${y.offsetToIndices("global_idx")};\n      var inputIndices: ${m.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let inputDimValue = ${y.indicesGet("outputIndices","i")}  % ${m.indicesGet("inputShape","i")};\n\n        ${m.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${y.setByOffset("global_idx",m.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:l}},Td=e=>{Dg(e.inputs),e.compute(zg(e.inputs),{inputs:[0]})}});var Vg,Wg,Od,kd=ae(()=>{"use strict";Ze();ke();Pe();Vg=(e,r,t,u,a)=>{let p=Z.size(t),m=Math.ceil(p/4),y=se("outputData",a,t,4),l=te("aData",r[1].dataType,r[1].dims,4),S=te("bData",r[2].dataType,r[2].dims,4),A=te("cData",r[0].dataType,r[0].dims,4),P,T=(k,O,R)=>`select(${O}, ${k}, ${R})`;if(!u)P=y.setByOffset("global_idx",T(l.getByOffset("global_idx"),S.getByOffset("global_idx"),A.getByOffset("global_idx")));else{let k=(O,R,j="")=>{let M=`aData[indexA${R}][componentA${R}]`,z=`bData[indexB${R}][componentB${R}]`,q=`bool(cData[indexC${R}] & ${4278190080>>>(3-R)*8}u)`;return`\n            let outputIndices${R} = ${y.offsetToIndices(`global_idx * 4u + ${R}u`)};\n            let offsetA${R} = ${l.broadcastedIndicesToOffset(`outputIndices${R}`,y)};\n            let offsetB${R} = ${S.broadcastedIndicesToOffset(`outputIndices${R}`,y)};\n            let offsetC${R} = ${A.broadcastedIndicesToOffset(`outputIndices${R}`,y)};\n            let indexA${R} = offsetA${R} / 4u;\n            let indexB${R} = offsetB${R} / 4u;\n            let indexC${R} = offsetC${R} / 4u;\n            let componentA${R} = offsetA${R} % 4u;\n            let componentB${R} = offsetB${R} % 4u;\n            ${O}[${R}] = ${j}(${T(M,z,q)});\n          `};a===9?P=`\n            var data = vec4<u32>(0);\n            ${k("data",0,"u32")}\n            ${k("data",1,"u32")}\n            ${k("data",2,"u32")}\n            ${k("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:P=`\n            ${k("outputData[global_idx]",0)}\n            ${k("outputData[global_idx]",1)}\n            ${k("outputData[global_idx]",2)}\n            ${k("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(A,l,S,y)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n        ${P}\n      }`},Wg=e=>{let r=e[1].dims,t=e[2].dims,u=e[0].dims,a=e[1].dataType,p=!(Z.areEqual(r,t)&&Z.areEqual(t,u)),m=r,y=Z.size(r);if(p){let l=Tt.calcShape(Tt.calcShape(r,t,!1),u,!1);if(!l)throw new Error("Can\'t perform where op on the given tensors");m=l,y=Z.size(m)}return{name:"Where",getShaderSource:l=>Vg(l,e,m,p,a),getRunData:()=>({outputs:[{dims:m,dataType:a}],dispatchGroup:{x:Math.ceil(y/64/4)}})}},Od=e=>{e.compute(Wg(e.inputs))}});var Pd,Rd=ae(()=>{"use strict";Us();Wi();su();lu();Nu();Ju();rl();qi();hl();wl();Sl();Il();El();Pl();Ml();zl();Wl();Gl();ql();ud();dd();ti();pd();gd();wd();Sd();Id();Ed();xr();Hi();kd();Pd=new Map([["Abs",[du]],["Acos",[cu]],["Acosh",[fu]],["Add",[Hu]],["ArgMax",[Ws,Vi]],["ArgMin",[Vs,Vi]],["Asin",[pu]],["Asinh",[mu]],["Atan",[hu]],["Atanh",[gu]],["Attention",[Hs,Ns]],["AveragePool",[Jl,Ql]],["BatchNormalization",[au]],["BiasAdd",[uu]],["BiasSplitGelu",[Uu]],["Cast",[bu,yu]],["Ceil",[wu]],["Clip",[vu]],["Concat",[el,tl]],["Conv",[Yi,Ki]],["ConvTranspose",[ml,pl]],["Cos",[$u]],["Cosh",[Cu]],["Div",[Gu]],["Einsum",[bl,vl]],["Elu",[Su,ui]],["Equal",[Lu]],["Erf",[xu]],["Exp",[_u]],["Expand",[Cl]],["Floor",[Iu]],["FusedConv",[Yi,Ki]],["Gather",[_l,xl]],["GatherElements",[Tl,Al]],["Gelu",[Au]],["Gemm",[Ol,kl]],["GlobalAveragePool",[rd,td]],["GlobalMaxPool",[sd,ad]],["Greater",[Yu]],["GreaterOrEqual",[Xu]],["InstanceNormalization",[Bl,Rl]],["LayerNormalization",[jl,Dl]],["LeakyRelu",[Tu,ui]],["Less",[Zu]],["LessOrEqual",[Qu]],["Log",[Wu]],["MatMul",[Vl]],["MaxPool",[id,od]],["Mul",[Fu]],["MultiHeadAttention",[Hl,Nl]],["Neg",[Ou]],["Not",[Eu]],["Pad",[Ll,Fl]],["Pow",[qu]],["Range",[ld]],["Reciprocal",[ku]],["ReduceMin",[Rs,Ct]],["ReduceMean",[Ts,Ct]],["ReduceMax",[Ps,Ct]],["ReduceSum",[Ms,Ct]],["ReduceProd",[Bs,Ct]],["ReduceL1",[Es,Ct]],["ReduceL2",[Os,Ct]],["ReduceLogSum",[js,Ct]],["ReduceLogSumExp",[ks,Ct]],["ReduceSumSquare",[Ds,Ct]],["Relu",[Pu]],["Resize",[cd,fd]],["Sigmoid",[Ru]],["Sin",[Bu]],["Sinh",[Mu]],["Slice",[bd,vd]],["SkipLayerNormalization",[md,hd]],["Split",[xd,_d]],["Sqrt",[Du]],["Softmax",[$d,Cd]],["Sub",[Ku]],["Tan",[ju]],["Tanh",[zu]],["ThresholdedRelu",[Vu,ui]],["Tile",[Td]],["Transpose",[hs,gs]],["Where",[Od]]])});var bi,Bd=ae(()=>{"use strict";Ze();zt();Pe();bi=class{constructor(r){this.backend=r;this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,t){this.repo.set(r,t)}run(r,t,u,a,p,m,y){let l=this.backend.device,S=this.backend.getComputePassEncoder();S.setPipeline(r.computePipeline);let A=[];for(let T of a)A.push({binding:A.length,resource:{buffer:T.buffer}});for(let T of p)A.push({binding:A.length,resource:{buffer:T.buffer}});y&&A.push({binding:A.length,resource:y});let P=l.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:A,label:r.programInfo.name});if(S.setBindGroup(0,P),S.dispatchWorkgroups(...m),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let T=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,T.buffer,0,this.backend.querySetCount*8),this.backend.flush();let k=this.backend.currentKernelId,O=this.backend.kernels.get(k),R=`[${O[0]}] ${O[1]}`;T.buffer.mapAsync(GPUMapMode.READ).then(()=>{let j=new BigUint64Array(T.buffer.getMappedRange()),M=j[0],z=j[1];T.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=M);let q=Number(M-this.backend.queryTimeBase),G=Number(z-this.backend.queryTimeBase);if(!Number.isSafeInteger(q)||!Number.isSafeInteger(G))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(T.id);let Y="";t.forEach((X,J)=>{Y+=`input[${J}]: [${X.dims}] | ${mn(X.dataType)}, `});let _="";u.forEach((X,J)=>{_+=`output[${J}]: [${X.dims}] | ${mn(X.dataType)}, `}),console.log(`[profiling] kernel "${k}|${R}|${r.programInfo.name}" ${Y}${_}execution time: ${G-q} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(r,t){let u=this.backend.device,a=[];u.features.has("shader-f16")&&a.push("enable f16;");let p=ps(t),m=r.getShaderSource(p),y=`${a.join(`\n`)}\n${p.additionalImplementations}\n${m}`,l=u.createShaderModule({code:y,label:r.name});Ge("verbose",()=>`[WebGPU] ${r.name} shader code: ${y}`);let S=u.createComputePipeline({compute:{module:l,entryPoint:"main"},layout:"auto",label:r.name});return{programInfo:r,computePipeline:S}}normalizeDispatchGroupSize(r){let t=typeof r=="number"?r:r.x,u=typeof r=="number"?1:r.y||1,a=typeof r=="number"?1:r.z||1,p=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=p&&u<=p&&a<=p)return[t,u,a];let m=t*u*a,y=Math.ceil(Math.sqrt(m));if(y>p){if(y=Math.ceil(Math.cbrt(m)),y>p)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[y,y,y]}else return[y,y,1]}}});var Ug,Ng,vi,Md=ae(()=>{"use strict";zt();as();ds();Rd();Bd();Ug=(e,r)=>{if(r.length!==e.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${e.length}.`);let t=[];for(let u=0;u<e.length;++u){let a=e[u].dataType;switch(r[u]){case"none":{t.push("");break}case"type":{t.push(`${a}`);break}case"rank":{let p=e[u].dims.length;t.push(`${a};${p}`);break}case"dims":{let p=e[u].dims.join(",");t.push(`${a};${p}`);break}default:throw new Error(`unsupported input dependency: ${r[u]}`)}}return t.join("|")},Ng=(e,r,t)=>{let u=e.name;return e.shaderCache?.hint&&(u+="["+e.shaderCache.hint+"]"),u+=":"+t+`:${Ug(r,e.shaderCache?.inputDependencies??new Array(r.length).fill("dims"))}`,u},vi=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=r;let u=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:u};t.features.has("timestamp-query")&&u.push("timestamp-query"),t.features.has("shader-f16")&&u.push("shader-f16"),this.device=await t.requestDevice(a),this.gpuDataManager=ls(this),this.programManager=new bi(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,is(r.logLevel,!!r.debug),this.device.onuncapturederror=p=>{p.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${p.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let r={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(r,t,u,a,p){let m=[];for(let z=0;z<t.length;++z){let q=this.gpuDataManager.get(t[z].data);if(!q)throw new Error(`no GPU data for input: ${t[z].data}`);m[z]=q}let{outputs:y,dispatchGroup:l,programUniforms:S}=r.getRunData(t),A=u.length===0?y.map((z,q)=>q):u;if(A.length!==y.length)throw new Error(`Output size ${A.length} must be equal to ${y.length}.`);let P=[],T=[];for(let z=0;z<y.length;++z){if(!Number.isInteger(A[z])||A[z]<-3||A[z]>=y.length)throw new Error(`Invalid output index: ${A[z]}`);if(A[z]===-3)continue;let q=A[z]===-1,G=A[z]===-2,Y=q||G?p(y[z].dataType,y[z].dims):a(A[z],y[z].dataType,y[z].dims),_=this.gpuDataManager.get(Y.data);if(!_)throw new Error(`no GPU data for output: ${Y.data}`);if(q&&this.temporaryData.push(_),G){let X=this.kernelPersistentData.get(this.currentKernelId);X||(X=[],this.kernelPersistentData.set(this.currentKernelId,X)),X.push(_)}P.push(Y),T.push(_)}let k;if(S){let z=0,q=[];S.forEach(X=>{let J=typeof X.data=="number"?[X.data]:X.data;if(J.length===0)return;let re=J.length<=2?J.length*4:16;z=Math.ceil(z/re)*re,q.push(z),z+=J.length>4?Math.ceil(J.length/4)*16:J.length*4});let G=16;z=Math.ceil(z/G)*G;let Y=new ArrayBuffer(z);S.forEach((X,J)=>{let re=q[J],fe=typeof X.data=="number"?[X.data]:X.data;X.type==="int32"?new Int32Array(Y,re,fe.length).set(fe):X.type==="uint32"?new Uint32Array(Y,re,fe.length).set(fe):new Float32Array(Y,re,fe.length).set(fe)});let _=this.gpuDataManager.create(z,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,Y,0,z),this.gpuDataManager.release(_.id),k={offset:0,size:z,buffer:_.buffer}}let O=this.programManager.normalizeDispatchGroupSize(l),R=O[1]===1&&O[2]===1,j=Ng(r,t,R),M=this.programManager.getArtifact(j);return M||(M=this.programManager.build(r,O),this.programManager.setArtifact(j,M),Ge("info",()=>`[artifact] key: ${j}, programName: ${r.name}`)),Ge("info",()=>`[ProgramManager] run "${r.name}" (key=${j}) with ${O[0]}x${O[1]}x${O[2]}`),this.programManager.run(M,t,P,m,T,O,k),P}upload(r,t){this.gpuDataManager.upload(r,t)}memcpy(r,t){this.gpuDataManager.memcpy(r,t)}async download(r,t){await this.gpuDataManager.download(r,t)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,t,u,a){let p=Pd.get(r);if(!p)throw new Error(`kernel not implemented: ${r}`);this.kernels.set(t,[r,a,p[0],[p[1],u]])}releaseKernel(r){let t=this.kernelPersistentData.get(r);if(t){for(let u of t)this.gpuDataManager.release(u.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,t,u){let a=this.kernels.get(r);if(!a)throw new Error(`kernel not created: ${r}`);let[p,m,y,l]=a;if(this.currentKernelId!==null)throw new Error(`kernel "[${p}] ${m}" is not allowed to be called recursively`);this.currentKernelId=r,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),Ge("info",()=>`[WebGPU] Start to run kernel "[${p}] ${m}"...`);let S=this.env.debug;this.temporaryData=[];try{return S&&this.device.pushErrorScope("validation"),y(t,l[1]),0}catch(A){return u.push(Promise.resolve(`[WebGPU] Kernel "[${p}] ${m}" failed. ${A}`)),1}finally{S&&u.push(this.device.popErrorScope().then(A=>A?`GPU validation error for kernel "[${p}] ${m}": ${A.message}`:null));for(let A of this.temporaryData)this.gpuDataManager.release(A.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,t,u,a){let p=this.sessionExternalDataMapping.get(r);p||(p=new Map,this.sessionExternalDataMapping.set(r,p));let m=p.get(t),y=this.gpuDataManager.registerExternalBuffer(u,a,m?.[1]);return p.set(t,[y,u]),y}unregisterBuffers(r){let t=this.sessionExternalDataMapping.get(r);t&&(t.forEach(u=>this.gpuDataManager.unregisterExternalBuffer(u[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let t=this.gpuDataManager.get(r);if(!t)throw new Error(`no GPU data for buffer: ${r}`);return t.buffer}createDownloader(r,t,u){return async()=>{let a=await Pi(this,r,t);return os(a.buffer,u)}}}});var Dd={};qn(Dd,{init:()=>Hg});var wn,to,Hg,jd=ae(()=>{"use strict";Ze();Md();zt();ke();wn=class e{constructor(r,t,u,a){this.module=r;this.dataType=t;this.data=u;this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=Z.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=Z.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=Z.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(Z.size(r)!==Z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,r)}},to=class{constructor(r,t,u){this.module=r;this.backend=t;this.customDataOffset=0;this.customDataSize=0;let a=r.HEAPU32,p=u>>2;this.opKernelContext=a[p++];let m=a[p++];this.outputCount=a[p++],this.customDataOffset=a[p++],this.customDataSize=a[p++];let y=[];for(let l=0;l<m;l++){let S=a[p++],A=a[p++],P=a[p++],T=[];for(let k=0;k<P;k++)T.push(a[p++]);y.push(new wn(r,S,A,T))}this.inputs=y}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(r,t){let u=t?.inputs?.map(y=>typeof y=="number"?this.inputs[y]:y)??this.inputs,a=t?.outputs??[],p=(y,l,S)=>new wn(this.module,l,this.output(y,S),S),m=(y,l)=>{let S=hn(y);if(!S)throw new Error(`Unsupported data type: ${y}`);let A=S*Z.size(l);return new wn(this.module,y,this.backend.gpuDataManager.create(A).id,l)};return this.backend.run(r,u,a,p,m)}output(r,t){let u=this.module.stackSave();try{let a=this.module.stackAlloc((1+t.length)*4),p=a>>2;this.module.HEAPU32[p++]=t.length;for(let m=0;m<t.length;m++)this.module.HEAPU32[p++]=t[m];return this.module._JsepOutput(this.opKernelContext,r,a)}catch(a){throw new Error(`Failed to generate kernel\'s output[${r}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(u)}}},Hg=async(e,r)=>{let t=e.jsepInit;if(t&&navigator.gpu){if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let u=new vi;await u.initialize(r),t(u,a=>u.alloc(a),a=>u.free(a),(a,p,m,y=!1)=>{if(y)Ge("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${p}, size=${m}`),u.memcpy(a,p);else{Ge("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${p}, size=${m}`);let l=e.HEAPU8.subarray(a,a+m);u.upload(p,l)}},async(a,p,m)=>{Ge("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${p}, size=${m}`),await u.download(a,()=>e.HEAPU8.subarray(p,p+m))},(a,p,m)=>u.createKernel(a,p,m,r.debug||r.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(p)):`${p}`),a=>u.releaseKernel(a),(a,p,m,y)=>{Ge("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${m}, kernel=${a}, contextDataOffset=${p}`);let l=new to(e,u,p);return u.computeKernel(a,l,y)})}}});var Xa;Xa=Ua();var im=Ka(),Ai,Ti=!1,Kn=!1,Za=!1,om=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},am=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},sm=(e,r)=>e?r?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":r?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Qa=async e=>{if(Ti)return Promise.resolve();if(Kn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Za)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Kn=!0;let r=e.initTimeout,t=e.numThreads,u=e.simd,a=t>1&&om(),p=u&&am(),m=e.wasmPaths,y=typeof m=="string"?m:void 0,l=sm(p,a),S=typeof m=="object"?m[l]:void 0,A=!1,P=[];if(r>0&&P.push(new Promise(T=>{setTimeout(()=>{A=!0,T()},r)})),P.push(new Promise((T,k)=>{let O=a?im:Xa,R={locateFile:(j,M)=>{if(a&&j.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ya()],{type:"text/javascript"}));if(j.endsWith(".wasm")){if(S)return S;let z=y??M;return l==="ort-wasm-simd.wasm"?z+"ort-wasm-simd.jsep.wasm":l==="ort-wasm-simd-threaded.wasm"?z+"ort-wasm-simd-threaded.jsep.wasm":z+l}return M+j}};if(a)if(typeof Blob>"u")R.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let j=`var ortWasmThreaded=${O.toString()};`;R.mainScriptUrlOrBlob=new Blob([j],{type:"text/javascript"})}O(R).then(j=>{Kn=!1,Ti=!0,Ai=j,T()},j=>{Kn=!1,Za=!0,k(j)})})),await Promise.race(P),A)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},qe=()=>{if(Ti&&Ai)return Ai;throw new Error("WebAssembly is not initialized yet.")};var Ye=(e,r)=>{let t=qe(),u=t.lengthBytesUTF8(e)+1,a=t._malloc(u);return t.stringToUTF8(e,a,u),r.push(a),a},pn=(e,r,t,u)=>{if(typeof e=="object"&&e!==null){if(t.has(e))throw new Error("Circular reference in options");t.add(e)}Object.entries(e).forEach(([a,p])=>{let m=r?r+a:a;if(typeof p=="object")pn(p,m+".",t,u);else if(typeof p=="string"||typeof p=="number")u(m,p.toString());else if(typeof p=="boolean")u(m,p?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof p}`)})},We=e=>{let r=qe(),t=r.stackSave();try{let u=r.stackAlloc(8);r._OrtGetLastError(u,u+4);let a=r.HEAP32[u/4],p=r.HEAPU32[u/4+1],m=p?r.UTF8ToString(p):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${m}`)}finally{r.stackRestore(t)}};var Ja=e=>{let r=qe(),t=0,u=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let p=0;return e?.tag!==void 0&&(p=Ye(e.tag,u)),t=r._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,p),t===0&&We("Can\'t create run options."),e?.extra!==void 0&&pn(e.extra,"",new WeakSet,(m,y)=>{let l=Ye(m,u),S=Ye(y,u);r._OrtAddRunConfigEntry(t,l,S)!==0&&We(`Can\'t set a run config entry: ${m} - ${y}.`)}),[t,u]}catch(p){throw t!==0&&r._OrtReleaseRunOptions(t),u.forEach(m=>r._free(m)),p}};var um=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},lm=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},dm=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(e.enableMemPattern=!1)},cm=(e,r,t)=>{for(let u of r){let a=typeof u=="string"?u:u.name;switch(a){case"xnnpack":a="XNNPACK";break;case"webnn":if(a="WEBNN",typeof u!="string"){let m=u;if(m?.deviceType){let y=Ye("deviceType",t),l=Ye(m.deviceType,t);qe()._OrtAddSessionConfigEntry(e,y,l)!==0&&We(`Can\'t set a session config entry: \'deviceType\' - ${m.deviceType}.`)}if(m?.numThreads){let y=m.numThreads;(typeof y!="number"||!Number.isInteger(y)||y<0)&&(y=0);let l=Ye("numThreads",t),S=Ye(y.toString(),t);qe()._OrtAddSessionConfigEntry(e,l,S)!==0&&We(`Can\'t set a session config entry: \'numThreads\' - ${m.numThreads}.`)}if(m?.powerPreference){let y=Ye("powerPreference",t),l=Ye(m.powerPreference,t);qe()._OrtAddSessionConfigEntry(e,y,l)!==0&&We(`Can\'t set a session config entry: \'powerPreference\' - ${m.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof u!="string"){let m=u;if(m?.preferredLayout){if(m.preferredLayout!=="NCHW"&&m.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${m.preferredLayout}`);let y=Ye("preferredLayout",t),l=Ye(m.preferredLayout,t);qe()._OrtAddSessionConfigEntry(e,y,l)!==0&&We(`Can\'t set a session config entry: \'preferredLayout\' - ${m.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let p=Ye(a,t);qe()._OrtAppendExecutionProvider(e,p)!==0&&We(`Can\'t append execution provider: ${a}.`)}},es=e=>{let r=qe(),t=0,u=[],a=e||{};dm(a);try{let p=um(a.graphOptimizationLevel??"all"),m=lm(a.executionMode??"sequential"),y=typeof a.logId=="string"?Ye(a.logId,u):0,l=a.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let S=a.logVerbosityLevel??0;if(!Number.isInteger(S)||S<0||S>4)throw new Error(`log verbosity level is not valid: ${S}`);let A=typeof a.optimizedModelFilePath=="string"?Ye(a.optimizedModelFilePath,u):0;if(t=r._OrtCreateSessionOptions(p,!!a.enableCpuMemArena,!!a.enableMemPattern,m,!!a.enableProfiling,0,y,l,S,A),t===0&&We("Can\'t create session options."),a.executionProviders&&cm(t,a.executionProviders,u),a.freeDimensionOverrides)for(let[P,T]of Object.entries(a.freeDimensionOverrides)){if(typeof P!="string")throw new Error(`free dimension override name must be a string: ${P}`);if(typeof T!="number"||!Number.isInteger(T)||T<0)throw new Error(`free dimension override value must be a non-negative integer: ${T}`);let k=Ye(P,u);r._OrtAddFreeDimensionOverride(t,k,T)!==0&&We(`Can\'t set a free dimension override: ${P} - ${T}.`)}return a.extra!==void 0&&pn(a.extra,"",new WeakSet,(P,T)=>{let k=Ye(P,u),O=Ye(T,u);r._OrtAddSessionConfigEntry(t,k,O)!==0&&We(`Can\'t set a session config entry: ${P} - ${T}.`)}),[t,u]}catch(p){throw t!==0&&r._OrtReleaseSessionOptions(t),u.forEach(m=>r._free(m)),p}};Ze();var Vd=!1,Gg=e=>{let r=qe(),t=r.stackSave();try{let u=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,u,u+4)!==0&&We("Can\'t get session input/output count."),[r.HEAP32[u/4],r.HEAP32[u/4+1]]}finally{r.stackRestore(t)}},Lg=(e,r)=>{qe()._OrtInit(e,r)!==0&&We("Can\'t initialize onnxruntime.")},Wd=async e=>{Lg(e.wasm.numThreads,gn(e.logLevel));{let r=(jd(),Sr(Dd)).init;await r(qe(),e)}Vd=!0},$n=new Map,Ud=()=>Vd,ro=e=>{let r=qe(),t=r._malloc(e.byteLength);if(t===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,t),[t,e.byteLength]},no=(e,r)=>{let t=qe(),u=0,a=0,p=0,m=[],y=[],l=[];try{[a,m]=es(r),u=t._OrtCreateSession(e[0],e[1],a),u===0&&We("Can\'t create a session.");let[S,A]=Gg(u),P=[],T=[],k=[];for(let R=0;R<S;R++){let j=t._OrtGetInputName(u,R);j===0&&We("Can\'t get an input name."),y.push(j),P.push(t.UTF8ToString(j))}for(let R=0;R<A;R++){let j=t._OrtGetOutputName(u,R);j===0&&We("Can\'t get an output name."),l.push(j);let M=t.UTF8ToString(j);T.push(M);{let z=typeof r?.preferredOutputLocation=="string"?r.preferredOutputLocation:r?.preferredOutputLocation?.[M]??"cpu";if(z!=="cpu"&&z!=="cpu-pinned"&&z!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${z}.`);k.push(z)}}let O=null;return k.some(R=>R==="gpu-buffer")&&(p=t._OrtCreateBinding(u),p===0&&We("Can\'t create IO binding."),O={handle:p,outputPreferredLocations:k,outputPreferredLocationsEncoded:k.map(R=>Oi(R))}),$n.set(u,[u,y,l,O]),[u,P,T]}catch(S){throw y.forEach(A=>t._OrtFree(A)),l.forEach(A=>t._OrtFree(A)),p!==0&&t._OrtReleaseBinding(p),u!==0&&t._OrtReleaseSession(u),S}finally{t._free(e[0]),a!==0&&t._OrtReleaseSessionOptions(a),m.forEach(S=>t._free(S))}},Nd=(e,r)=>{let t=ro(e);return no(t,r)},Hd=e=>{let r=qe(),t=$n.get(e);if(!t)throw new Error(`cannot release session. invalid session id: ${e}`);let[u,a,p,m]=t;m&&r._OrtReleaseBinding(m.handle),r.jsepUnregisterBuffers?.(e),a.forEach(y=>r._OrtFree(y)),p.forEach(y=>r._OrtFree(y)),r._OrtReleaseSession(u),$n.delete(e)},zd=(e,r,t,u,a)=>{if(!e){r.push(0);return}let p=qe(),m=e[0],y=e[1],l=e[3],S,A;if(m==="string"&&l==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(l==="gpu-buffer"){let k=e[2].gpuBuffer,O=hn(Ei(m));A=y.reduce((R,j)=>R*j,1)*O,S=p.jsepRegisterBuffer(u,a,k,A)}else{let k=e[2];if(Array.isArray(k)){A=4*k.length,S=p._malloc(A),t.push(S);let O=S/4;for(let R=0;R<k.length;R++){if(typeof k[R]!="string")throw new TypeError(`tensor data at index ${R} is not a string`);p.HEAPU32[O++]=Ye(k[R],t)}}else A=k.byteLength,S=p._malloc(A),t.push(S),p.HEAPU8.set(new Uint8Array(k.buffer,k.byteOffset,A),S)}let P=p.stackSave(),T=p.stackAlloc(4*y.length);try{let k=T/4;y.forEach(R=>p.HEAP32[k++]=R);let O=p._OrtCreateTensor(Ei(m),S,A,T,y.length,Oi(l));O===0&&We(`Can\'t create tensor for input/output. session=${u}, index=${a}.`),r.push(O)}finally{p.stackRestore(P)}},Gd=async(e,r,t,u,a,p)=>{let m=qe(),y=$n.get(e);if(!y)throw new Error(`cannot run inference. invalid session id: ${e}`);let[l,S,A,P]=y,T=r.length,k=u.length,O=0,R=[],j=[],M=[],z=[],q=m.stackSave(),G=m.stackAlloc(T*4),Y=m.stackAlloc(T*4),_=m.stackAlloc(k*4),X=m.stackAlloc(k*4);try{[O,R]=Ja(p);for(let me=0;me<T;me++)zd(t[me],j,z,e,r[me]);for(let me=0;me<k;me++)zd(a[me],M,z,e,T+u[me]);let J=G/4,re=Y/4,fe=_/4,L=X/4;for(let me=0;me<T;me++)m.HEAPU32[J++]=j[me],m.HEAPU32[re++]=S[r[me]];for(let me=0;me<k;me++)m.HEAPU32[fe++]=M[me],m.HEAPU32[L++]=A[u[me]];if(P){let{handle:me,outputPreferredLocations:Re,outputPreferredLocationsEncoded:ue}=P;if(S.length!==T)throw new Error(`input count from feeds (${T}) is expected to be always equal to model\'s input count (${S.length}).`);for(let Be=0;Be<T;Be++){let Me=r[Be];await m._OrtBindInput(me,S[Me],j[Be])!==0&&We(`Can\'t bind input[${Be}] for session=${e}.`)}for(let Be=0;Be<k;Be++){let Me=u[Be];a[Be]?.[3]?m._OrtBindOutput(me,A[Me],M[Be],0)!==0&&We(`Can\'t bind pre-allocated output[${Be}] for session=${e}.`):m._OrtBindOutput(me,A[Me],0,ue[Me])!==0&&We(`Can\'t bind output[${Be}] to ${Re[Be]} for session=${e}.`)}}let oe;P?oe=await m._OrtRunWithBinding(l,P.handle,k,_,O):oe=await m._OrtRun(l,Y,G,T,X,k,_,O),oe!==0&&We("failed to call OrtRun().");let Se=[];for(let me=0;me<k;me++){let Re=m.HEAPU32[_/4+me];if(Re===M[me]){Se.push(a[me]);continue}let ue=m.stackSave(),Be=m.stackAlloc(4*4),Me=!1,De,Ae=0;try{m._OrtGetTensorData(Re,Be,Be+4,Be+8,Be+12)!==0&&We(`Can\'t access output tensor data on index ${me}.`);let rt=Be/4,nt=m.HEAPU32[rt++];Ae=m.HEAPU32[rt++];let ne=m.HEAPU32[rt++],we=m.HEAPU32[rt++],Ie=[];for(let Fe=0;Fe<we;Fe++)Ie.push(m.HEAPU32[ne/4+Fe]);m._OrtFree(ne);let tt=Ie.reduce((Fe,Qe)=>Fe*Qe,1);De=mn(nt);let st=P?.outputPreferredLocations[u[me]];if(De==="string"){if(st==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Fe=[],Qe=Ae/4;for(let at=0;at<tt;at++){let xt=m.HEAPU32[Qe++],dt=at===tt-1?void 0:m.HEAPU32[Qe]-xt;Fe.push(m.UTF8ToString(xt,dt))}Se.push([De,Ie,Fe,"cpu"])}else if(st==="gpu-buffer"&&tt>0){let Fe=m.jsepGetBuffer(Ae),Qe=hn(nt);if(Qe===void 0||!ts(De))throw new Error(`Unsupported data type: ${De}`);Me=!0,Se.push([De,Ie,{gpuBuffer:Fe,download:m.jsepCreateDownloader(Fe,tt*Qe,De),dispose:()=>{m._OrtReleaseTensor(Re)}},"gpu-buffer"])}else{let Fe=Yn(De),Qe=new Fe(tt);new Uint8Array(Qe.buffer,Qe.byteOffset,Qe.byteLength).set(m.HEAPU8.subarray(Ae,Ae+Qe.byteLength)),Se.push([De,Ie,Qe,"cpu"])}}finally{m.stackRestore(ue),De==="string"&&Ae&&m._free(Ae),Me||m._OrtReleaseTensor(Re)}}return P&&m._OrtClearBoundOutputs(P.handle),Se}finally{m.stackRestore(q),j.forEach(J=>m._OrtReleaseTensor(J)),M.forEach(J=>m._OrtReleaseTensor(J)),z.forEach(J=>m._free(J)),O!==0&&m._OrtReleaseRunOptions(O),R.forEach(J=>m._free(J))}},Ld=e=>{let r=qe(),t=$n.get(e);if(!t)throw new Error("invalid session id");let u=t[0],a=r._OrtEndProfiling(u);a===0&&We("Can\'t get an profile file name."),r._OrtFree(a)},Fd=e=>{let r=[];for(let t of e){let u=t[2];!Array.isArray(u)&&"buffer"in u&&r.push(u.buffer)}return r};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{Qa(e.data.in).then(()=>postMessage({type:"init-wasm"}),r=>postMessage({type:"init-wasm",err:r}))}catch(r){postMessage({type:"init-wasm",err:r})}break;case"init-ort":try{Wd(e.data.in).then(()=>postMessage({type:"init-ort"}),r=>postMessage({type:"init-ort",err:r}))}catch(r){postMessage({type:"init-ort",err:r})}break;case"create_allocate":try{let{model:r}=e.data.in,t=ro(r);postMessage({type:"create_allocate",out:t})}catch(r){postMessage({type:"create_allocate",err:r})}break;case"create_finalize":try{let{modeldata:r,options:t}=e.data.in,u=no(r,t);postMessage({type:"create_finalize",out:u})}catch(r){postMessage({type:"create_finalize",err:r})}break;case"create":try{let{model:r,options:t}=e.data.in,u=Nd(r,t);postMessage({type:"create",out:u})}catch(r){postMessage({type:"create",err:r})}break;case"release":try{Hd(e.data.in),postMessage({type:"release"})}catch(r){postMessage({type:"release",err:r})}break;case"run":try{let{sessionId:r,inputIndices:t,inputs:u,outputIndices:a,options:p}=e.data.in;Gd(r,t,u,a,new Array(a.length).fill(null),p).then(m=>{m.some(y=>y[3]!=="cpu")?postMessage({type:"run",err:"Proxy does not support non-cpu tensor location."}):postMessage({type:"run",out:m},Fd(m))},m=>{postMessage({type:"run",err:m})})}catch(r){postMessage({type:"run",err:r})}break;case"end-profiling":try{let r=e.data.in;Ld(r),postMessage({type:"end-profiling"})}catch(r){postMessage({type:"end-profiling",err:r})}break;case"is-ort-env-initialized":try{let r=Ud();postMessage({type:"is-ort-env-initialized",out:r})}catch(r){postMessage({type:"is-ort-env-initialized",err:r})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var Ht,pt,zn,ja,Da,Aa,Ea,Ta,Oa,ka,Ra,Pa,Ba,Ma,qt,i0,Dn,Uc,Hc,Lc,Gc,za,Fc,qc,Kc,Yc,Wa=oe(()=>{"use strict";Ut();Vc();Mr();Ht=()=>!!Ve.wasm.proxy&&typeof document<"u",zn=!1,ja=!1,Da=!1,Ta=[],Oa=[],ka=[],Ra=[],Pa=[],Ba=[],Ma=[],qt=()=>{if(zn||!ja||Da||!pt)throw new Error("worker not ready")},i0=e=>{switch(e.data.type){case"init-wasm":zn=!1,e.data.err?(Da=!0,Aa[1](e.data.err)):(ja=!0,Aa[0]());break;case"init-ort":e.data.err?Ea[1](e.data.err):Ea[0]();break;case"create_allocate":e.data.err?Ta.shift()[1](e.data.err):Ta.shift()[0](e.data.out);break;case"create_finalize":e.data.err?Oa.shift()[1](e.data.err):Oa.shift()[0](e.data.out);break;case"create":e.data.err?ka.shift()[1](e.data.err):ka.shift()[0](e.data.out);break;case"release":e.data.err?Ra.shift()[1](e.data.err):Ra.shift()[0]();break;case"run":e.data.err?Pa.shift()[1](e.data.err):Pa.shift()[0](e.data.out);break;case"end-profiling":e.data.err?Ba.shift()[1](e.data.err):Ba.shift()[0]();break;case"is-ort-env-initialized":e.data.err?Ma.shift()[1](e.data.err):Ma.shift()[0](e.data.out);break;default:}},Dn=typeof document<"u"?document?.currentScript?.src:void 0,Uc=async()=>{if(Ht()){if(ja)return;if(zn)throw new Error("multiple calls to 'initWasm()' detected.");if(Da)throw new Error("previous call to 'initWasm()' failed.");return zn=!0,Ve.wasm.wasmPaths===void 0&&Dn&&Dn.indexOf("blob:")!==0&&(Ve.wasm.wasmPaths=Dn.substr(0,+Dn.lastIndexOf("/")+1)),new Promise((e,r)=>{pt?.terminate();let t=URL.createObjectURL(new Blob([Nc()],{type:"text/javascript"}));pt=new Worker(t,{name:"ort-wasm-proxy-worker"}),pt.onerror=a=>r(a),pt.onmessage=i0,URL.revokeObjectURL(t),Aa=[e,r];let s={type:"init-wasm",in:Ve.wasm};pt.postMessage(s)})}else return ou(Ve.wasm)},Hc=async e=>{if(Ht())return qt(),new Promise((r,t)=>{Ea=[r,t];let s={type:"init-ort",in:e};pt.postMessage(s)});await Pc(e)},Lc=async e=>Ht()?(qt(),new Promise((r,t)=>{Ta.push([r,t]);let s={type:"create_allocate",in:{model:e}};pt.postMessage(s,[e.buffer])})):xa(e),Gc=async(e,r)=>Ht()?(qt(),new Promise((t,s)=>{Oa.push([t,s]);let a={type:"create_finalize",in:{modeldata:e,options:r}};pt.postMessage(a)})):Ia(e,r),za=async(e,r)=>{if(Ht()){if(r?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return qt(),new Promise((t,s)=>{ka.push([t,s]);let a={type:"create",in:{model:e,options:r}};pt.postMessage(a,[e.buffer])})}else return Mc(e,r)},Fc=async e=>{if(Ht())return qt(),new Promise((r,t)=>{Ra.push([r,t]);let s={type:"release",in:e};pt.postMessage(s)});jc(e)},qc=async(e,r,t,s,a,f)=>{if(Ht()){if(t.some(p=>p[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some(p=>p))throw new Error("pre-allocated output tensor is not supported for proxy.");return qt(),new Promise((p,g)=>{Pa.push([p,g]);let u=t,w={type:"run",in:{sessionId:e,inputIndices:r,inputs:u,outputIndices:s,options:f}};pt.postMessage(w,Wc(u))})}else return Dc(e,r,t,s,a,f)},Kc=async e=>{if(Ht())return qt(),new Promise((r,t)=>{Ba.push([r,t]);let s={type:"end-profiling",in:e};pt.postMessage(s)});zc(e)},Yc=async()=>Ht()?(qt(),new Promise((e,r)=>{Ma.push([e,r]);let t={type:"is-ort-env-initialized"};pt.postMessage(t)})):Bc()});var Wn,Xc,n0,Vn,Zc=oe(()=>{"use strict";Ut();Wa();Ze();Xc=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${r()}`)}},n0=e=>{switch(e[3]){case"cpu":return new ot(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!gn(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:t,download:s,dispose:a}=e[2];return ot.fromGpuBuffer(t,{dataType:r,dims:e[1],download:s,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},Vn=class{async createSessionAllocate(r){let t=await fetch(r);if(t.status!==200)throw new Error(`failed to load model: ${r}`);let s=await t.arrayBuffer();return Lc(new Uint8Array(s))}async loadModel(r,t){if(await Yc()||(Wn||(Wn=Hc(Ve)),await Wn,Wn=void 0),typeof r=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let s=await(void 0)(r);[this.sessionId,this.inputNames,this.outputNames]=await za(s,t)}else{let s=await this.createSessionAllocate(r);[this.sessionId,this.inputNames,this.outputNames]=await Gc(s,t)}else[this.sessionId,this.inputNames,this.outputNames]=await za(r,t)}async dispose(){return Fc(this.sessionId)}async run(r,t,s){let a=[],f=[];Object.entries(r).forEach(x=>{let O=x[0],k=x[1],P=this.inputNames.indexOf(O);if(P===-1)throw new Error(`invalid input '${O}'`);a.push(k),f.push(P)});let p=[],g=[];Object.entries(t).forEach(x=>{let O=x[0],k=x[1],P=this.outputNames.indexOf(O);if(P===-1)throw new Error(`invalid output '${O}'`);p.push(k),g.push(P)});let u=a.map((x,O)=>Xc(x,()=>`input "${this.inputNames[f[O]]}"`)),w=p.map((x,O)=>x?Xc(x,()=>`output "${this.outputNames[g[O]]}"`):null),C=await qc(this.sessionId,f,u,g,w,s),T={};for(let x=0;x<C.length;x++)T[this.outputNames[g[x]]]=p[x]??n0(C[x]);return T}startProfiling(){}endProfiling(){Kc(this.sessionId)}}});var a0,Nn,Qc=oe(()=>{"use strict";Ut();Wa();Zc();a0=()=>{if((typeof Ve.wasm.initTimeout!="number"||Ve.wasm.initTimeout<0)&&(Ve.wasm.initTimeout=0),typeof Ve.wasm.simd!="boolean"&&(Ve.wasm.simd=!0),typeof Ve.wasm.proxy!="boolean"&&(Ve.wasm.proxy=!1),typeof Ve.wasm.numThreads!="number"||!Number.isInteger(Ve.wasm.numThreads)||Ve.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ve.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Nn=class{async init(){a0(),await Uc()}async createInferenceSessionHandler(r,t){let s=new Vn;return await s.loadModel(r,t),Promise.resolve(s)}}});var Jc={};Br(Jc,{wasmBackend:()=>o0});var o0,ef=oe(()=>{"use strict";Qc();o0=new Nn});Ut();Ut();Ut();var Fs="1.17.0";var CC=Gn;{let e=(ef(),sr(Jc)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&Lt("webgpu",e,5),Lt("cpu",e,10),Lt("wasm",e,10),Lt("xnnpack",e,9),Lt("webnn",e,9)}Object.defineProperty(Ve.versions,"web",{value:Fs,enumerable:!0});export{um as InferenceSession,ot as Tensor,dm as TrainingSession,CC as default,Ve as env,Lt as registerBackend};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
